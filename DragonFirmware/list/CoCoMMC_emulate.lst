                      (    DragonMMC.asm):00001         ;
                      (    DragonMMC.asm):00002         ; DragonPicoSD system ROM,
                      (    DragonMMC.asm):00003         ;
                      (    DragonMMC.asm):00004         ; 2011-06-13, Phill Harvey-Smith.
                      (    DragonMMC.asm):00005         ;
                      (    DragonMMC.asm):00006         ; Fixed for assembly with "mamou" cross-assembler,
                      (    DragonMMC.asm):00007         ; from NitrOS9 cocotools.
                      (    DragonMMC.asm):00008         ;
                      (    DragonMMC.asm):00009         ; 2012-10-07,   Began porting to CoCo.
                      (    DragonMMC.asm):00010         ;
                      (    DragonMMC.asm):00011         ; 2012-10-20,   Began merging with SuperDos for dos disk image emulation.
                      (    DragonMMC.asm):00012         ;
                      (    DragonMMC.asm):00013         ; 2016-03-21,   Abandoned use of Superdos, and reverted to a bugfixed 
                      (    DragonMMC.asm):00014         ;               Dragondos (1.3) for Dragon disk emulation.
                      (    DragonMMC.asm):00015         ;
                      (    DragonMMC.asm):00016         ; 2016-04-05,   Implemented RSDOS disk emulation.
                      (    DragonMMC.asm):00017         ;
                      (    DragonMMC.asm):00018         ; 2017-03-04,   Began implementing NMI handler for snapshot button.
                      (    DragonMMC.asm):00019         ;
                      (    DragonMMC.asm):00020         ; 2017-03-07,   Fixed a bug that caused MTAPERUN to crash if called from a program,
                      (    DragonMMC.asm):00021         ;               caused by stack being over-written. Fixed by effectively doing a
                      (    DragonMMC.asm):00022         ;                               clear 200,ramtop, to restore the machine to it's default power on 
                      (    DragonMMC.asm):00023         ;                               state.
                      (    DragonMMC.asm):00024         ;
                      (    DragonMMC.asm):00025         ; 2017-03-10,   Fixed a further bug with MTAPERUN caused by the fix to the stack 
                      (    DragonMMC.asm):00026         ;                               overwrite, where FlagonBird would crash on loading due to the 
                      (    DragonMMC.asm):00027         ;                               return address from MTAPERUN being destroyed by the clear above.
                      (    DragonMMC.asm):00028         ;                               we now save and restore the return address so that on exit MTAPERUN
                      (    DragonMMC.asm):00029         ;                               returns to the BASIC loop where it left off!
                      (    DragonMMC.asm):00030         ;                               MTAPERUN now also tries to validate that the EXEC address is within
                      (    DragonMMC.asm):00031         ;                               the area of memory loaded and only calls it if this is true.
                      (    DragonMMC.asm):00032         ;                               Implemented CFTypeE and CFTypeL to retrieve the EXEC and Load addresses
                      (    DragonMMC.asm):00033         ;                               of the next tape file.
                      (    DragonMMC.asm):00034         ; 
                      (    DragonMMC.asm):00035         ; 2017-03-10,   Note to self, calling a routine that does hardware IO with the wrong
                      (    DragonMMC.asm):00036         ;                               register contents leads to a crash!
                      (    DragonMMC.asm):00037         ;
                      (    DragonMMC.asm):00038         ; 2017-03-14,   Patched so that Basic programs will auto run when loaded, the CLOAD
                      (    DragonMMC.asm):00039         ;                               command never returns and jumps directly into the basic main interpreter
                      (    DragonMMC.asm):00040         ;                               loop. So we patch it in two ways, for tokenized programs we patch the RAM
                      (    DragonMMC.asm):00041         ;                               copy of the ROM to call a routine in the MMC rom to tidy up and run the 
                      (    DragonMMC.asm):00042         ;                               program. For ASCII programs we hook the "finish loading ASCII program" vector
                      (    DragonMMC.asm):00043         ;                               and cause it to run the program.
                      (    DragonMMC.asm):00044         ;
                      (    DragonMMC.asm):00045         ; 2017-03-20,   Moved SAM bits saving into CPLD as AVR could not give quick enough response
                      (    DragonMMC.asm):00046         ;               time and was therefore dropping bits.
                      (    DragonMMC.asm):00047         ;               Implemented NMI handler with menu that handles cold / warm re-booting and
                      (    DragonMMC.asm):00048         ;               Memory snapshots.
                      (    DragonMMC.asm):00049         ; 
                      (    DragonMMC.asm):00050         ; 2017-04-03,   Fixed BASIC program auto load / run bug that was borking PImania, caused by
                      (    DragonMMC.asm):00051         ;                               the wrong basic vector being patched leading to it being called in a recursive
                      (    DragonMMC.asm):00052         ;                               loop and overwriting the RAM by blowing the stack up :(
                      (    DragonMMC.asm):00053         ;                               Implemented conditianally assembled code that allows MCAS and auto-running basic 
                      (    DragonMMC.asm):00054         ;                               to be emulated in MESS, to help fix above.
                      (    DragonMMC.asm):00055         ;
                      (    DragonMMC.asm):00056         ; 2017-07-29    Implemented MMIRROR and MMIRRORA commands for capturing tape input to a cas file
                      (    DragonMMC.asm):00057         ;                               stored on the card.
                      (    DragonMMC.asm):00058         ;
                      (    DragonMMC.asm):00059         ; 2017-08-02    Removed array address function as will not be needed now that the AVR sorts files.
                      (    DragonMMC.asm):00060         ;                               Removal of dead code, streamlining prior to first full release.
                      (    DragonMMC.asm):00061         ;
                      (    DragonMMC.asm):00062         ; 2017-09-08    Forked to V1.00 for release.
                      (    DragonMMC.asm):00063         ;
                      (    DragonMMC.asm):00064         ; 2017-09-11    Began work on V1.10.
                      (    DragonMMC.asm):00065         ;                               Implemented MSETCFGS and MSETCFGC to set and clear the bits specified in the 
                      (    DragonMMC.asm):00066         ;                               config byte. So something like MSETCFGS $80,0 will set bit 7 of the system config 
                      (    DragonMMC.asm):00067         ;                               but leave bits 6..0 unchanged. Basically 'S' is OR cfgbyte and 'C' is AND NOT cfgbyte.
                      (    DragonMMC.asm):00068         ;
                      (    DragonMMC.asm):00069         ;
                      (    DragonMMC.asm):00070         ; 2017-10-08    Beta test release of 1.10.
                      (    DragonMMC.asm):00071         ;               Changes :
                      (    DragonMMC.asm):00072         ;                   
                      (    DragonMMC.asm):00073         ;                   Added MSETCFGs MSETCFGc to set and clear individual bits in config. 
                      (    DragonMMC.asm):00074         ;                   Added MLOADc to clear back to power on state and then do an MLOADa
                      (    DragonMMC.asm):00075         ;
                      (    DragonMMC.asm):00076         ;                   AVR firmware 2.70 now makes a bak file if an attempt to create an
                      (    DragonMMC.asm):00077         ;                   already existing file is made, instead of generating an error.
                      (    DragonMMC.asm):00078         ;
                      (    DragonMMC.asm):00079         ;                   Partially Re-written Dragon / RS dos emulation code to pass head and
                      (    DragonMMC.asm):00080         ;                   sector to AVR code, this allows us to create disk images.
                      (    DragonMMC.asm):00081         ;
                      (    DragonMMC.asm):00082         ;                   Before loading AUTOEXEC.DGN / .CCO the firmware now prints an autoboot 
                      (    DragonMMC.asm):00083         ;                   message and waits for 1 second before booting. Pressing space during the
                      (    DragonMMC.asm):00084         ;                   wait will abort the auto boot.
                      (    DragonMMC.asm):00085         ;
                      (    DragonMMC.asm):00086         ; 2024-10-02    Made changes to port to running on the Raspbery Pi Pico 2, these included:
                      (    DragonMMC.asm):00087         ;                                       Merging the read and write data register into one.
                      (    DragonMMC.asm):00088         ;                                       Adding a one byte latch read register for single byte results which
                      (    DragonMMC.asm):00089         ;                                       saves having to send the read_data command to get the result.
                      (    DragonMMC.asm):00090         ;                                       Removed RAM control register and replaced it with commands to get and
                      (    DragonMMC.asm):00091         ;                                       set it.
                      (    DragonMMC.asm):00092         ;                                       Removed PIA replacement and tape emulation code as no longer required.
                      (    DragonMMC.asm):00093         ;
                      (    DragonMMC.asm):00094         ; 2024-11-07    All commands now return a result, in result register.
                      (    DragonMMC.asm):00095         ;                                       Busy flag changed to bit 7 so we can use a simple tst/bmi loop.
                      (    DragonMMC.asm):00096         ;
                      (    DragonMMC.asm):00097         ;       
                      (    DragonMMC.asm):00098         
                      (    DragonMMC.asm):00099         ; These are defined by the makefile
                      (    DragonMMC.asm):00100         ;
                      (    DragonMMC.asm):00101         ;DragonDos              EQU             1       ; Define this if compiling for Standard DragonDos Cart.
                      (    DragonMMC.asm):00102         ;DragonAlpha    EQU             1       ; Define this if compiling for Dragon Alpha.
                      (    DragonMMC.asm):00103         ;RSDos                  EQU             1       ; Define this if compiling for the RS-DOS cart.
                      (    DragonMMC.asm):00104         
                      (    DragonMMC.asm):00105         ; Set to > 0 to enable debugging 
     0000             (    DragonMMC.asm):00106         DEBUG           EQU         0
                      (    DragonMMC.asm):00107         
                      (    DragonMMC.asm):00108         #Set to 1 for development version, mainly just affects signon message :)
     0001             (    DragonMMC.asm):00109         DEVEL           EQU             1
                      (    DragonMMC.asm):00110         
                      (    DragonMMC.asm):00111                                 use             cpudefs.asm
                      (      cpudefs.asm):00001         ;
                      (      cpudefs.asm):00002         ; CPUDEFS
                      (      cpudefs.asm):00003         ;
                      (      cpudefs.asm):00004         
                      (      cpudefs.asm):00005         ; bitmasks for flags
     0001             (      cpudefs.asm):00006         FlagCarry               equ             $01
     0002             (      cpudefs.asm):00007         FlagOverflow    equ             $02
     0004             (      cpudefs.asm):00008         FlagZero                equ             $04
     0008             (      cpudefs.asm):00009         FlagNegative    equ             $08
     0010             (      cpudefs.asm):00010         FlagIRQ                 equ             $10
     0020             (      cpudefs.asm):00011         FlagHlafCarry   equ             $20
     0040             (      cpudefs.asm):00012         FlagFIRQ                equ             $40
     0080             (      cpudefs.asm):00013         FlagEntire              equ             $80
                      (      cpudefs.asm):00014         
     FFF2             (      cpudefs.asm):00015         HWVecBase               equ             $FFF2
     FFF2             (      cpudefs.asm):00016         HWVecSWI3               equ             $FFF2
     FFF4             (      cpudefs.asm):00017         HWVecSWI2               equ             $FFF4
     FFF6             (      cpudefs.asm):00018         HWVecFIRQ               equ             $FFF6
     FFF8             (      cpudefs.asm):00019         HWVecIRQ                equ             $FFF8
     FFFA             (      cpudefs.asm):00020         HWVecSWI                equ             $FFFA
     FFFC             (      cpudefs.asm):00021         HWVecNMI                equ             $FFFC
     FFFE             (      cpudefs.asm):00022         HWVecReset              equ             $FFFE
                      (      cpudefs.asm):00023         
     0007             (      cpudefs.asm):00024         HWVecCount              equ             $7
                      (      cpudefs.asm):00025         
                      (      cpudefs.asm):00026         
                      (      cpudefs.asm):00027         
                      (      cpudefs.asm):00028         
                      (    DragonMMC.asm):00112                                 use             dgndefs.asm
                      (      dgndefs.asm):00001         *
                      (      dgndefs.asm):00002         * Deinitions for ports on Dragon 32/64/Alpha.
                      (      dgndefs.asm):00003         *
                      (      dgndefs.asm):00004         * 2004-11-16. P.Harvey-Smith.
                      (      dgndefs.asm):00005         *       Fixed the stupid error I made in the defines below
                      (      dgndefs.asm):00006         *       that made all the non DPxxxxx defines equal to FF00 !!!
                      (      dgndefs.asm):00007         *
                      (      dgndefs.asm):00008         * 2004-10-10. P.Harvey-Smith.
                      (      dgndefs.asm):00009         *       Tidyed up a little, moved romdefs into their own file.
                      (      dgndefs.asm):00010         *
                      (      dgndefs.asm):00011         * 2017-03-17.  P.Harvey-Smith.
                      (      dgndefs.asm):00012         *   Changed tabs to be 4 characters.
                      (      dgndefs.asm):00013         
                      (      dgndefs.asm):00014         ;TextScreenBase  equ $0400               ; Default text screen base
     0600             (      dgndefs.asm):00015         GraphScreenBase equ $0600               ; Default Graphics screen base
                      (      dgndefs.asm):00016         
     0020             (      dgndefs.asm):00017         TextLineLen equ     32                  ; 32 characters / line
                      (      dgndefs.asm):00018         
                      (      dgndefs.asm):00019         
     FF00             (      dgndefs.asm):00020         IO                  equ         $ff00               ; IO page on Dragon
                      (      dgndefs.asm):00021         
                      (      dgndefs.asm):00022         *
                      (      dgndefs.asm):00023         * Most of these symbols will be defined twice, as some 
                      (      dgndefs.asm):00024         * of the Dragon code, sets DP=$FF, and uses direct page
                      (      dgndefs.asm):00025         * addressing to access the io ports, whilst some of it
                      (      dgndefs.asm):00026         * uses absolute addressing.
                      (      dgndefs.asm):00027         * The versions starting DP must be used with DP=$FF.
                      (      dgndefs.asm):00028         *
                      (      dgndefs.asm):00029         
     0004             (      dgndefs.asm):00030         PIACRDDR    equ     $04                 ; Select DDR or Data reg
                      (      dgndefs.asm):00031         
                      (      dgndefs.asm):00032         *Pia 0 and 1 standard on all Dragons.
                      (      dgndefs.asm):00033         
     0000             (      dgndefs.asm):00034         DPPIA0DA        EQU             $00                         ; Side A Data/DDR
     0001             (      dgndefs.asm):00035         DPPIA0CRA       EQU             $01                         ; Side A Control.
     0002             (      dgndefs.asm):00036         DPPIA0DB        EQU             $02                         ; Side B Data/DDR
     0003             (      dgndefs.asm):00037         DPPIA0CRB       EQU             $03                         ; Side B Control.
                      (      dgndefs.asm):00038         
     FF00             (      dgndefs.asm):00039         PIA0DA          EQU             DPPIA0DA+IO             ; Side A Data/DDR
     FF01             (      dgndefs.asm):00040         PIA0CRA         EQU             DPPIA0CRA+IO        ; Side A Control.
     FF02             (      dgndefs.asm):00041         PIA0DB          EQU             DPPIA0DB+IO             ; Side A Data/DDR
     FF03             (      dgndefs.asm):00042         PIA0CRB         EQU             DPPIA0CRB+IO        ; Side A Control.
                      (      dgndefs.asm):00043         
     0020             (      dgndefs.asm):00044         DPPIA1DA        EQU             $20                         ; Side A Data/DDR
     0021             (      dgndefs.asm):00045         DPPIA1CRA       EQU             $21                         ; Side A Control.
     0022             (      dgndefs.asm):00046         DPPIA1DB        EQU             $22                         ; Side B Data/DDR
     0023             (      dgndefs.asm):00047         DPPIA1CRB       EQU             $23                         ; Side B Control.
                      (      dgndefs.asm):00048         
     FF20             (      dgndefs.asm):00049         PIA1DA          EQU             DPPIA1DA+IO             ; Side A Data/DDR
     FF21             (      dgndefs.asm):00050         PIA1CRA         EQU             DPPIA1CRA+IO        ; Side A Control.
     FF22             (      dgndefs.asm):00051         PIA1DB          EQU             DPPIA1DB+IO             ; Side A Data/DDR
     FF23             (      dgndefs.asm):00052         PIA1CRB         EQU             DPPIA1CRB+IO        ; Side A Control.
                      (      dgndefs.asm):00053         
                      (      dgndefs.asm):00054         * Dragon Alpha has a third PIA at FF24.
                      (      dgndefs.asm):00055         
     0024             (      dgndefs.asm):00056         DPPIA2DA        EQU             $24                         ; Side A Data/DDR
     0025             (      dgndefs.asm):00057         DPPIA2CRA       EQU             $25                         ; Side A Control.
     0026             (      dgndefs.asm):00058         DPPIA2DB        EQU             $26                         ; Side B Data/DDR
     0027             (      dgndefs.asm):00059         DPPIA2CRB       EQU             $27                         ; Side B Control.
                      (      dgndefs.asm):00060         
     FF24             (      dgndefs.asm):00061         PIA2DA          EQU             DPPIA2DA+IO             ; Side A Data/DDR
     FF25             (      dgndefs.asm):00062         PIA2CRA         EQU             DPPIA2CRA+IO        ; Side A Control.
     FF26             (      dgndefs.asm):00063         PIA2DB          EQU             DPPIA2DB+IO             ; Side A Data/DDR
     FF27             (      dgndefs.asm):00064         PIA2CRB         EQU             DPPIA2CRB+IO        ; Side A Control.
                      (      dgndefs.asm):00065         
                      (      dgndefs.asm):00066         ;WD2797 Floppy disk controler, used in Alpha Note registers in reverse order !
     002F             (      dgndefs.asm):00067         DPCmdRegA       EQU             $2F                         ; command/status                    
     002E             (      dgndefs.asm):00068         DPTrkRegA       EQU             $2E                         ; Track register
     002D             (      dgndefs.asm):00069         DPSecRegA       EQU             $2D                         ; Sector register
     002C             (      dgndefs.asm):00070         DPDataRegA      EQU             $2C                         ; Data register
                      (      dgndefs.asm):00071         
     ????             (      dgndefs.asm):00072         CmdRegA         EQU             DPCMDREGA+IO        ; command/status                    
     ????             (      dgndefs.asm):00073         TrkRegA         EQU             DPTRKREGA+IO        ; Track register
     ????             (      dgndefs.asm):00074         SecRegA         EQU             DPSECREGA+IO        ; Sector register
     ????             (      dgndefs.asm):00075         DataRegA        EQU             DPDATAREGA+IO       ; Data register
                      (      dgndefs.asm):00076         
                      (      dgndefs.asm):00077         ; Constants for Alpha AY-8912 sound chip, which is used to control
                      (      dgndefs.asm):00078         ; Drive select and motor on the Alpha
                      (      dgndefs.asm):00079         
     000E             (      dgndefs.asm):00080         AYIOREG         EQU             $0E                         ; AY-8912, IO Register number.
     0000             (      dgndefs.asm):00081         AYIdle          EQU             $00                         ; Make AY Idle.
     0001             (      dgndefs.asm):00082         AYWriteReg      EQU             $01                         ; Write AY Register
     0002             (      dgndefs.asm):00083         AYReadReg       EQU             $02                         ; Read AY Register
     0003             (      dgndefs.asm):00084         AYREGLatch      EQU             $03                         ; Latch register into AY
                      (      dgndefs.asm):00085         
     0003             (      dgndefs.asm):00086         DSMask          EQU             $03                         ; Drive select mask.
     0004             (      dgndefs.asm):00087         MotorMask       EQU             $04                         ; Motor enable mask
     0008             (      dgndefs.asm):00088         DDENMask        EQU             $08                         ; DDEN Mask
     0010             (      dgndefs.asm):00089         ENPMask         EQU             $10                         ; Enable Precomp mask
     0020             (      dgndefs.asm):00090         NMIMask         EQU             $20                         ; NMI enable Mask
                      (      dgndefs.asm):00091         
                      (      dgndefs.asm):00092         ; Dragon 64/Alpha Serial port.
     0004             (      dgndefs.asm):00093         DPAciaData      EQU             $04                         ; Acia Rx/Tx Register
     0005             (      dgndefs.asm):00094         DPAciaStat      EQU             $05                         ; Acia status register
     0006             (      dgndefs.asm):00095         DPAciaCmd       EQU             $06                         ; Acia command register
     0007             (      dgndefs.asm):00096         DPAciaCtrl      EQU             $07                         ; Acia control register
                      (      dgndefs.asm):00097         
     FF04             (      dgndefs.asm):00098         AciaData        EQU             DPAciaData+IO       ; Acia Rx/Tx Register
     FF05             (      dgndefs.asm):00099         AciaStat        EQU             DPAciaStat+IO       ; Acia status register
     FF06             (      dgndefs.asm):00100         AciaCmd         EQU             DPAciaCmd+IO        ; Acia command register
     FF07             (      dgndefs.asm):00101         AciaCtrl        EQU             DPAciaCtrl+IO       ; Acia control register
                      (      dgndefs.asm):00102         
                      (      dgndefs.asm):00103         ; Dragon Alpha Modem port (6850)
                      (      dgndefs.asm):00104         
     0028             (      dgndefs.asm):00105         DPModemCtrl     EQU             $28                         ; Modem Control/Status
     0029             (      dgndefs.asm):00106         DPModemData     EQU             $29                         ; Modem Rx/Tx Data
                      (      dgndefs.asm):00107         
     FF28             (      dgndefs.asm):00108         ModemCtrl       EQU             DPModemCtrl+IO      ; Modem Control/Status
     FF29             (      dgndefs.asm):00109         ModemData       EQU             DPModemData+IO      ; Modem Rx/Tx Data
                      (      dgndefs.asm):00110         
                      (      dgndefs.asm):00111         ;DragonDos Cartrage IO for WD2797
                      (      dgndefs.asm):00112         
                      (      dgndefs.asm):00113         ;WD2797 Floppy disk controler, used in DragonDos.
     0040             (      dgndefs.asm):00114         DPCmdRegD       EQU             $40                         ; command/status                    
     0041             (      dgndefs.asm):00115         DPTrkRegD       EQU             $41                         ; Track register
     0042             (      dgndefs.asm):00116         DPSecRegD       EQU             $42                         ; Sector register
     0043             (      dgndefs.asm):00117         DPDataRegD      EQU             $43                         ; Data register
                      (      dgndefs.asm):00118         
     ????             (      dgndefs.asm):00119         CmdRegD         EQU             DPCMDREGD+IO        ; command/status    4               
     ????             (      dgndefs.asm):00120         TrkRegD         EQU             DPTRKREGD+IO        ; Track register
     ????             (      dgndefs.asm):00121         SecRegD         EQU             DPSECREGD+IO        ; Sector register
     ????             (      dgndefs.asm):00122         DataRegD        EQU             DPDATAREGD+IO       ; Data register
                      (      dgndefs.asm):00123         
     0048             (      dgndefs.asm):00124         DPDSKCTLD       EQU             $48                         ; Disk DS/motor control reg
     FF48             (      dgndefs.asm):00125         DSKCTLD         EQU             DPDSKCTLD+IO            
                      (      dgndefs.asm):00126         
                      (      dgndefs.asm):00127         ; Disk IO bitmasks (DragonDos).
                      (      dgndefs.asm):00128         
     0020             (      dgndefs.asm):00129         NMIEnD          EQU             %00100000 
     0010             (      dgndefs.asm):00130         WPCEnD          EQU     %00010000 
     0008             (      dgndefs.asm):00131         SDensEnD        EQU     %00001000 
     0004             (      dgndefs.asm):00132         MotorOnD        EQU     %00000100 
     0000             (      dgndefs.asm):00133         Drive0D         EQU             %00000000
     0001             (      dgndefs.asm):00134         Drive1D         EQU             %00000001
     0002             (      dgndefs.asm):00135         Drive2D         EQU             %00000010
     0003             (      dgndefs.asm):00136         Drive3D         EQU             %00000011
     0003             (      dgndefs.asm):00137         DriveMaskD      EQU             %00000011               ; Mask to extract drives
                      (      dgndefs.asm):00138         
                      (      dgndefs.asm):00139         ; Disk IO bitmasks (Dragon Alpha).
                      (      dgndefs.asm):00140         
                      (      dgndefs.asm):00141         ;NMIEnA         EQU             %10000000               ; This is just a guess, but in current code just used as a flag 
     0080             (      dgndefs.asm):00142         Drive5or8       EQU             %10000000               ; is drive in 5" or 8" mode Acording to circuit trace on R.Harding's machine
     0040             (      dgndefs.asm):00143         WPCEnA          EQU             %01000000               ; Acording to circuit trace by R.Harding.
     0020             (      dgndefs.asm):00144         SDensEnA        EQU             %00100000               ; DDen Acording to circuit trace on R.Harding's machine
     0010             (      dgndefs.asm):00145         MotorOnA        EQU             %00010000       
     0001             (      dgndefs.asm):00146         Drive0A         EQU             %00000001               ; Drive selects acording to OS9 headers
     0002             (      dgndefs.asm):00147         Drive1A         EQU             %00000010
     0004             (      dgndefs.asm):00148         Drive2A         EQU             %00000100
     0008             (      dgndefs.asm):00149         Drive3A         EQU             %00001000
     000F             (      dgndefs.asm):00150         DriveMaskA      EQU             %00001111               ; Mask to extract drives
                      (      dgndefs.asm):00151         
                      (      dgndefs.asm):00152         ; On the Alpha, NMI is enabled/disabled by setting CA2 of the third PIA, High=enabled.
                      (      dgndefs.asm):00153         
                      (      dgndefs.asm):00154         ;WD1793/1772 Floppy disk controler, used in RS-DOS.
     0048             (      dgndefs.asm):00155         DPCmdRegT       EQU             $48                         ; command/status                    
     0049             (      dgndefs.asm):00156         DPTrkRegT       EQU             $49                         ; Track register
     004A             (      dgndefs.asm):00157         DPSecRegT       EQU             $4A                         ; Sector register
     004B             (      dgndefs.asm):00158         DPDataRegT      EQU             $4B                         ; Data registerT
                      (      dgndefs.asm):00159         
     ????             (      dgndefs.asm):00160         CmdRegT         EQU             DPCMDREGT+IO        ; command/status    4               
     ????             (      dgndefs.asm):00161         TrkRegT         EQU             DPTRKREGT+IO        ; Track register
     ????             (      dgndefs.asm):00162         SecRegT         EQU             DPSECREGT+IO        ; Sector register
     ????             (      dgndefs.asm):00163         DataRegT        EQU             DPDATAREGT+IO       ; Data register
                      (      dgndefs.asm):00164         
     0040             (      dgndefs.asm):00165         DPDSKCTLT       EQU             $40                         ; Disk DS/motor control reg
     FF40             (      dgndefs.asm):00166         DSKCTLT         EQU             DPDSKCTLT+IO            
                      (      dgndefs.asm):00167         
                      (      dgndefs.asm):00168         ; Disk IO bitmasks (RSDos FD-500).
                      (      dgndefs.asm):00169         
     0080             (      dgndefs.asm):00170         HaltEn          EQU             %10000000               ; Halt enable
     0040             (      dgndefs.asm):00171         SS0             EQU             %01000000               ; Side select
     0020             (      dgndefs.asm):00172         SDensEnT        EQU             %00100000               ; Double density enable 
     0020             (      dgndefs.asm):00173         NMIEnT          EQU             %00100000               ; Enable NMI, always enabled when in DD mode
     0010             (      dgndefs.asm):00174         WPCEnT          EQU             %00010000       
     0008             (      dgndefs.asm):00175         MotorOnT        EQU             %00001000               ; Drive selects only 3
     0001             (      dgndefs.asm):00176         Drive0T         EQU             %00000001
     0002             (      dgndefs.asm):00177         Drive1T         EQU             %00000010
     0004             (      dgndefs.asm):00178         Drive2T         EQU             %00000100
     0004             (      dgndefs.asm):00179         Drive3T         EQU             %00000100               ; Drive 3 same as drive 2 !
     0007             (      dgndefs.asm):00180         DriveMaskT      EQU             %00000111               ; Mask to extract drives
     000F             (      dgndefs.asm):00181         DriveOffMaskT EQU       MotorOnT+DriveMaskT     
                      (    DragonMMC.asm):00113                                 use             dosdefs.asm
                      (      dosdefs.asm):00001         ;
                      (      dosdefs.asm):00002         ; SuperDos E6, Copyright (C) 1986 ???, Grosvenor.
                      (      dosdefs.asm):00003         ;
                      (      dosdefs.asm):00004         ; Disassembled 2004-11-05, P.Harvey-Smith.
                      (      dosdefs.asm):00005         ;
                      (      dosdefs.asm):00006         ; 2005-10-10, forked ram vars into seperate include file.
                      (      dosdefs.asm):00007         ;
                      (      dosdefs.asm):00008         
     0010             (      dosdefs.asm):00009         TrackPrecomp    EQU     $10             ; Track to enable precomp if greater
                      (      dosdefs.asm):00010         
     0012             (      dosdefs.asm):00011         SectorsPerTrack EQU     $12             ; Sectors per track
     0028             (      dosdefs.asm):00012         FmtDefTracks    EQU     $28             ; Default tracks for format
     0001             (      dosdefs.asm):00013         FmtDefSides     EQU     $01
                      (      dosdefs.asm):00014         
     0004             (      dosdefs.asm):00015         MaxDriveNo      EQU     $04             ; Maximum valid drive no
     000E             (      dosdefs.asm):00016         MaxFilenameLen  EQU     $0E             ; Max filename length, DriveNo:Filename.EXT
                      (      dosdefs.asm):00017         
                      (      dosdefs.asm):00018         ;
                      (      dosdefs.asm):00019         ; Boot command related.
                      (      dosdefs.asm):00020         ;
                      (      dosdefs.asm):00021         
     0003             (      dosdefs.asm):00022         BootFirstSector EQU     $03             ; Boot sector is track 0 sector 3
     0012             (      dosdefs.asm):00023         BootLastSector  EQU     $12             ; Last sector of boot
     4F53             (      dosdefs.asm):00024         BootSignature   EQU     $4F53           ; Boot signature 'OS'
     2600             (      dosdefs.asm):00025         BootLoadAddr    EQU     $2600           ; Boot area load address.
     2602             (      dosdefs.asm):00026         BootEntryAddr   EQU     $2602           ; Boot entry address
                      (      dosdefs.asm):00027         
                      (      dosdefs.asm):00028         ;
                      (      dosdefs.asm):00029         ; Dir track related
                      (      dosdefs.asm):00030         ;
                      (      dosdefs.asm):00031         
     0014             (      dosdefs.asm):00032         DirPrimary      EQU     $14             ; Primary dir track is track 20
     0010             (      dosdefs.asm):00033         DirBackup       EQU     $10             ; Backup on track 16
                      (      dosdefs.asm):00034         
                      (      dosdefs.asm):00035         ;
                      (      dosdefs.asm):00036         ; DOS Low memory variables
                      (      dosdefs.asm):00037         ;
                      (      dosdefs.asm):00038         
     00FF             (      dosdefs.asm):00039         AutoFlag        EQU     $FF             ; Auto re-number flag, if $613=this then auto enter basic lines
                      (      dosdefs.asm):00040         
     00EA             (      dosdefs.asm):00041         DosHWByte       EQU     $00EA           ; Location of hardware IO byte
     00EB             (      dosdefs.asm):00042         LastActiveDrv   EQU     $00EB           ; Last active drive number
     00EC             (      dosdefs.asm):00043         DskTrackNo      EQU     $00EC           ; Disk track no
     00ED             (      dosdefs.asm):00044         DskSectorNo     EQU     $00ED           ; Disk sectror no
     00EE             (      dosdefs.asm):00045         DiskBuffPtr     EQU     $00EE           ; Disk buffer pointer
                      (      dosdefs.asm):00046         
     00EB             (      dosdefs.asm):00047         DosLastDrive    EQU     $00EB           ; Active/last used drive number (1-4)
     00F0             (      dosdefs.asm):00048         DosDiskError    EQU     $00F0           ; Disk error status byte
     00F1             (      dosdefs.asm):00049         DosCurrCtrlBlk  EQU     $00F1           ; Current file control block (0..9) $FF=no files open
     00F2             (      dosdefs.asm):00050         DosBytesInDTA   EQU     $00F2           ; Number of bytes in DTA (also used for tracks in DSKINIT).
     00F3             (      dosdefs.asm):00051         DosNoBytesMove  EQU     $00F3           ; Number of bytes to transfer to/from buffer
     00F4             (      dosdefs.asm):00052         DosRecLenFlag   EQU     $00F4           ; Record length flag, 00 don'r care $FF=do care
     00F5             (      dosdefs.asm):00053         DosIRQTimeFlag  EQU     $00F5           ; Dos IRQ timeout flag, 00=check for timeout
     00F6             (      dosdefs.asm):00054         DosIOInProgress EQU     $00f6           ; I/O currently in progress flag 0x00 check for time out, Non-0x00 skip timeout check
     00F8             (      dosdefs.asm):00055         DosSectorSeek   EQU     $00F8           ; Sector currently seeking {SuperDos Rom}
                      (      dosdefs.asm):00056         
     0600             (      dosdefs.asm):00057         DosAreaStart    EQU     $0600           ; Start of RAM used by DOS
     0603             (      dosdefs.asm):00058         DosErrorCode    EQU     $0603           ; Error code from DOS
     0605             (      dosdefs.asm):00059         DosTimeout      EQU     $0605           ; Timeout count, timeout occurs when this location is decremented from 0x01 to 0x00 
     0606             (      dosdefs.asm):00060         DosHWMaskFF40   EQU     $0606           ; Hardware command byte mask for FF40
     0607             (      dosdefs.asm):00061         DosHWMaskFF48   EQU     $0607           ; hardware control mask for $ff48
     0608             (      dosdefs.asm):00062         DosVerifyFlag   EQU     $0608           ; Verify flag, 00=no verify $FF=verify
     0609             (      dosdefs.asm):00063         DosErrorMask    EQU     $0609           ; Error mask, ANDed with error code from WD
     060A             (      dosdefs.asm):00064         DosDefDriveNo   EQU     $060A           ; Default drive number
     060B             (      dosdefs.asm):00065         DosFWriteBPtr   EQU     $060B           ; FWrite buffer pointer 
     060D             (      dosdefs.asm):00066         DosAutoCurrent  EQU     $060D           ; AUTO current line no
     060F             (      dosdefs.asm):00067         DosAutoInc      EQU     $060F           ; AUTO line increment
     060D             (      dosdefs.asm):00068         DosBuffStart    EQU     $060D           ; Buffer start, same loc as auto line
     060F             (      dosdefs.asm):00069         DosBuffEnd      EQU     $060F           ; Buffer end, same loc as auto increment
     0611             (      dosdefs.asm):00070         DosRunLoadFlag  EQU     $0611           ; Run/load flag $00=LOAD
     0612             (      dosdefs.asm):00071         DosFlFreadFlag  EQU     $0612           ; Fread/FLread flag 00=fread, $FF=FLread
     0613             (      dosdefs.asm):00072         DosAutoFlag     EQU     $0613           ; Auto flag, $FF=auto, $00=no auto
                      (      dosdefs.asm):00073         
     0614             (      dosdefs.asm):00074         DosErrGotoFlag  EQU     $0614           ; ERROR GOTO flag, 0x00 Off Non-0x00 On 
     0615             (      dosdefs.asm):00075         DosErrDestLine  EQU     $0615           ; Error destination line
     0617             (      dosdefs.asm):00076         DosErrLineNo    EQU     $0617           ; ERR line no
     0619             (      dosdefs.asm):00077         DosErrLast      EQU     $0619           ; Last ERR error
                      (      dosdefs.asm):00078         
     061C             (      dosdefs.asm):00079         Drv0Details     EQU     $061C           ; Drive 0 details (6 bytes)
     0622             (      dosdefs.asm):00080         Drv1Details     EQU     $0622           ; Drive 1 details (6 bytes)
     0628             (      dosdefs.asm):00081         Drv2Details     EQU     $0628           ; Drive 2 details (6 bytes)
     062E             (      dosdefs.asm):00082         Drv3Details     EQU     $062E           ; Drive 3 details (6 bytes)
     0006             (      dosdefs.asm):00083         DrvDeatailLen   EQU     $06             ; Entries are 6 bytes long
                      (      dosdefs.asm):00084         
                      (      dosdefs.asm):00085         ; Offsets into drive details
     0000             (      dosdefs.asm):00086         DrvDetDirLSN    EQU     $00             ; LSN of directory
     0002             (      dosdefs.asm):00087         DrvDetFrelen    EQU     $02             ; Free length
     0003             (      dosdefs.asm):00088         DrvDetFreEPtr   EQU     $03             ; Free extent pointer
     0005             (      dosdefs.asm):00089         DrvDetUseCnt    EQU     $05             ; Usage/open file count ?
                      (      dosdefs.asm):00090         
     0004             (      dosdefs.asm):00091         BuffCount       EQU     $04             ; 4 disk buffers
     0007             (      dosdefs.asm):00092         BuffDetailSize  EQU     $07             ; Buffer detail entries ar 7 bytes long
     0634             (      dosdefs.asm):00093         Buff1Details    EQU     $0634           ; Disk buffer 1 details
     063B             (      dosdefs.asm):00094         Buff2Details    EQU     $063B           ; Disk buffer 2 details
     0642             (      dosdefs.asm):00095         Buff3Details    EQU     $0642           ; Disk buffer 3 details
     0649             (      dosdefs.asm):00096         Buff4Details    EQU     $0649           ; Disk buffer 4 details
                      (      dosdefs.asm):00097         
                      (      dosdefs.asm):00098         
                      (      dosdefs.asm):00099         ; Disk buffer details offsets for above table
     0000             (      dosdefs.asm):00100         BuffLSN         EQU     $00             ; LSN number 
     0002             (      dosdefs.asm):00101         BuffFlag        EQU     $02             ; Flag, tested for $55 and $FF (also set to $01)
     0003             (      dosdefs.asm):00102         BuffDrive       EQU     $03             ; Drive no 1..4
     0004             (      dosdefs.asm):00103         BuffAge         EQU     $04             ; Age of buffer since last use, 1=oldest..4=youngest
     0005             (      dosdefs.asm):00104         BuffAddr        EQU     $05             ; Buffer address
                      (      dosdefs.asm):00105         
                      (      dosdefs.asm):00106         ;BuffFlag values
                      (      dosdefs.asm):00107         
     0000             (      dosdefs.asm):00108         BuffFree        EQU     $00             ; Disk buffer is free
     0001             (      dosdefs.asm):00109         BuffUnknown     EQU     $01             ; Unknown flag set by SuperDosFindAndRead
     0055             (      dosdefs.asm):00110         BuffInUse       EQU     $55             ; Buffer in use
     00FE             (      dosdefs.asm):00111         BuffDirtyExpire EQU     $FE             ; Buffer has been modified, but not written to disk, grace period expired
     00FF             (      dosdefs.asm):00112         BuffDirty       EQU     $FF             ; Buffer has been modified, but not written to disk
                      (      dosdefs.asm):00113         
     0650             (      dosdefs.asm):00114         DosCurDriveInfo EQU     $0650           ; Dos current drive info
     0650             (      dosdefs.asm):00115         DosCurFilename  EQU     $0650           ; Current filename
     0658             (      dosdefs.asm):00116         DosCurExtension EQU     $0658           ; Current extension, used in validation
     065B             (      dosdefs.asm):00117         DosCurDriveNo   EQU     $065B           ; Current drive no
     065C             (      dosdefs.asm):00118         DosLSNCounter   EQU     $065C           ; LSN counter
     065E             (      dosdefs.asm):00119         DosSaveBuffAddr EQU     $065E           ; Save buffer address
                      (      dosdefs.asm):00120         
                      (      dosdefs.asm):00121         
     0660             (      dosdefs.asm):00122         DosCurCount     EQU     $0660           ; Current count, used in various places (extent found?)
     0664             (      dosdefs.asm):00123         DosFWriteAddr   EQU     $0664           ; Fwrite address
     0667             (      dosdefs.asm):00124         DosPageBufAddr  EQU     $0667           ; Page buffer address
     0669             (      dosdefs.asm):00125         DosCurrSector   EQU     $0669           ; Current sector (LSN?)
     066B             (      dosdefs.asm):00126         DosTotalSFound  EQU     $066B           ; Total sectors found
     066D             (      dosdefs.asm):00127         DosFSNToFind    EQU     $066D           ; FSN sought
     066F             (      dosdefs.asm):00128         DosCurLSN       EQU     $066F           ; Current LSN, of current DIR sector being processed
     067F             (      dosdefs.asm):00129         DosCurDirBuff   EQU     $067F           ; Pointer to the current Dire sector, Buffer def block
     0682             (      dosdefs.asm):00130         DosCurFileNo    EQU     $0682           ; Current file number on disk, to get dir entry for
                      (      dosdefs.asm):00131         
                      (      dosdefs.asm):00132         
     0683             (      dosdefs.asm):00133         DosNewUSRTable  EQU     $0683           ; New USR table, relocated from low ram
                      (      dosdefs.asm):00134         
                      (      dosdefs.asm):00135         ;Drive parameter tables, note these need to be in this order.
     0697             (      dosdefs.asm):00136         DosD0Online     EQU     $0697           ; Drive 0 online flag
     0698             (      dosdefs.asm):00137         DosD1Online     EQU     $0698           ; Drive 1 online flag
     0699             (      dosdefs.asm):00138         DosD2Online     EQU     $0699           ; Drive 2 online flag
     069A             (      dosdefs.asm):00139         DosD3Online     EQU     $069A           ; Drive 3 online flag
                      (      dosdefs.asm):00140         
     069B             (      dosdefs.asm):00141         DosD0Track      EQU     $069B           ; Drive 0 current track
     069C             (      dosdefs.asm):00142         DosD1Track      EQU     $069C           ; Drive 1 current track
     069D             (      dosdefs.asm):00143         DosD2Track      EQU     $069D           ; Drive 2 current track
     069E             (      dosdefs.asm):00144         DosD3Track      EQU     $069E           ; Drive 3 current track
                      (      dosdefs.asm):00145         
     069F             (      dosdefs.asm):00146         DosLBASec       EQU     $069F           ; as step rates meaningless for disk image
                      (      dosdefs.asm):00147         
     069F             (      dosdefs.asm):00148         DosD0StepRate   EQU     $069F           ; Drive 0 step rate
     06A0             (      dosdefs.asm):00149         DosD1StepRate   EQU     $06A0           ; Drive 1 step rate
     06A1             (      dosdefs.asm):00150         DosD2StepRate   EQU     $06A1           ; Drive 2 step rate
     06A2             (      dosdefs.asm):00151         DosD3StepRate   EQU     $06A2           ; Drive 3 step rate
                      (      dosdefs.asm):00152         
     06A3             (      dosdefs.asm):00153         DosD0Tracks     EQU     $06A3           ; Tracks on disk in drive 0
     06A4             (      dosdefs.asm):00154         DosD1Tracks     EQU     $06A4           ; Tracks on disk in drive 1
     06A5             (      dosdefs.asm):00155         DosD2Tracks     EQU     $06A5           ; Tracks on disk in drive 2
     06A6             (      dosdefs.asm):00156         DosD3Tracks     EQU     $06A6           ; Tracks on disk in drive 3
                      (      dosdefs.asm):00157         
     06A7             (      dosdefs.asm):00158         DosD0SecTrack   EQU     $06A7           ; Sectors per track drive 0
     06A8             (      dosdefs.asm):00159         DosD1SecTrack   EQU     $06A8           ; Sectors per track drive 1
     06A9             (      dosdefs.asm):00160         DosD2SecTrack   EQU     $06A9           ; Sectors per track drive 2
     06AA             (      dosdefs.asm):00161         DosD3SecTrack   EQU     $06AA           ; Sectors per track drive 3
                      (      dosdefs.asm):00162         
                      (      dosdefs.asm):00163         ; Offsets of tables from Online table, this way we can point an indes register
                      (      dosdefs.asm):00164         ; at the drive online byte and access the other tables with offset,IR
                      (      dosdefs.asm):00165         
     0004             (      dosdefs.asm):00166         DosTrackTblOfs  EQU     (DosD0Track-DosD0Online)
     0008             (      dosdefs.asm):00167         DosStepTblOfs   EQU     (DosD0StepRate-DosD0Online)
     000C             (      dosdefs.asm):00168         DosTracksTblOfs EQU     (DosD0Tracks-DosD0Online)
     0010             (      dosdefs.asm):00169         DosSecTrkTblOfs EQU     (DosD0SecTrack-DosD0Online)
                      (      dosdefs.asm):00170         
     06AB             (      dosdefs.asm):00171         DosDirSecStatus EQU     $06AB           ; Directory sector status $06ab-$06bc
                      (      dosdefs.asm):00172         
     06BD             (      dosdefs.asm):00173         DosFCB0Addr     EQU     $06BD           ; File Control Block 0 Address 
     06DC             (      dosdefs.asm):00174         DosFCB1Addr     EQU     $06DC           ; File Control Block 1 Address
     06FB             (      dosdefs.asm):00175         DosFCB2Addr     EQU     $06FB           ; File Control Block 2 Address 
     071A             (      dosdefs.asm):00176         DosFCB3Addr     EQU     $071A           ; File Control Block 3 Address 
     0739             (      dosdefs.asm):00177         DosFCB4Addr     EQU     $0739           ; File Control Block 4 Address 
     0758             (      dosdefs.asm):00178         DosFCB5Addr     EQU     $0758           ; File Control Block 5 Address 
     0777             (      dosdefs.asm):00179         DosFCB6Addr     EQU     $0777           ; File Control Block 6 Address 
     0796             (      dosdefs.asm):00180         DosFCB7Addr     EQU     $0796           ; File Control Block 7 Address 
     07B5             (      dosdefs.asm):00181         DosFCB8Addr     EQU     $07B5           ; File Control Block 8 Address 
     07D4             (      dosdefs.asm):00182         DosFCB9Addr     EQU     $07D4           ; File Control Block 9 Address 
     07F3             (      dosdefs.asm):00183         DosFCBEnd       EQU     $07F3           ; First byte beyond last FCB
                      (      dosdefs.asm):00184         
     0800             (      dosdefs.asm):00185         DosDiskBuffBase EQU     $0800           ; Base of Disk buffers
                      (      dosdefs.asm):00186         
     001F             (      dosdefs.asm):00187         DosFCBLength    EQU     $1F             ; 31 bytes per FCB
                      (      dosdefs.asm):00188         
                      (      dosdefs.asm):00189         ;
                      (      dosdefs.asm):00190         ; FCB structure may be :
                      (      dosdefs.asm):00191         ;
                      (      dosdefs.asm):00192         ; offset        len     purpose
                      (      dosdefs.asm):00193         ; $00           8       Filename (zero padded)
                      (      dosdefs.asm):00194         ; $08           3       Extension
                      (      dosdefs.asm):00195         ; $0B           1       Drive number (1..4)
                      (      dosdefs.asm):00196         ; $0C           3       File pointer
                      (      dosdefs.asm):00197         ; $10           3       File len ?
                      (      dosdefs.asm):00198         ;
                      (      dosdefs.asm):00199         ; $1D           1       File Number ? (used by DIR).
                      (      dosdefs.asm):00200         
     0000             (      dosdefs.asm):00201         FCBFileName     EQU     $00     ; Filename (zero padded)
     0008             (      dosdefs.asm):00202         FCBExtension    EQU     $08     ; Extension (zero padded)
     000B             (      dosdefs.asm):00203         FCBDrive        EQU     $0B     ; Drive no
     000C             (      dosdefs.asm):00204         FCBFilePointer  EQU     $0C     ; File Pointer 
     000F             (      dosdefs.asm):00205         FCBDirFlags     EQU     $0F     ; Dir flags
     0010             (      dosdefs.asm):00206         FCBFileLen      EQU     $10     ; File Length
     0013             (      dosdefs.asm):00207         FCBFSNExtent1   EQU     $13     ; FSN of extent 1
     0015             (      dosdefs.asm):00208         FCBLSNExtent1   EQU     $15     ; LSN of extent 1 
     0017             (      dosdefs.asm):00209         FCBSecExtent1   EQU     $17     ; Sectors in extent 1
     0018             (      dosdefs.asm):00210         FCBFSNExtent2   EQU     $18     ; FSN of extent 1
     001A             (      dosdefs.asm):00211         FCBLSNExtent2   EQU     $1A     ; LSN of extent 1 
     001C             (      dosdefs.asm):00212         FCBSecExtent2   EQU     $1C     ; Sectors in extent 1
     001D             (      dosdefs.asm):00213         FCBDiskFileNo   EQU     $1D     ; File number on disk, (dir entry no).
     001E             (      dosdefs.asm):00214         FCBDirNoLast    EQU     $1E     ; Dir no of last entry
                      (      dosdefs.asm):00215         ;
                      (      dosdefs.asm):00216         ; Backup command stack frame offsets
                      (      dosdefs.asm):00217         ;
                      (      dosdefs.asm):00218         ; These are offset from U on stack
                      (      dosdefs.asm):00219         ;
                      (      dosdefs.asm):00220         
     0000             (      dosdefs.asm):00221         BupSrcDrive     EQU     0       ; Drive number of source 
     0001             (      dosdefs.asm):00222         BupSrcTrk       EQU     1       ; $0001 Source track and sector ?
     0002             (      dosdefs.asm):00223         BupSrcSec       EQU     2       ; Source sector no
                      (      dosdefs.asm):00224         ;       3,U     $DF5A Error masks ???
     0005             (      dosdefs.asm):00225         BupSrcBuff      EQU     5       ; Source sector buffer addr ?
     0007             (      dosdefs.asm):00226         BupDestDrive    EQU     7       ; Drive number of dest ?
     0008             (      dosdefs.asm):00227         BupDestTrk      EQU     8       ; $0001 Dest track and sector ?
     0009             (      dosdefs.asm):00228         BupDestSec      EQU     9       ; Dest sector no
                      (      dosdefs.asm):00229         ;       10,U    $DF6D Error masks ???
     000C             (      dosdefs.asm):00230         BupDestBuff     EQU     12      ; Dest sector buffer addr ?
     000E             (      dosdefs.asm):00231         BupSecTrk       EQU     14      ; Sector count per track to copy ?
     000F             (      dosdefs.asm):00232         BupAvailPages   EQU     15      ; Pages available to buffer sectors
                      (      dosdefs.asm):00233         
                      (      dosdefs.asm):00234         ;
                      (      dosdefs.asm):00235         ; Offset from X, which will point to BupSrcDrive, or BupDestDrive
                      (      dosdefs.asm):00236         ; 
                      (      dosdefs.asm):00237         
     0000             (      dosdefs.asm):00238         BupDrive        EQU     0       ; Drive number  
     0001             (      dosdefs.asm):00239         BupTrk          EQU     1       ; $00 track 
     0002             (      dosdefs.asm):00240         BupSec          EQU     2       ; $01 sector
                      (      dosdefs.asm):00241         ;               3,X     $DF5A ???
     0005             (      dosdefs.asm):00242         BupBuff         EQU     5       ; Source sector buffer addr ?
                      (      dosdefs.asm):00243         
     D800             (      dosdefs.asm):00244         SpinUpDelay     EQU     $D800   ; Value for timeout loop
                      (      dosdefs.asm):00245         
                      (      dosdefs.asm):00246         
                      (      dosdefs.asm):00247         ;
                      (      dosdefs.asm):00248         ; Sync dir stack frame offsets
                      (      dosdefs.asm):00249         ;
                      (      dosdefs.asm):00250         ; These are offset from U on stack
                      (      dosdefs.asm):00251         ;
                      (      dosdefs.asm):00252         
     0001             (      dosdefs.asm):00253         SyncDrive       EQU     1       ; Drive we are syncing
     0002             (      dosdefs.asm):00254         SyncTableCount  EQU     2       ; Table entry in SyncSectorNos
     0003             (      dosdefs.asm):00255         SyncSecNo       EQU     3       ; Sector we are syncing
     0004             (      dosdefs.asm):00256         SyncSectorNos   EQU     4       ; 4 sectors currently being synced
     0004             (      dosdefs.asm):00257         SyncTableSize   EQU     4       ; 4 Sync table entries
                      (      dosdefs.asm):00258         
                      (      dosdefs.asm):00259         ;
                      (      dosdefs.asm):00260         ; Dos function codes used by hardware routine.
                      (      dosdefs.asm):00261         ; 
                      (      dosdefs.asm):00262         
     0000             (      dosdefs.asm):00263         DosFnRestore    EQU     $00     ; Restore to track 0
     0001             (      dosdefs.asm):00264         DosFnSeek       EQU     $01     ; Seek to a track
     0002             (      dosdefs.asm):00265         DosFnReadSec    EQU     $02     ; Read a sector
     0003             (      dosdefs.asm):00266         DosFnWriteSec   EQU     $03     ; Write a sector
     0004             (      dosdefs.asm):00267         DosFnWriteSec2  EQU     $04     ; not sure what difference is
     0005             (      dosdefs.asm):00268         DosFnWriteTrack EQU     $05     ; Write (format) track
     0006             (      dosdefs.asm):00269         DosFnReadAddr   EQU     $06     ; Read address mark
     0007             (      dosdefs.asm):00270         DosFnReadSec2   EQU     $07     ; Read first two bytes of a sector
                      (      dosdefs.asm):00271         
                      (      dosdefs.asm):00272         *******************************************
                      (      dosdefs.asm):00273         ***** Directory Track realted defines *****
                      (      dosdefs.asm):00274         *******************************************
                      (      dosdefs.asm):00275         
                      (      dosdefs.asm):00276         ;
                      (      dosdefs.asm):00277         ; Dir entry format(s).
                      (      dosdefs.asm):00278         ;
                      (      dosdefs.asm):00279         ; Dragon/Super dos directory entries can take one of 2 formats, they can be either a
                      (      dosdefs.asm):00280         ; filename block, containing filename, attributes & 4 allocation entries, or they can
                      (      dosdefs.asm):00281         ; be a continuation block, containing just allocation entries. 
                      (      dosdefs.asm):00282         ; This is controled by the byte at offset $18, and the attributes.
                      (      dosdefs.asm):00283         ;
                      (      dosdefs.asm):00284         ; if AttrContinued = 0 then 
                      (      dosdefs.asm):00285         ;       the byte at offset $18, contains the number of number of bytes in the last sector (256 bytes = 0).
                      (      dosdefs.asm):00286         ;
                      (      dosdefs.asm):00287         ; if AttrContinued = 0 then 
                      (      dosdefs.asm):00288         ;       the byte at offset $18 controls the format of the entry :
                      (      dosdefs.asm):00289         ;               if 0 then 
                      (      dosdefs.asm):00290         ;                       Entry is a filename entry
                      (      dosdefs.asm):00291         ;               else
                      (      dosdefs.asm):00292         ;                       Entry is a continuation block.
                      (      dosdefs.asm):00293         
                      (      dosdefs.asm):00294         ; Filename block format 
                      (      dosdefs.asm):00295         
     0000             (      dosdefs.asm):00296         DirEntAttr      EQU     $00             ; Attributes (see above)
     0001             (      dosdefs.asm):00297         DirEntFilename  EQU     $01             ; Filename, zero padded
     0009             (      dosdefs.asm):00298         DirEntExtension EQU     $09             ; Extension, zero padded
     000C             (      dosdefs.asm):00299         DirEntFnBlock1  EQU     $0C             ; Allocation block #1
     000F             (      dosdefs.asm):00300         DirEntFnBlock2  EQU     $0F             ; Allocation block #2
     0012             (      dosdefs.asm):00301         DirEntFnBlock3  EQU     $12             ; Allocation block #3
     0015             (      dosdefs.asm):00302         DirEntFnBlock4  EQU     $15             ; Allocation block #4
     0018             (      dosdefs.asm):00303         DirEntFlag      EQU     $18             ; Filename/Continuation flag 0/nonzero
                      (      dosdefs.asm):00304         
     0019             (      dosdefs.asm):00305         DirEntryLen     EQU     $19             ; Length of Dir Entry.
                      (      dosdefs.asm):00306         
                      (      dosdefs.asm):00307         ; Continuation block, DirEntAttr, and DirEntFlag, as above.
                      (      dosdefs.asm):00308         
     0001             (      dosdefs.asm):00309         DirEntCntBlock1 EQU     $01             ; Allocation block #1
     0004             (      dosdefs.asm):00310         DirEntCntBlock2 EQU     $04             ; Allocation block #2
     0007             (      dosdefs.asm):00311         DirEntCntBlock3 EQU     $07             ; Allocation block #3
     000A             (      dosdefs.asm):00312         DirEntCntBlock4 EQU     $0A             ; Allocation block #4
     000D             (      dosdefs.asm):00313         DirEntCntBlock5 EQU     $0D             ; Allocation block #5
     0010             (      dosdefs.asm):00314         DirEntCntBlock6 EQU     $10             ; Allocation block #6
     0013             (      dosdefs.asm):00315         DirEntCntBlock7 EQU     $13             ; Allocation block #7
                      (      dosdefs.asm):00316         
                      (      dosdefs.asm):00317         ;
                      (      dosdefs.asm):00318         ; Allocation block format.
                      (      dosdefs.asm):00319         ;
                      (      dosdefs.asm):00320         
     0000             (      dosdefs.asm):00321         AllocLSN        EQU     $00             ; Logical sector number of start of allocation
     0002             (      dosdefs.asm):00322         AllocCount      EQU     $02             ; Count of number of sectors allocated.
                      (      dosdefs.asm):00323         
                      (      dosdefs.asm):00324         ;
                      (      dosdefs.asm):00325         ; File Attributes
                      (      dosdefs.asm):00326         ;
                      (      dosdefs.asm):00327         
     0080             (      dosdefs.asm):00328         AttrDeleted     EQU     %10000000       ; Deleted, may be reused
     0020             (      dosdefs.asm):00329         AttrContinued   EQU     %00100000       ; Continuation entry, byte at $18 giver next entry no
     0008             (      dosdefs.asm):00330         AttrEndOfDir    EQU     %00001000       ; End of directory, no more entries need to be scanned
     0002             (      dosdefs.asm):00331         AttrWriteProt   EQU     %00000010       ; Write protect flag
     0001             (      dosdefs.asm):00332         AttrIsCont      EQU     %00000001       ; This is a continuation entry.
                      (      dosdefs.asm):00333         
     0089             (      dosdefs.asm):00334         AttrAtFormat    EQU     AttrDeleted+AttrEndOfDir+AttrIsCont     ; Attributes set in DSKINIT     
                      (      dosdefs.asm):00335         
     000A             (      dosdefs.asm):00336         DirEntPerSec    EQU     $0A             ; Directory entries per sector
                      (      dosdefs.asm):00337         
                      (      dosdefs.asm):00338         ;
                      (      dosdefs.asm):00339         ; Offsets in Sector 0 on Dir track
                      (      dosdefs.asm):00340         ;
                      (      dosdefs.asm):00341         
     0000             (      dosdefs.asm):00342         BitmapPart1     EQU     $00             ; Bitmap uses bytes $00..$FB on first sector
     00FC             (      dosdefs.asm):00343         DirTracks       EQU     $FC             ; Tracks on disk
     00FD             (      dosdefs.asm):00344         DirSecPerTrk    EQU     $FD             ; Sectors/track 18=Single sided, 36=Double sided
     00FE             (      dosdefs.asm):00345         DirTracks1s     EQU     $FE             ; complement of DirTracks (used to validate)
     00FF             (      dosdefs.asm):00346         DirSecPerTrk1s  EQU     $FF             ; Complement of DirSecPerTrk (used to validate)
                      (      dosdefs.asm):00347         
                      (      dosdefs.asm):00348         ;
                      (      dosdefs.asm):00349         ; DOS Error codes.
                      (      dosdefs.asm):00350         ;
                      (      dosdefs.asm):00351         
     0080             (      dosdefs.asm):00352         DDErrNR         EQU     $80             ; Not ready
     0082             (      dosdefs.asm):00353         DDErrSK         EQU     $82             ; seek
     0084             (      dosdefs.asm):00354         DDErrWP         EQU     $84             ; write protect
     0086             (      dosdefs.asm):00355         DDErrRT         EQU     $86             ; record type
     0088             (      dosdefs.asm):00356         DDErrRF         EQU     $88             ; record not found
     008A             (      dosdefs.asm):00357         DDErrCC         EQU     $8A             ; CRC
     008C             (      dosdefs.asm):00358         DDErrLD         EQU     $8C             ; Lost data
     008E             (      dosdefs.asm):00359         DDErrBT         EQU     $8E             ; boot
     0090             (      dosdefs.asm):00360         DDErrIV         EQU     $90             ; invalid volume / directory
     0092             (      dosdefs.asm):00361         DDErrFD         EQU     $92             ; Full directory
     0094             (      dosdefs.asm):00362         DDErrDF         EQU     $94             ; Disk full
     0096             (      dosdefs.asm):00363         DDErrFS         EQU     $96             ; File spec
     0098             (      dosdefs.asm):00364         DDErrPT         EQU     $98             ; Protection
     009A             (      dosdefs.asm):00365         DDErrPE         EQU     $9A             ; (read) Past end 
     009C             (      dosdefs.asm):00366         DDErrFF         EQU     $9C             ; File not Found 
     009E             (      dosdefs.asm):00367         DDErrFE         EQU     $9E             ; File exists
     00A0             (      dosdefs.asm):00368         DDErrNE         EQU     $A0             ; (file does) Not Exist
     00A2             (      dosdefs.asm):00369         DDErrTF         EQU     $A2             ; Too many Files open
     00A4             (      dosdefs.asm):00370         DDErrPR         EQU     $A4             ; Parameter
     00A6             (      dosdefs.asm):00371         DDErrUD         EQU     $A6             ; Undefined
     00FF             (      dosdefs.asm):00372         DDErrSFF        EQU     $FF             ; ????
                      (      dosdefs.asm):00373         
     0080             (      dosdefs.asm):00374         DDFirstError    EQU     DDErrNR         ; First error code
                      (      dosdefs.asm):00375         
     0800             (      dosdefs.asm):00376         DskInitBuffer   EQU     $0800           ; Address of format disk buffer
     0008             (      dosdefs.asm):00377         SectorsPerBAM   EQU     $08             ; Each BAM entry is for 8 sectors
     005A             (      dosdefs.asm):00378         BAMEntries40SS  EQU     (SectorsPerTrack*40)/SectorsPerBAM      ; Number of BAM entries for a single sided 40 track disk
                      (      dosdefs.asm):00379         
                      (      dosdefs.asm):00380         
                      (      dosdefs.asm):00381         ; Offsets within BAM of directory track flags
     002D             (      dosdefs.asm):00382         BAMOffDirPriSS  EQU     (SectorsPerTrack*DirPrimary)/SectorsPerBAM
     0024             (      dosdefs.asm):00383         BAMOffDirBakSS  EQU     (SectorsPerTrack*DirBackup)/SectorsPerBAM
     005A             (      dosdefs.asm):00384         BAMOffDirPriDS  EQU     (SectorsPerTrack*(DirPrimary*2))/SectorsPerBAM
     0048             (      dosdefs.asm):00385         BAMOffDirBakDS  EQU     (SectorsPerTrack*(DirBackup*2))/SectorsPerBAM
                      (    DragonMMC.asm):00114                     use     WDdefs.asm
                      (       WDdefs.asm):00001         ;
                      (       WDdefs.asm):00002         ; WD17xx / WD27xx defines.
                      (       WDdefs.asm):00003         ;
                      (       WDdefs.asm):00004                         ifdef   Tandy
                      (       WDdefs.asm):00005         ; Disk command codes WD1793, WD1773, RSDos FDC carts.
     0000             (       WDdefs.asm):00006         WDCmdRestore    EQU     $00             ; Restore to track 0
     0010             (       WDdefs.asm):00007         WDCmdSeek       EQU     $10             ; Seek to track command
     0080             (       WDdefs.asm):00008         WDCmdReadSec    EQU     $80             ; Read sector command
     00A0             (       WDdefs.asm):00009         WDCmdWriteSec   EQU     $A0             ; Write sector command
     00C0             (       WDdefs.asm):00010         WDCmdReadAddr   EQU     $C0             ; Read address mark
     00D0             (       WDdefs.asm):00011         WDCmdForceInt   EQU     $D0             ; Force inturrupt
     00F4             (       WDdefs.asm):00012         WDCmdWriteTrack EQU     $F4             ; Write (format) track  
                      (       WDdefs.asm):00013                         else
                      (       WDdefs.asm):00014         ; Disk command codes WD2797, Dragon Dos, Cumana Dos, Dragon Alpha/Professional, Dragon Beta
0000                  (       WDdefs.asm):00015         WDCmdRestore    EQU     $00             ; Restore to track 0
0000                  (       WDdefs.asm):00016         WDCmdSeek       EQU     $10             ; Seek to track command
0000                  (       WDdefs.asm):00017         WDCmdReadSec    EQU     $88             ; Read sector command
0000                  (       WDdefs.asm):00018         WDCmdWriteSec   EQU     $A8             ; Write sector command
0000                  (       WDdefs.asm):00019         WDCmdReadAddr   EQU     $C0             ; Read address mark
0000                  (       WDdefs.asm):00020         WDCmdForceInt   EQU     $D0             ; Force inturrupt
0000                  (       WDdefs.asm):00021         WDCmdWriteTrack EQU     $F4             ; Write (format) track
                      (       WDdefs.asm):00022                         endc
                      (       WDdefs.asm):00023         ;
                      (       WDdefs.asm):00024         ; Step rates.
                      (       WDdefs.asm):00025         ;
                      (       WDdefs.asm):00026         
     0000             (       WDdefs.asm):00027         StepRate6ms     EQU     $00             ;  6ms step rate
     0001             (       WDdefs.asm):00028         StepRate12ms    EQU     $01             ; 12ms step rate
     0002             (       WDdefs.asm):00029         StepRate20ms    EQU     $02             ; 20ms step rate
     0003             (       WDdefs.asm):00030         StepRate30ms    EQU     $03             ; 30ms step rate
                      (       WDdefs.asm):00031         
     0002             (       WDdefs.asm):00032         SeepRateDefault EQU     StepRate20ms    ; Default
                      (       WDdefs.asm):00033         
                      (       WDdefs.asm):00034         ;
                      (       WDdefs.asm):00035         ; WD Error flag / status bits
                      (       WDdefs.asm):00036         ;
                      (       WDdefs.asm):00037         
     0080             (       WDdefs.asm):00038         WDErrNotReady   EQU     $80             ; Not ready
     0040             (       WDdefs.asm):00039         WDErrWriteProt  EQU     $40             ; Write protect
     0020             (       WDdefs.asm):00040         WDErrHeadLoaded EQU     $20             ; Head loaded, type 1
     0020             (       WDdefs.asm):00041         WDErrRecType    EQU     $20             ; Record type, read sec
     0010             (       WDdefs.asm):00042         WDErrSeek       EQU     $10             ; Seek error, type 1
     0010             (       WDdefs.asm):00043         WDErrRNF        EQU     $10             ; Record not found, read address, sector write sector
     0008             (       WDdefs.asm):00044         WDErrCRC        EQU     $08             ; CRC error all but read/write track
     0004             (       WDdefs.asm):00045         WDErrTrack0     EQU     $04             ; Head on track 0, type 1
     0004             (       WDdefs.asm):00046         WDErrLostData   EQU     $04             ; Lost data 
     0002             (       WDdefs.asm):00047         WDErrIndex      EQU     $02             ; Index pulse, type 1
     0002             (       WDdefs.asm):00048         WDErrDRQ        EQU     $02             ; Data request
     0001             (       WDdefs.asm):00049         WDErrBusy       EQU     $01             ; Busy
                      (       WDdefs.asm):00050         
     000F             (       WDdefs.asm):00051         WDErrMask0F     EQU     WDErrCRC+WDErrLostData+WDErrDRQ+WDErrBusy
     005F             (       WDdefs.asm):00052         WDErrMask5F     EQU     WDErrWriteProt+WDErrRNF+WDErrMask0F
     00DF             (       WDdefs.asm):00053         WDErrMaskDF     EQU     WDErrNotReady+WDErrMask5F
     0047             (       WDdefs.asm):00054         WDErrMaskFormat EQU     WDErrWriteProt+WDErrLostData+WDErrDRQ+WDErrBusy
     003F             (       WDdefs.asm):00055         WDDefErrMask    EQU     WDErrRecType+WDErrSeek+WDErrMask0F
     007C             (       WDdefs.asm):00056         WDErrMaskRW     EQU     WDErrWriteProt+WDErrRecType+WDErrRNF+WDErrCRC+WDErrLostData
                      (       WDdefs.asm):00057         
                      (       WDdefs.asm):00058         
                      (    DragonMMC.asm):00115                                 use             romdefs.asm
     0000             (      romdefs.asm):00001         DStubResWordsOfs                EQU     $0000           Offset of number of reserved words
     0001             (      romdefs.asm):00002         DStubResLookupOfs               EQU     $0001           Offset of reserved word lookup table
     0003             (      romdefs.asm):00003         DStubResJumpOfs                 EQU     $0003           Offset of reserved word jump table
     0005             (      romdefs.asm):00004         DStubFuncsOfs                   EQU     $0005           Offset of nummber of functions
     0006             (      romdefs.asm):00005         DStubFuncsLookupOfs             EQU     $0006           Offset of function lookup table
     0008             (      romdefs.asm):00006         DStubFuncsJumpOfs               EQU     $0008           Offset of functions jump table
                      (      romdefs.asm):00007         
     0021             (      romdefs.asm):00008         DSkip1                          EQU     $0021           Skip 1 byte (BRN)
     008C             (      romdefs.asm):00009         DSkip2                          EQU     $008C           Skip 2 bytes (CMPX)
     0086             (      romdefs.asm):00010         DSkip1LD                        EQU     $0086           Skip 1 byte (LDA)
     007D             (      romdefs.asm):00011         DSkip2TST                       EQU     $007D           Skip 2 bytes (TST)
                      (      romdefs.asm):00012         
     0000             (      romdefs.asm):00013         DCoCoVec167                     EQU     $0000           Vector dest for 167 
     0000             (      romdefs.asm):00014         DCoCoVect16A                    EQU     $0000           Vector dest for 16A
     0000             (      romdefs.asm):00015         DCoCoVect176                    EQU     $0000           Vector dest for 176
     0000             (      romdefs.asm):00016         DCoCoVect179                    EQU     $0000           Vector dest for 179
     0000             (      romdefs.asm):00017         DCoCoVect18B                    EQU     $0000           Vector dest for 18B
     0000             (      romdefs.asm):00018         DCoCoVect191                    EQU     $0000           Vector dest for 191
     0000             (      romdefs.asm):00019         DCoCoVect194                    EQU     $0000           Vector Dest for 194
     0000             (      romdefs.asm):00020         DCoCoVect197                    EQU     $0000           Vector Dest for 197
     0000             (      romdefs.asm):00021         DCoCoVect19A                    EQU     $0000           Vector Dest for 19A
     0000             (      romdefs.asm):00022         DCoCoVect1A3                    EQU     $0000           Vector Dest for 1A3
     0027             (      romdefs.asm):00023         DAddrFWareRamTop                EQU     $0027           Top of firmware RAM CLEAR xxx,yyyy set this to yyyy
     0074             (      romdefs.asm):00024         DAddrRamTop                     EQU     $0074           Physical end of RAM (4K, 16K, 32K or 64K).
     0021             (      romdefs.asm):00025         DAddrStack                      EQU     $0021           Address of top of machine stack
     0123             (      romdefs.asm):00026         DBasAddrCmdDisp                 EQU     $0123           Address of basic command dispatch
     0121             (      romdefs.asm):00027         DBasAddrCmdList                 EQU     $0121           Address of basic command list
     012D             (      romdefs.asm):00028         DBasAddrDskCmdDisp              EQU     $012D           Address of disk basic command dispatch
     012B             (      romdefs.asm):00029         DBasAddrDskCmdList              EQU     $012B           Address of disk basic command list
     0132             (      romdefs.asm):00030         DBasAddrDskFuncDisp             EQU     $0132           Address of disk basic function dispatcher
     0130             (      romdefs.asm):00031         DBasAddrDskFuncList             EQU     $0130           Address of disk basic function list
     0128             (      romdefs.asm):00032         DBasAddrFuncDisp                EQU     $0128           Address of basic function dispatcher
     0126             (      romdefs.asm):00033         DBasAddrFuncList                EQU     $0126           Address of basic function list
     00A6             (      romdefs.asm):00034         DBasAddrSigByte                 EQU     $00A6           Address of current significant bit in command line
     B84E             (      romdefs.asm):00035         DBasAOError                     EQU     $B84E           Print ?AO Error and return to basic
     0005             (      romdefs.asm):00036         DBasArrayEval                   EQU     $0005           Array evaluation flag, 0=eval, 1=dimensioning
     B400             (      romdefs.asm):00037         DBasBootBasic                   EQU     $B400           Restart basic, as if power on, also deletes current program
     0017             (      romdefs.asm):00038         DBasBotStack                    EQU     $0017           Bottom of stack at last check
     84DA             (      romdefs.asm):00039         DBasBRARun                      EQU     $84DA           BRA to main loop, used by DOS
     0000             (      romdefs.asm):00040         DBasBreakFlag                   EQU     $0000           Break flag, +ve=stop,-ve=end
     03D7             (      romdefs.asm):00041         DBasBuffer                      EQU     $03D7           Basic buffer space
     831C             (      romdefs.asm):00042         DBasChkArrSpaceMv               EQU     $831C           Check memory space at top of arrays + move arrays
     8331             (      romdefs.asm):00043         DBasChkB2Free                   EQU     $8331           Check B*2 bytes free above Arrays, OM error if not
     9C76             (      romdefs.asm):00044         DBasChkDirect                   EQU     $9C76           Check for direct mode, ID Error if so
     009F             (      romdefs.asm):00045         DBasChrGet                      EQU     $009F           Get next basic character routine
     00A5             (      romdefs.asm):00046         DBasChrGetCurr                  EQU     $00A5           Get current basic ccharacter
     00D3             (      romdefs.asm):00047         DBasCloadMOffs                  EQU     $00D3           2s complement of CLOADM offset
     8371             (      romdefs.asm):00048         DBasCmdMode                     EQU     $8371           Return to command mode
     0029             (      romdefs.asm):00049         DBasContLine                    EQU     $0029           Line no used by CONT
     0068             (      romdefs.asm):00050         DBasCurrentLine                 EQU     $0068           Current line no $FFFF in direct mode
     0001             (      romdefs.asm):00051         DBasDelim1                      EQU     $0001           First string delimiter
     0002             (      romdefs.asm):00052         DBasDelim2                      EQU     $0002           Second string delimiter
     002F             (      romdefs.asm):00053         DBasDirectTextPtr               EQU     $002F           Direct mode text pointer
     0008             (      romdefs.asm):00054         DBasDisArraySearch              EQU     $0008           Disable array search flag, 0=allow 0<>disable
     B851             (      romdefs.asm):00055         DBasDNError                     EQU     $B851           Print ?DN Error and return to basic
     84ED             (      romdefs.asm):00056         DBasDoDispatch                  EQU     $84ED           Do command dispatech, X must point to dispatch table
     00D7             (      romdefs.asm):00057         DBasEditorLineLen               EQU     $00D7           Editor line length
     82A9             (      romdefs.asm):00058         DBasErrorCodeTable              EQU     $82A9           List of 2 byte error codes eg 'SN' 'OM' 'UL' etc
     009D             (      romdefs.asm):00059         DBasExecAddr                    EQU     $009D           Exec address, on D64, at startup points to routine to boot all ram mode
     8B8D             (      romdefs.asm):00060         DBasFCError                     EQU     $8B8D           Print ?FC Error and return to basic
     83FF             (      romdefs.asm):00061         DBasFindLineNo                  EQU     $83FF           Find a line number in basic program
     B848             (      romdefs.asm):00062         DBasFMError                     EQU     $B848           Print ?FM Error and return to basic
     0007             (      romdefs.asm):00063         DBasGarbageFlag                 EQU     $0007           Garbage collection flag
     0003             (      romdefs.asm):00064         DBasGenCount                    EQU     $0003           General count/scratch var
     B7D4             (      romdefs.asm):00065         DBasGetDevNo                    EQU     $B7D4           Get dev no from line & validate
     869A             (      romdefs.asm):00066         DBasGetLineNo                   EQU     $869A           Get line no and store in BasTempLine
     8DEA             (      romdefs.asm):00067         DBasGetStrFirst                 EQU     $8DEA           Get first character of string into B
     8D9A             (      romdefs.asm):00068         DBasGetStrLenAddr               EQU     $8D9A           Get string len in B and address in X of string desc in FPA2
     8027             (      romdefs.asm):00069         DBasicCassBitIn                 EQU     $8027           Cassette bit input
     8024             (      romdefs.asm):00070         DBasicCassByIn                  EQU     $8024           Cassette byte input
     801E             (      romdefs.asm):00071         DBasicCassByOut                 EQU     $801E           Cassette byte output
     8018             (      romdefs.asm):00072         DBasicCassOff                   EQU     $8018           Cassette player motor off
     8015             (      romdefs.asm):00073         DBasicCassOn                    EQU     $8015           Cassette player motor on
     8021             (      romdefs.asm):00074         DBasicCassOnRd                  EQU     $8021           Cassette on for reading
     8009             (      romdefs.asm):00075         DBasicCursorB                   EQU     $8009           Cursor blink
     8000             (      romdefs.asm):00076         DBasicHWInit                    EQU     $8000           Hardware initialisation
     8012             (      romdefs.asm):00077         DBasicJoyIn                     EQU     $8012           Joystick input
     8006             (      romdefs.asm):00078         DBasicKbdIn                     EQU     $8006           Keyboard input
     800F             (      romdefs.asm):00079         DBasicPrintOut                  EQU     $800F           Printer output
     800C             (      romdefs.asm):00080         DBasicScreenOut                 EQU     $800C           Screen output
     802A             (      romdefs.asm):00081         DBasicSerIn                     EQU     $802A           Read a byte from serial
     802D             (      romdefs.asm):00082         DBasicSerOut                    EQU     $802D           Write a byte to serial port
     8030             (      romdefs.asm):00083         DBasicSetBaud                   EQU     $8030           Set baud rate
     8003             (      romdefs.asm):00084         DBasicSWInit                    EQU     $8003           Software initialisation
     801B             (      romdefs.asm):00085         DBasicWriteLead                 EQU     $801B           Cassette write leader
     9C7C             (      romdefs.asm):00086         DBasIDError                     EQU     $9C7C           Print ?ID Error and return to basic
     0004             (      romdefs.asm):00087         DBasIfCount                     EQU     $0004           If count - how many in a line
     B5D3             (      romdefs.asm):00088         DBasInBuffFromX                 EQU     $B5D3           Read input buffer at X as basic input
     0009             (      romdefs.asm):00089         DBasInputFlag                   EQU     $0009           Iinput/read flag, 0=input 0<>read
     B84B             (      romdefs.asm):00090         DBasIOError                     EQU     $B84B           Print ?IO Error and return to basic
     9D3D             (      romdefs.asm):00091         DBasIRQVec                      EQU     $9D3D           Basic IRQ routine, increments timer
     015A             (      romdefs.asm):00092         DBasJoyVal0                     EQU     $015A           Joystick(0) value
     015B             (      romdefs.asm):00093         DBasJoyVal1                     EQU     $015B           Joystick(1) value
     015C             (      romdefs.asm):00094         DBasJoyVal2                     EQU     $015C           Joystick(2) value
     015D             (      romdefs.asm):00095         DBasJoyVal3                     EQU     $015D           Joystick(3) value
     9DD9             (      romdefs.asm):00096         DBasLineInputEntry              EQU     $9DD9           Entry into LINE INPUT routine, used by DOS
     02DC             (      romdefs.asm):00097         DBasLinInpBuff                  EQU     $02DC           Basic line input buffer
     02DA             (      romdefs.asm):00098         DBasLinInpHead                  EQU     $02DA           Basic line input buffer header
     8EAA             (      romdefs.asm):00099         DBasList                        EQU     $8EAA           List basic program to SysDevN A must be 0 on entry
     0066             (      romdefs.asm):00100         DBasListLine                    EQU     $0066           Current line during list
     AA87             (      romdefs.asm):00101         DBasLocateScreen                EQU     $AA87           Initialise beginning of basic after graphics screen, no of pages in A
     8D6B             (      romdefs.asm):00102         DBasLSError                     EQU     $8D6B           Print ?LS Error and return to basic
     A101             (      romdefs.asm):00103         DBasNEError                     EQU     $A101           Print ?NE Error and return to basic
     8417             (      romdefs.asm):00104         DBasNew                         EQU     $8417           Remove current basic program from meory, like NEW command
     B631             (      romdefs.asm):00105         DBasNOError                     EQU     $B631           Print ?NO Error and return to basic
     0120             (      romdefs.asm):00106         DBasNumCmds                     EQU     $0120           Number of basic commands
     012A             (      romdefs.asm):00107         DBasNumDskCmds                  EQU     $012A           Number of disk basic commands
     012F             (      romdefs.asm):00108         DBasNumDskFuncs                 EQU     $012F           Number of disk basic functions
     0125             (      romdefs.asm):00109         DBasNumFuncs                    EQU     $0125           Number of basic functions
     002D             (      romdefs.asm):00110         DBasOldInputPtr                 EQU     $002D           Pointer to saved input during a STOP
     8342             (      romdefs.asm):00111         DBasOMError                     EQU     $8342           Print ?OM Error and return to basic
     91DB             (      romdefs.asm):00112         DBasOVError                     EQU     $91DB           Print ?OV Error and return to basic
     851B             (      romdefs.asm):00113         DBasPollKeyboard                EQU     $851B           Basic, poll keyboard and check for break
     978E             (      romdefs.asm):00114         DBasRandom8                     EQU     $978E           Generate an 8 bit random number and place in BasRandomSeed+1
     0115             (      romdefs.asm):00115         DBasRandomSeed                  EQU     $0115           Random number seed for RND function
     000A             (      romdefs.asm):00116         DBasRelateFlag                  EQU     $000A           Relational operator flag
     00D1             (      romdefs.asm):00117         DBasRenumStart                  EQU     $00D1           Renum start line no
     00D5             (      romdefs.asm):00118         DBasRenumStartLine              EQU     $00D5           Renum start line number
     00CF             (      romdefs.asm):00119         DBasRenumVal                    EQU     $00CF           Renum increment value
     8434             (      romdefs.asm):00120         DBasResetStack                  EQU     $8434           Reset basic stack to initial position
     8C52             (      romdefs.asm):00121         DBasResStr                      EQU     $8C52           Reserve B bytes of string space return start in X, setup low mem vars
     8CB3             (      romdefs.asm):00122         DBasResStr2                     EQU     $8CB3           Reserve B bytes of string space return start in X
     00AB             (      romdefs.asm):00123         DBasRndData                     EQU     $00AB           Used by RND
     849F             (      romdefs.asm):00124         DBasRun                         EQU     $849F           Run basic program in memory, like RUN
     85EE             (      romdefs.asm):00125         DBasSetProgPtrX                 EQU     $85EE           Sets basic program pointer to X-1
     B4B2             (      romdefs.asm):00126         DBasSignonMess                  EQU     $B4B2           Signon message address, for CoCo this is for Extended basic.
     85E7             (      romdefs.asm):00127         DBasSkipLineNo                  EQU     $85E7           Skip past line no in basic line, UL error if no line no.
     89B4             (      romdefs.asm):00128         DBasSNError                     EQU     $89B4           Print ?SN Error and return to basic
     0019             (      romdefs.asm):00129         DBasStartProg                   EQU     $0019           Start addr of basic program
     8C99             (      romdefs.asm):00130         DBasSTError                     EQU     $8C99           Print ?OM Error and return to basic
     01A9             (      romdefs.asm):00131         DBasStrDescStack                EQU     $01A9           String descriptor stack
     000B             (      romdefs.asm):00132         DBasStrFirstFreeTemp            EQU     $000B           First free temory string space pointer
     000D             (      romdefs.asm):00133         DBasStrLastUsedTemp             EQU     $000D           Last used tempory string space pointer
     0025             (      romdefs.asm):00134         DBasStrUtil                     EQU     $0025           Utility string pointer
     0120             (      romdefs.asm):00135         DBasStub0                       EQU     $0120           Basic Stub 0 (All basic on Dragon, Colour basic on Tandy)
     012A             (      romdefs.asm):00136         DBasStub1                       EQU     $012A           Basic stub 1 (Disk basic on Dragon, Extended basic on Tandy)
     0134             (      romdefs.asm):00137         DBasStub2                       EQU     $0134           Basic Stub 2 (Null on dragon, Disk basic on Tandy)
     013E             (      romdefs.asm):00138         DBasStub3                       EQU     $013E           Basic Stub 3 (do not use on dragon, user stub on Tandy)
     0013             (      romdefs.asm):00139         DBasTempFPA2                    EQU     $0013           Tempory FPA Mantissa for FPA2
     002B             (      romdefs.asm):00140         DBasTempLine                    EQU     $002B           Tempory line no
     000F             (      romdefs.asm):00141         DBasTempPtr                     EQU     $000F           Tempory pointer
     0011             (      romdefs.asm):00142         DBasTempPtr1                    EQU     $0011           Tempory discriptor pointer (stack search)
     003F             (      romdefs.asm):00143         DBasTempRelateFlag              EQU     $003F           Tempory relational operator flag
     003B             (      romdefs.asm):00144         DBasTempVarDesc                 EQU     $003B           Pointer to a tempory var descriptor
     8882             (      romdefs.asm):00145         DBasTMError                     EQU     $8882           Print ?TM Error and return to basic
     00AF             (      romdefs.asm):00146         DBasTronFlag                    EQU     $00AF           Tron flag nonzero=trace on
     8605             (      romdefs.asm):00147         DBasULError                     EQU     $8605           Print ?UL Error and return to basic
     0076             (      romdefs.asm):00148         DBasUnused1                     EQU     $0076           2 unused bytes
     00B0             (      romdefs.asm):00149         DBasUSRTableAddr                EQU     $00B0           Address of USR address table
     0134             (      romdefs.asm):00150         DBasUsrVecNoDisk                EQU     $0134           USR vector tabl when basic not installed
     001D             (      romdefs.asm):00151         DBasVarArrayAddr                EQU     $001D           Start address of Array table
     0052             (      romdefs.asm):00152         DBasVarAssign16                 EQU     $0052           Part of FPA1, used for 16bit assigns
     0033             (      romdefs.asm):00153         DBasVarDataAddr                 EQU     $0033           Address of next item in data
     0031             (      romdefs.asm):00154         DBasVarDataLine                 EQU     $0031           Line number of current data statement
     001F             (      romdefs.asm):00155         DBasVarEnd                      EQU     $001F           End of storage in use by basic
     004F             (      romdefs.asm):00156         DBasVarFPAcc1                   EQU     $004F           Floating point acumulator 1
     005C             (      romdefs.asm):00157         DBasVarFPAcc2                   EQU     $005C           Floating point acumulator 2
     0040             (      romdefs.asm):00158         DBasVarFPAcc3                   EQU     $0040           Floating point accumulator 3 (packed)
     0045             (      romdefs.asm):00159         DBasVarFPAcc4                   EQU     $0045           Floating point accumulator 4 (packed)
     004A             (      romdefs.asm):00160         DBasVarFPAcc5                   EQU     $004A           Floating point accumulator 5 (packed)
     0037             (      romdefs.asm):00161         DBasVarLastInUse                EQU     $0037           Pointer to variable last in use
     0039             (      romdefs.asm):00162         DBasVarPtrLast                  EQU     $0039           Poiinter to VARPTR last in use
     001B             (      romdefs.asm):00163         DBasVarSimpleAddr               EQU     $001B           Start address of simple variables
     0021             (      romdefs.asm):00164         DBasVarStringBase               EQU     $0021           Base address of string space (and stack)
     0023             (      romdefs.asm):00165         DBasVarStrTop                   EQU     $0023           Top of string space in use
     0006             (      romdefs.asm):00166         DBasVarType                     EQU     $0006           Variable type flag 0=numeric, $ff=string
     841F             (      romdefs.asm):00167         DBasVect1                       EQU     $841F           Sets up various basic vectors (after load), should be followed by call to BasVect2
     8424             (      romdefs.asm):00168         DBasVect1a                      EQU     $8424           Same as Vect1, but doesn't reset input pointer
     83ED             (      romdefs.asm):00169         DBasVect2                       EQU     $83ED           Finalises setup of basic vectors (after load), should be preceeded by call to BasVect1
     93B1             (      romdefs.asm):00170         DBasZDError                     EQU     $93B1           Print ?ZD Error and return to basic
     01E3             (      romdefs.asm):00171         DCasASCIIFlag                   EQU     $01E3           ASCII flag byte
     BAC3             (      romdefs.asm):00172         DCasAudioOff                    EQU     $BAC3           Turn off audio from cassette
     BAEC             (      romdefs.asm):00173         DCasAudioOn                     EQU     $BAEC           Turn on Audio from cassete to speaker
     0083             (      romdefs.asm):00174         DCasBitCount                    EQU     $0083           Cassette bit counter
     BDA5             (      romdefs.asm):00175         DCasBitIn                       EQU     $BDA5           Reads a bity into the 'Z' flag
     B93E             (      romdefs.asm):00176         DCasBlockIn                     EQU     $B93E           Reads a block into the cassete buffer pointed to by CasIOBuffAddr
     007D             (      romdefs.asm):00177         DCasBlockLen                    EQU     $007D           Cassete block length, number of bytes read, or to be written
     B999             (      romdefs.asm):00178         DCasBlockOut                    EQU     $B999           Write a block to cassete pointed to by CasIOBuffAddr
     007C             (      romdefs.asm):00179         DCasBlockType                   EQU     $007C           Cassete block type, 0=filename, 1=data, 255=EOF
     BDAD             (      romdefs.asm):00180         DCasByteIn                      EQU     $BDAD           Reads a single byte into the A register
     BE12             (      romdefs.asm):00181         DCasByteOut                     EQU     $BE12           Write byte in A register to cassete
     0080             (      romdefs.asm):00182         DCasCkSum                       EQU     $0080           Used by cassette routines for calculating checksum
     B65F             (      romdefs.asm):00183         DCasClosFiles                   EQU     $B65F           Close any open cassete file
     01E5             (      romdefs.asm):00184         DCasEntryAddr                   EQU     $01E5           Entry address for MC programs
     0070             (      romdefs.asm):00185         DCasEOFFlag                     EQU     $0070           Cassette IO Flag, nonzero if EOF reached
     B8B3             (      romdefs.asm):00186         DCasFindFile                    EQU     $B8B3           Searches a tape for specified filename
     01D2             (      romdefs.asm):00187         DCasFName                       EQU     $01D2           Cassete filename to search for or write out
     01DA             (      romdefs.asm):00188         DCasFNameFound                  EQU     $01DA           Filename found, when reading
     01D1             (      romdefs.asm):00189         DCasFNameLen                    EQU     $01D1           Length of cassette filename can be 0 to 8
     01E2             (      romdefs.asm):00190         DCasFType                       EQU     $01E2           File type 0=tokenized basic, 1=ASCII data, 2=Binary
     01E4             (      romdefs.asm):00191         DCasGapFlag                     EQU     $01E4           Gap flag byte
     007A             (      romdefs.asm):00192         DCasHeadBuffAddr                EQU     $007A           Address of cassette file header
     01DA             (      romdefs.asm):00193         DCasIOBuff                      EQU     $01DA           COS default IO buffer, if this contains filename block then folloing are valid
     007E             (      romdefs.asm):00194         DCasIOBuffAddr                  EQU     $007E           Cassette IO buffer address, where data will be read/written
     0079             (      romdefs.asm):00195         DCasIOBuffSize                  EQU     $0079           Size of cassette IO buffer
     0081             (      romdefs.asm):00196         DCasIOErrorCode                 EQU     $0081           Cassette IO error code 0=no error, 1=CRC, 2=attempt to load in non-ram area
     006E             (      romdefs.asm):00197         DCasIOFlag                      EQU     $006E           Cassette IO Flag, set to $FF when IO in progress
     0085             (      romdefs.asm):00198         DCasLastSine                    EQU     $0085           Casette last sine tabe entry
     0090             (      romdefs.asm):00199         DCasLeadCount                   EQU     $0090           Cassete leader count, number of $55 bytes in the leader
     01E7             (      romdefs.asm):00200         DCasLoadAddr                    EQU     $01E7           Load address
     0093             (      romdefs.asm):00201         DCasMax12                       EQU     $0093           Cassette Upper limit of 1200Hz
     0094             (      romdefs.asm):00202         DCasMax24                       EQU     $0094           Cassette Upper limit of 2400Hz
     0095             (      romdefs.asm):00203         DCasMotorDelay                  EQU     $0095           Cassette motor on delay (also inter-block gap)
     BDDC             (      romdefs.asm):00204         DCasMotorOff                    EQU     $BDDC           Turn off cassette motor
     BDCF             (      romdefs.asm):00205         DCasMotorOn                     EQU     $BDCF           Turn on motor, and wait for delay in CasMotorDelay
     0092             (      romdefs.asm):00206         DCasPartrt                      EQU     $0092           Cassette 1200/2400 partition
     0084             (      romdefs.asm):00207         DCasPhaseFlag                   EQU     $0084           Cassette Phase flag
     B748             (      romdefs.asm):00208         DCasReadBin                     EQU     $B748           Read in a binary file, similar to CLOADM
     B933             (      romdefs.asm):00209         DCasReadBlock1                  EQU     $B933           Turns on motor, reads header and then first block into CasIOBufAddr
     BDE7             (      romdefs.asm):00210         DCasReadLeader                  EQU     $BDE7           Turn on motor and read past leader
     0078             (      romdefs.asm):00211         DCasStatus                      EQU     $0078           Cassette status byte, 0=cassette closed, 1=open for input, 2=open for output
     0082             (      romdefs.asm):00212         DCasTemp                        EQU     $0082           Cassette tempory storage
     B6A5             (      romdefs.asm):00213         DCasWriteBasic                  EQU     $B6A5           Write tokenized basic program out, similar to CSAVE
     991B             (      romdefs.asm):00214         DCasWriteBin                    EQU     $991B           Write a binary file out push return address, then start,end and entry addresses and then JMP to this
     B991             (      romdefs.asm):00215         DCasWriteBlock1                 EQU     $B991           Turn on motor, write leader and then first block
     801B             (      romdefs.asm):00216         DCasWriteLeader                 EQU     $801B           Turn on motor and write out leader
     943E             (      romdefs.asm):00217         DCmdABS                         EQU     $943E           Basic Command
     8A12             (      romdefs.asm):00218         DCmdAND                         EQU     $8A12           Basic Command
     8DE6             (      romdefs.asm):00219         DCmdASC                         EQU     $8DE6           Basic Command
     9877             (      romdefs.asm):00220         DCmdATN                         EQU     $9877           Basic Command
     BADF             (      romdefs.asm):00221         DCmdAudio                       EQU     $BADF           Basic Command
     8DD2             (      romdefs.asm):00222         DCmdCHRS                        EQU     $8DD2           Basic Command
     B238             (      romdefs.asm):00223         DCmdCircle                      EQU     $B238           Basic Command
     8571             (      romdefs.asm):00224         DCmdClear                       EQU     $8571           Basic Command
     B6D5             (      romdefs.asm):00225         DCmdCload                       EQU     $B6D5           Basic Command
     B64D             (      romdefs.asm):00226         DCmdClose                       EQU     $B64D           Basic Command
     BA60             (      romdefs.asm):00227         DCmdCLS                         EQU     $BA60           Basic Command
     A8D4             (      romdefs.asm):00228         DCmdColor                       EQU     $A8D4           Basic Command
     8560             (      romdefs.asm):00229         DCmdCont                        EQU     $8560           Basic Command
     97CB             (      romdefs.asm):00230         DCmdCOS                         EQU     $97CB           Basic Command
     B683             (      romdefs.asm):00231         DCmdCsave                       EQU     $B683           Basic Command
     8613             (      romdefs.asm):00232         DCmdData                        EQU     $8613           Basic Command
     9C81             (      romdefs.asm):00233         DCmdDef                         EQU     $9C81           Basic Command
     9D61             (      romdefs.asm):00234         DCmdDelete                      EQU     $9D61           Basic Command
     8A8B             (      romdefs.asm):00235         DCmdDim                         EQU     $8A8B           Basic Command
     933C             (      romdefs.asm):00236         DCmdDivide                      EQU     $933C           Basic Command
     A049             (      romdefs.asm):00237         DCmdDload                       EQU     $A049           Basic Command
     B051             (      romdefs.asm):00238         DCmdDraw                        EQU     $B051           Basic Command
     9965             (      romdefs.asm):00239         DCmdEdit                        EQU     $9965           Basic Command
     8532             (      romdefs.asm):00240         DCmdEnd                         EQU     $8532           Basic Command
     B801             (      romdefs.asm):00241         DCmdEOF                         EQU     $B801           Basic Command
     B771             (      romdefs.asm):00242         DCmdExec                        EQU     $B771           Basic Command
     9713             (      romdefs.asm):00243         DCmdEXP                         EQU     $9713           Basic Command
     96A0             (      romdefs.asm):00244         DCmdExponet                     EQU     $96A0           Basic Command
     9956             (      romdefs.asm):00245         DCmdFIX                         EQU     $9956           Basic Command
     8448             (      romdefs.asm):00246         DCmdFor                         EQU     $8448           Basic Command
     AAF0             (      romdefs.asm):00247         DCmdGet                         EQU     $AAF0           Basic Command
     85B9             (      romdefs.asm):00248         DCmdGo                          EQU     $85B9           Basic Command
     A00E             (      romdefs.asm):00249         DCmdHexS                        EQU     $A00E           Basic Command
     8647             (      romdefs.asm):00250         DCmdIF                          EQU     $8647           Basic Command
     B797             (      romdefs.asm):00251         DCmdInkeyS                      EQU     $B797           Basic Command
     872B             (      romdefs.asm):00252         DCmdInput                       EQU     $872B           Basic Command
     9BB4             (      romdefs.asm):00253         DCmdInstr                       EQU     $9BB4           Basic Command
     9499             (      romdefs.asm):00254         DCmdINT                         EQU     $9499           Basic Command
     BB0D             (      romdefs.asm):00255         DCmdJoystk                      EQU     $BB0D           Basic Command
     8DF1             (      romdefs.asm):00256         DCmdLeftS                       EQU     $8DF1           Basic Command
     8DC7             (      romdefs.asm):00257         DCmdLEN                         EQU     $8DC7           Basic Command
     86BC             (      romdefs.asm):00258         DCmdLet                         EQU     $86BC           Basic Command
     A749             (      romdefs.asm):00259         DCmdLine                        EQU     $A749           Basic Command
     9DB1             (      romdefs.asm):00260         DCmdLineInput                   EQU     $9DB1           Line input command
     8EAA             (      romdefs.asm):00261         DCmdList                        EQU     $8EAA           Basic Command
     8EA4             (      romdefs.asm):00262         DCmdLList                       EQU     $8EA4           Basic Command
     923C             (      romdefs.asm):00263         DCmdLOG                         EQU     $923C           Basic Command
     8C31             (      romdefs.asm):00264         DCmdMEM                         EQU     $8C31           Basic Command
     8E15             (      romdefs.asm):00265         DCmdMidS                        EQU     $8E15           Basic Command
     9105             (      romdefs.asm):00266         DCmdMinus                       EQU     $9105           Basic Command
     B982             (      romdefs.asm):00267         DCmdMotor                       EQU     $B982           Basic Command
     9275             (      romdefs.asm):00268         DCmdMultiply                    EQU     $9275           Basic Command
     8415             (      romdefs.asm):00269         DCmdNew                         EQU     $8415           Basic Command
     8829             (      romdefs.asm):00270         DCmdNext                        EQU     $8829           Basic Command
     8675             (      romdefs.asm):00271         DCmdON                          EQU     $8675           Basic Command
     B829             (      romdefs.asm):00272         DCmdOpen                        EQU     $B829           Basic Command
     B835             (      romdefs.asm):00273         DCmdOpenEntry                   EQU     $B835           Entry into Basic open command used by Dragon/SuperDos
     8A11             (      romdefs.asm):00274         DCmdOR                          EQU     $8A11           Basic Command
     AC87             (      romdefs.asm):00275         DCmdPaint                       EQU     $AC87           Basic Command
     AA19             (      romdefs.asm):00276         DCmdPClear                      EQU     $AA19           Basic Command
     A8C0             (      romdefs.asm):00277         DCmdPCls                        EQU     $A8C0           Basic Command
     AABE             (      romdefs.asm):00278         DCmdPcopy                       EQU     $AABE           Basic Command
     8E96             (      romdefs.asm):00279         DCmdPeek                        EQU     $8E96           Basic Command
     ADBD             (      romdefs.asm):00280         DCmdPlay                        EQU     $ADBD           Basic Command
     910E             (      romdefs.asm):00281         DCmdPlus                        EQU     $910E           Basic Command
     A9AF             (      romdefs.asm):00282         DCmdPmode                       EQU     $A9AF           Basic Command
     BA45             (      romdefs.asm):00283         DCmdPoint                       EQU     $BA45           Basic Command
     8E9D             (      romdefs.asm):00284         DCmdPoke                        EQU     $8E9D           Basic Command
     9ADE             (      romdefs.asm):00285         DCmdPOS                         EQU     $9ADE           Basic Command
     A6C7             (      romdefs.asm):00286         DCmdPPoint                      EQU     $A6C7           Basic Command
     A6F3             (      romdefs.asm):00287         DCmdPReset                      EQU     $A6F3           Basic Command
     903D             (      romdefs.asm):00288         DCmdPrint                       EQU     $903D           Basic Command
     A6EF             (      romdefs.asm):00289         DCmdPset                        EQU     $A6EF           Basic Command
     AAF3             (      romdefs.asm):00290         DCmdPut                         EQU     $AAF3           Basic Command
     8777             (      romdefs.asm):00291         DCmdRead                        EQU     $8777           Basic Command
     877A             (      romdefs.asm):00292         DCmdReadFromX                   EQU     $877A           As basic READ command but ptr in X supplied by caller
     8616             (      romdefs.asm):00293         DCmdREM                         EQU     $8616           Basic Command
     9DFA             (      romdefs.asm):00294         DCmdRenum                       EQU     $9DFA           Basic Command
     BA04             (      romdefs.asm):00295         DCmdReset                       EQU     $BA04           Basic Command
     8514             (      romdefs.asm):00296         DCmdRestore                     EQU     $8514           Basic Command
     85F3             (      romdefs.asm):00297         DCmdReturn                      EQU     $85F3           Basic Command
     8E0E             (      romdefs.asm):00298         DCmdRightS                      EQU     $8E0E           Basic Command
     9772             (      romdefs.asm):00299         DCmdRND                         EQU     $9772           Basic Command
     85A5             (      romdefs.asm):00300         DCmdRun                         EQU     $85A5           Basic Command
     A9FE             (      romdefs.asm):00301         DCmdScreen                      EQU     $A9FE           Basic Command
     B9D3             (      romdefs.asm):00302         DCmdSet                         EQU     $B9D3           Basic Command
     9425             (      romdefs.asm):00303         DCmdSGN                         EQU     $9425           Basic Command
     97D1             (      romdefs.asm):00304         DCmdSIN                         EQU     $97D1           Basic Command
     B81F             (      romdefs.asm):00305         DCmdSkipf                       EQU     $B81F           Basic Command
     BA9B             (      romdefs.asm):00306         DCmdSound                       EQU     $BA9B           Basic Command
     9697             (      romdefs.asm):00307         DCmdSQR                         EQU     $9697           Basic Command
     8539             (      romdefs.asm):00308         DCmdStop                        EQU     $8539           Basic Command
     9B84             (      romdefs.asm):00309         DCmdStringS                     EQU     $9B84           Basic Command
     8C40             (      romdefs.asm):00310         DCmdSTRS                        EQU     $8C40           Basic Command
     9816             (      romdefs.asm):00311         DCmdTAN                         EQU     $9816           Basic Command
     9D59             (      romdefs.asm):00312         DCmdTimer                       EQU     $9D59           Basic Command
     9ADA             (      romdefs.asm):00313         DCmdTroff                       EQU     $9ADA           Basic Command
     9AD9             (      romdefs.asm):00314         DCmdTron                        EQU     $9AD9           Basic Command
     9D1D             (      romdefs.asm):00315         DCmdUSR                         EQU     $9D1D           Basic Command
     8E5C             (      romdefs.asm):00316         DCmdVAL                         EQU     $8E5C           Basic Command
     9AF4             (      romdefs.asm):00317         DCmdVarptr                      EQU     $9AF4           Basic Command
     00B3             (      romdefs.asm):00318         DGrBackground                   EQU     $00B3           Current background colour
     00B9             (      romdefs.asm):00319         DGrBytesPerLine                 EQU     $00B9           Number of byts/lin in current mode
     BA28             (      romdefs.asm):00320         DGrCalcPixelPos                 EQU     $BA28           Calculates Lo-res pixel pos from data on stack
     00D0             (      romdefs.asm):00321         DGrCircleRadius                 EQU     $00D0           Circle radius
     00CB             (      romdefs.asm):00322         DGrCircleXCo                    EQU     $00CB           Circle command X
     00CD             (      romdefs.asm):00323         DGrCircleYCo                    EQU     $00CD           Circle command Y
     A8C7             (      romdefs.asm):00324         DGrClearGrScreen                EQU     $A8C7           Clears grapics screen to value in B
     00C1             (      romdefs.asm):00325         DGrColourSet                    EQU     $00C1           Colour set currently in use
     00B4             (      romdefs.asm):00326         DGrColourTemp                   EQU     $00B4           Tempory colour in use
     00B5             (      romdefs.asm):00327         DGrCurrColour                   EQU     $00B5           Byte value for current colour, to set all pixels in byte to that colour
     00B6             (      romdefs.asm):00328         DGrCurrPmode                    EQU     $00B6           Current PMODE number
     00BD             (      romdefs.asm):00329         DGrCurrX                        EQU     $00BD           Current X cursor pos
     00C7             (      romdefs.asm):00330         DGrCurrXCo                      EQU     $00C7           Current Cursor X
     00BF             (      romdefs.asm):00331         DGrCurrY                        EQU     $00BF           Current Y cursor pos
     00C9             (      romdefs.asm):00332         DGrCurrYCo                      EQU     $00C9           Current Cursor Y
     00DB             (      romdefs.asm):00333         DGrDirtyFlag                    EQU     $00DB           Flag to tell if graphics screen has changed
     00BA             (      romdefs.asm):00334         DGrDisplayStartAddr             EQU     $00BA           Address of first byte in current display
     B051             (      romdefs.asm):00335         DGrDraw                         EQU     $B051           Draw on pmode screen as in DRAW command
     00E8             (      romdefs.asm):00336         DGrDrawAngle                    EQU     $00E8           Current angle for DRAW command
     00E9             (      romdefs.asm):00337         DGrDrawScale                    EQU     $00E9           Current scale for DRAW command
     00B2             (      romdefs.asm):00338         DGrForeground                   EQU     $00B2           Current foreground colour
     00B7             (      romdefs.asm):00339         DGrLastDisplayAddr              EQU     $00B7           Address of last byte in current display
     00C3             (      romdefs.asm):00340         DGrPixelNoX                     EQU     $00C3           Current horizontal pixel no
     00C5             (      romdefs.asm):00341         DGrPixelNoY                     EQU     $00C5           Current vertical pixel number
     00C2             (      romdefs.asm):00342         DGrPlotFlag                     EQU     $00C2           Plot/Unplot flag, 0=reset, nonzero=set
     AA23             (      romdefs.asm):00343         DGrReserveGrRam                 EQU     $AA23           Reserves memory for graphics, no graphics pages in B
     BA07             (      romdefs.asm):00344         DGrResetLRGPixel                EQU     $BA07           ReSets lo res pixel
     AA10             (      romdefs.asm):00345         DGrSelectColourSet              EQU     $AA10           Selects colour set dependent on B
     A938             (      romdefs.asm):00346         DGrSelectDisplay                EQU     $A938           Sets Text or Graphics screen, if Z=1 then text
     A9E1             (      romdefs.asm):00347         DGrSelectPage                   EQU     $A9E1           On entry B contains Pmode page to be used
     A9A4             (      romdefs.asm):00348         DGrSelectVDGColSet              EQU     $A9A4           Select colour set from data in GrColourSet
     A928             (      romdefs.asm):00349         DGrSetColours                   EQU     $A928           Sets up colours in low memory
     B9DF             (      romdefs.asm):00350         DGrSetLRGPixel                  EQU     $B9DF           Sets lo res pixel
     0086             (      romdefs.asm):00351         DGrSetResetData                 EQU     $0086           Data for Lo-res set/reset
     A989             (      romdefs.asm):00352         DGrSetVDGMode                   EQU     $A989           Set VDG to mode in A register
     A99D             (      romdefs.asm):00353         DGrSetVDGOffset                 EQU     $A99D           Set VDG offset to page in A
     00BC             (      romdefs.asm):00354         DGrStartPages                   EQU     $00BC           Page number of Start of graphics pages
     A006             (      romdefs.asm):00355         DIndCasBlockIn                  EQU     $A006           Indirect Read cassette block
     A008             (      romdefs.asm):00356         DIndCasBlockOut                 EQU     $A008           Indirect Write cassete block
     A004             (      romdefs.asm):00357         DIndCasOnRead                   EQU     $A004           Indirect prepare cassette for read
     A00C             (      romdefs.asm):00358         DIndCasWriteLead                EQU     $A00C           Indirect Write cassette leader
     A002             (      romdefs.asm):00359         DIndCharOutput                  EQU     $A002           Indirect Character output
     A00A             (      romdefs.asm):00360         DIndJoystickIn                  EQU     $A00A           Indirect joystick in
     A000             (      romdefs.asm):00361         DIndKeyInput                    EQU     $A000           Indirect keyboard input jsr()
     0072             (      romdefs.asm):00362         DIndVecReset                    EQU     $0072           Secondary Reset vector address, must point to NOP
     008A             (      romdefs.asm):00363         DMisc16BitScratch               EQU     $008A           Misc 16 bit scratch register (always zero ??)
     A66B             (      romdefs.asm):00364         DPixMaskTable2Col               EQU     $A66B           Pixel mask table 2 colour mode
     A673             (      romdefs.asm):00365         DPixMaskTable4Col               EQU     $A673           Pixel mask table 4 colour mode
     BD0A             (      romdefs.asm):00366         DPrinterCRLF                    EQU     $BD0A           Moves printer head to next line.
     BCF5             (      romdefs.asm):00367         DPrinterDirOut                  EQU     $BCF5           Sends character in A register to printer (uncooked)
     BD1A             (      romdefs.asm):00368         DPrinterOut                     EQU     $BD1A           Sends character in A register to printer
     010F             (      romdefs.asm):00369         DSecVecFIRQ                     EQU     $010F           Secondary FIRQ vector JMP+ address
     010C             (      romdefs.asm):00370         DSecVecIRQ                      EQU     $010C           Secondary IRQ vector JMP+ address
     0109             (      romdefs.asm):00371         DSecVecNMI                      EQU     $0109           Secondary NMI vector JMP+ address
     0106             (      romdefs.asm):00372         DSecVecSWI                      EQU     $0106           Secondary NMI vector JMP+ address
     0103             (      romdefs.asm):00373         DSecVecSWI2                     EQU     $0103           Secondary SWI2 vector JMP+ address
     0100             (      romdefs.asm):00374         DSecVecSWI3                     EQU     $0100           Secondary SWI3 vector JMP+ address
     0000             (      romdefs.asm):00375         DSerDLBaud                      EQU     $0000           Baud rate for DLOAD, unknown for Dragon
     0000             (      romdefs.asm):00376         DSerDLTimeout                   EQU     $0000           Timeourt for DLOAD, unknown for Dragon
     BAA0             (      romdefs.asm):00377         DSndBeep                        EQU     $BAA0           Play a beep duration in B, frequency in SndPitch
     BAC3             (      romdefs.asm):00378         DSndDisable                     EQU     $BAC3           Disables D/A sound output
     00E5             (      romdefs.asm):00379         DSndDotNoteScale                EQU     $00E5           Dotted note scale factor for Play
     BAED             (      romdefs.asm):00380         DSndDTOAOn                      EQU     $BAED           Turn on audio to D/A converter
     BAC5             (      romdefs.asm):00381         DSndEnable                      EQU     $BAC5           Enables D/A sound output
     008D             (      romdefs.asm):00382         DSndLength                      EQU     $008D           Sound duration
     00E1             (      romdefs.asm):00383         DSndNoteLen                     EQU     $00E1           Note length for PLAY
     00DE             (      romdefs.asm):00384         DSndOctave                      EQU     $00DE           Sound octave value for PLAY
     008C             (      romdefs.asm):00385         DSndPitch                       EQU     $008C           Sound pitch value
     AE9A             (      romdefs.asm):00386         DSndPlayNote                    EQU     $AE9A           Plays a note from the A register (ASCII)
     00E2             (      romdefs.asm):00387         DSndTempo                       EQU     $00E2           Tempo for PLAY
     00E3             (      romdefs.asm):00388         DSndTimerPlay                   EQU     $00E3           Timer for the Play command
     00DF             (      romdefs.asm):00389         DSndVolume                      EQU     $00DF           Sound volume for PLAY
     BB80             (      romdefs.asm):00390         DSysBoot64                      EQU     $BB80           Dragon 64 only, boots basic into all ram mode, with 48K available to basic.
     8344             (      romdefs.asm):00391         DSysErr                         EQU     $8344           Report error code in B register, cleanup and return to basic
     835E             (      romdefs.asm):00392         DSysErr2                        EQU     $835E           Report error in B, do NOT hook to RAM, or turn of cas etc
     BD52             (      romdefs.asm):00393         DSysReadJoystick                EQU     $BD52           Read hardware joystick values & update BasJoyVal0..3
     B3B4             (      romdefs.asm):00394         DSysReset                       EQU     $B3B4           Perform soft reset, as if reset button pressed
     BAD4             (      romdefs.asm):00395         DSysResetDA                     EQU     $BAD4           Reset D/A converter to $7E
     BD41             (      romdefs.asm):00396         DSysSelJoystick                 EQU     $BD41           Select joystick alue to read from A
     0112             (      romdefs.asm):00397         DSysTimeVal                     EQU     $0112           Current value of system timer
     BAD6             (      romdefs.asm):00398         DSysWriteDA                     EQU     $BAD6           Write value in A to D/A, bits 0 &1 should be 0
     0149             (      romdefs.asm):00399         DTextCapsLock                   EQU     $0149           Capslock flag, nonzero=uppercase
     BCA0             (      romdefs.asm):00400         DTextClearLine                  EQU     $BCA0           Clears a VDU line from current cursor pos to EOL
     BA77             (      romdefs.asm):00401         DTextCls                        EQU     $BA77           Clear text mode screen, resets cursor to top left
     BA79             (      romdefs.asm):00402         DTextClsChar                    EQU     $BA79           Clears srcrren to character in B register & resets cursor
     008F             (      romdefs.asm):00403         DTextCursFalshCnt               EQU     $008F           Cusrsor flash counter
     006F             (      romdefs.asm):00404         DTextDevN                       EQU     $006F           Current device number
     0035             (      romdefs.asm):00405         DTextKbdBuffAddr                EQU     $0035           Address of keyboard input buffer
     0097             (      romdefs.asm):00406         DTextKbdDelay                   EQU     $0097           Keyboard scan delay constant, used to debounce
     0150             (      romdefs.asm):00407         DTextKbdRollover                EQU     $0150           Rollover table, to check for key releases
     0087             (      romdefs.asm):00408         DTextLastKey                    EQU     $0087           ASCII code of last keypress, not cleard by key release
     B54A             (      romdefs.asm):00409         DTextOutChar                    EQU     $B54A           Outputs character in A to screen
     90A1             (      romdefs.asm):00410         DTextOutCRLF                    EQU     $90A1           Outputs an EOL sequence to the screen
     957A             (      romdefs.asm):00411         DTextOutNum16                   EQU     $957A           Outputs unsigned integer in D to the TextDevN device
     9582             (      romdefs.asm):00412         DTextOutNumFPA0                 EQU     $9582           Outputs number in FPA0 to screen
     90F8             (      romdefs.asm):00413         DTextOutQuestion                EQU     $90F8           Outputs a question mark to screen
     90F5             (      romdefs.asm):00414         DTextOutSpace                   EQU     $90F5           Outputs a space to screen
     90E5             (      romdefs.asm):00415         DTextOutString                  EQU     $90E5           Outputs string pointed to by X to screen, X should point to byte before first byte of string
     0148             (      romdefs.asm):00416         DTextPrnAutoCRLF                EQU     $0148           Printer auto EOL flag, nonzero will send EOL sequence at end of line
     0099             (      romdefs.asm):00417         DTextPrnCommaW                  EQU     $0099           Printer comma width
     009C             (      romdefs.asm):00418         DTextPrnCurrCol                 EQU     $009C           Printer current column
     014A             (      romdefs.asm):00419         DTextPrnEOLCnt                  EQU     $014A           Number of characters in EOL sequence 1..4
     014B             (      romdefs.asm):00420         DTextPrnEOLSeq                  EQU     $014B           End of line characters
     009A             (      romdefs.asm):00421         DTextPrnLastComma               EQU     $009A           Printer last comma width, should be printer line width - prinnter comma width
     009B             (      romdefs.asm):00422         DTextPrnLineW                   EQU     $009B           Printer line width
     03FF             (      romdefs.asm):00423         DTextPrnSelFlag                 EQU     $03FF           Dragon 64 printer selection flag, 0=paralell port, nonzero=RS232
     A93A             (      romdefs.asm):00424         DTextResetVDU                   EQU     $A93A           Resets to text mode and screen base address of $400
     BBE5             (      romdefs.asm):00425         DTextScanKbd                    EQU     $BBE5           Scan keyboard, return Char in A, Zero flag set if no key
     FF07             (      romdefs.asm):00426         DTextSerBaudRate                EQU     $FF07           Serial baud rate, note on Dragon 64, this is the actual hardware baud rate reg.
     03FD             (      romdefs.asm):00427         DTextSerEOLDelay                EQU     $03FD           End of line delay for serial port on Dragon 64 & CoCo
     BBB5             (      romdefs.asm):00428         DTextUpdateCurs                 EQU     $BBB5           Decrements TextCursFlashCnt, if zero resets and flashes cursor
     006A             (      romdefs.asm):00429         DTextVDUCommaW                  EQU     $006A           VDU comma width field
     006C             (      romdefs.asm):00430         DTextVDUCurrCol                 EQU     $006C           Current column for VDU output
     0088             (      romdefs.asm):00431         DTextVDUCursAddr                EQU     $0088           Current VDU cursor address
     006B             (      romdefs.asm):00432         DTextVDULastComma               EQU     $006B           VDU last comma field, should be VDU line width - VDU comma width
     006D             (      romdefs.asm):00433         DTextVDULineW                   EQU     $006D           VDU line width, normally 32
     BCAB             (      romdefs.asm):00434         DTextVDUOut                     EQU     $BCAB           Outputs Char in A to VDU, does not reset screen.
     852B             (      romdefs.asm):00435         DTextWaitKey                    EQU     $852B           Wait for a keypress, calls TextScanKbd, also handles break
     A0EA             (      romdefs.asm):00436         DTextWaitKeyCurs                EQU     $A0EA           Same as TextWaitKey, but with cursor
     B505             (      romdefs.asm):00437         DTextWaitKeyCurs2               EQU     $B505           Same as TextWaitKey, but with cursor
     B7CC             (      romdefs.asm):00438         DUtilCopyBXtoU                  EQU     $B7CC           Copy B bytes from X to U
     8C35             (      romdefs.asm):00439         DVarAssign16Bit                 EQU     $8C35           Assigns value in D register to a variable, and returns to basic
     8C37             (      romdefs.asm):00440         DVarAssign16Bit2                EQU     $8C37           Assigns value in D register to a variable, and returns to basic (1 less instruction!).
     9C3E             (      romdefs.asm):00441         DVarAssign16BitB                EQU     $9C3E           Assigns value in BasVarAssign16 to a variable, and returns to basic
     8C36             (      romdefs.asm):00442         DVarAssign8Bit                  EQU     $8C36           Assigns value in B register to a variable, and returns to basic
     89AC             (      romdefs.asm):00443         DVarCKChar                      EQU     $89AC           Check for char in B register in command line, SNError if not
     89A4             (      romdefs.asm):00444         DVarCKClBrac                    EQU     $89A4           Check for Close bracket ')' in command line, SNError if not
     89AA             (      romdefs.asm):00445         DVarCKComma                     EQU     $89AA           Check for Comma in command line, SNError if not
     89A7             (      romdefs.asm):00446         DVarCKOpBrac                    EQU     $89A7           Check for Open bracket '(' in command line, SNError if not
     8D9F             (      romdefs.asm):00447         DVarDelVar                      EQU     $8D9F           Frees up storage used by a variable
     8CD7             (      romdefs.asm):00448         DVarGarbageCollect              EQU     $8CD7           Forces garbage collection in string space
     8E83             (      romdefs.asm):00449         DVarGet16Bit                    EQU     $8E83           Returns value of variable in D,FCError if more than 16 bits
     8E51             (      romdefs.asm):00450         DVarGet8Bit                     EQU     $8E51           Returns value of variable in B,FCError if more than 8 bits
     8E7E             (      romdefs.asm):00451         DVarGetComma8                   EQU     $8E7E           Checks for comman then gets 8 bit.
     8877             (      romdefs.asm):00452         DVarGetExpr                     EQU     $8877           Evaluate and put the VARPTR of experssion which follows in BasVarAssign16 (carry set)
     8874             (      romdefs.asm):00453         DVarGetExprCC                   EQU     $8874           Evaluate and put the VARPTR of experssion which follows in BasVarAssign16 (carry clear)
     8887             (      romdefs.asm):00454         DVarGetStr                      EQU     $8887           Compiles string and moves to free string space, should be followed by VarGetExpr
     8B29             (      romdefs.asm):00455         DVarGetUsr                      EQU     $8B29           Returns argument to USRnn as a 16bit no in D
     8A94             (      romdefs.asm):00456         DVarGetVar                      EQU     $8A94           Gets VARPTR address of following name and places in BasVarPtrLast
     9165             (      romdefs.asm):00457         DVarNormFPA0                    EQU     $9165           Normalize FPA0
     01A0             (      romdefs.asm):00458         DVectAccessScreen               EQU     $01A0           Called before CLS, GET & PUT are executed
     019D             (      romdefs.asm):00459         DVectAssignStr                  EQU     $019D           Called before assigning string to string variable
     015E             (      romdefs.asm):00460         DVectBase                       EQU     $015E           Base address of ram hooks/vectors
     0188             (      romdefs.asm):00461         DVectCheckEOF                   EQU     $0188           called before checking for end of file
     017F             (      romdefs.asm):00462         DVectCheckKeys                  EQU     $017F           Called before keyboard is scanned for BREAK,SHIFT-@
     0173             (      romdefs.asm):00463         DVectCloseAllFiles              EQU     $0173           Called before closing all files
     0176             (      romdefs.asm):00464         DVectCloseFile                  EQU     $0176           Called before closing a file
     0185             (      romdefs.asm):00465         DVectCloseFileCmd               EQU     $0185           Called before closing an ASCII file read in as basic
     0179             (      romdefs.asm):00466         DVectCmdInterp                  EQU     $0179           Called before interpreting a token in A
     01A6             (      romdefs.asm):00467         DVectDeTokenize                 EQU     $01A6           Called before a line is de-tokenized
     0164             (      romdefs.asm):00468         DVectDevInit                    EQU     $0164           Called before initialising a device
     0161             (      romdefs.asm):00469         DVectDevNo                      EQU     $0161           Called when a device number is verified
     015E             (      romdefs.asm):00470         DVectDevOpen                    EQU     $015E           Called before a device is opened
     018B             (      romdefs.asm):00471         DVectEvaluateExpr               EQU     $018B           Called before evaluating expression
     019A             (      romdefs.asm):00472         DVectGetNextCmd                 EQU     $019A           Called before fetching next command to be executed by BASIC
     016A             (      romdefs.asm):00473         DVectInChar                     EQU     $016A           Called before inputting a char to A
     016D             (      romdefs.asm):00474         DVectInputFile                  EQU     $016D           Called before inputting from a file
     0182             (      romdefs.asm):00475         DVectLineInputFile              EQU     $0182           Called before LINE INPUT is executed
     0167             (      romdefs.asm):00476         DVectOutChar                    EQU     $0167           Called before outputting char in A to a device
     0170             (      romdefs.asm):00477         DVectOutputFile                 EQU     $0170           Called before outputting to a file
     017C             (      romdefs.asm):00478         DVectReReqestIn                 EQU     $017C           Called before re-requesing input from keyboard
     0197             (      romdefs.asm):00479         DVectResetBasMem                EQU     $0197           Called before changing BASIC memory vectors after LOAD etc
     0194             (      romdefs.asm):00480         DVectRunLink                    EQU     $0194           Called when RUN about to be executed
     0191             (      romdefs.asm):00481         DVectSysError                   EQU     $0191           Can be patched by system to trap error messages
     01A3             (      romdefs.asm):00482         DVectTokenize                   EQU     $01A3           Called before an ASCII line is tokenized
     018E             (      romdefs.asm):00483         DVectUserError                  EQU     $018E           Can be patched by user to trap error messages
     B44F             (      romdefs.asm):00484         DWarmStart                      EQU     $B44F           Warm start routine
     0071             (      romdefs.asm):00485         DWarmStartFlag                  EQU     $0071           Warm start flag $55=warm start, else cold start
                      (      romdefs.asm):00486         
     0000             (      romdefs.asm):00487         CStubResWordsOfs                EQU     $0000           Offset of number of reserved words
     0001             (      romdefs.asm):00488         CStubResLookupOfs               EQU     $0001           Offset of reserved word lookup table
     0003             (      romdefs.asm):00489         CStubResJumpOfs                 EQU     $0003           Offset of reserved word jump table
     0005             (      romdefs.asm):00490         CStubFuncsOfs                   EQU     $0005           Offset of nummber of functions
     0006             (      romdefs.asm):00491         CStubFuncsLookupOfs             EQU     $0006           Offset of function lookup table
     0008             (      romdefs.asm):00492         CStubFuncsJumpOfs               EQU     $0008           Offset of functions jump table
                      (      romdefs.asm):00493         
     0021             (      romdefs.asm):00494         CSkip1                          EQU     $0021           Skip 1 byte (BRN)
     008C             (      romdefs.asm):00495         CSkip2                          EQU     $008C           Skip 2 bytes (CMPX)
     0086             (      romdefs.asm):00496         CSkip1LD                        EQU     $0086           Skip 1 byte (LDA)
     007D             (      romdefs.asm):00497         CSkip2TST                       EQU     $007D           Skip 2 bytes (TST)
                      (      romdefs.asm):00498         
     8273             (      romdefs.asm):00499         CCoCoVec167                     EQU     $8273           Vector dest for 167 
     8CF1             (      romdefs.asm):00500         CCoCoVect16A                    EQU     $8CF1           Vector dest for 16A
     8286             (      romdefs.asm):00501         CCoCoVect176                    EQU     $8286           Vector dest for 176
     8E90             (      romdefs.asm):00502         CCoCoVect179                    EQU     $8E90           Vector dest for 179
     8846             (      romdefs.asm):00503         CCoCoVect18B                    EQU     $8846           Vector dest for 18B
     88F0             (      romdefs.asm):00504         CCoCoVect191                    EQU     $88F0           Vector dest for 191
     829C             (      romdefs.asm):00505         CCoCoVect194                    EQU     $829C           Vector Dest for 194
     87E5             (      romdefs.asm):00506         CCoCoVect197                    EQU     $87E5           Vector Dest for 197
     82B9             (      romdefs.asm):00507         CCoCoVect19A                    EQU     $82B9           Vector Dest for 19A
     8304             (      romdefs.asm):00508         CCoCoVect1A3                    EQU     $8304           Vector Dest for 1A3
     0027             (      romdefs.asm):00509         CAddrFWareRamTop                EQU     $0027           Top of firmware RAM CLEAR xxx,yyyy set this to yyyy
     0074             (      romdefs.asm):00510         CAddrRamTop                     EQU     $0074           Physical end of RAM (4K, 16K, 32K or 64K).
     0021             (      romdefs.asm):00511         CAddrStack                      EQU     $0021           Address of top of machine stack
     0123             (      romdefs.asm):00512         CBasAddrCmdDisp                 EQU     $0123           Address of basic command dispatch
     0121             (      romdefs.asm):00513         CBasAddrCmdList                 EQU     $0121           Address of basic command list
     012D             (      romdefs.asm):00514         CBasAddrDskCmdDisp              EQU     $012D           Address of disk basic command dispatch
     012B             (      romdefs.asm):00515         CBasAddrDskCmdList              EQU     $012B           Address of disk basic command list
     0132             (      romdefs.asm):00516         CBasAddrDskFuncDisp             EQU     $0132           Address of disk basic function dispatcher
     0130             (      romdefs.asm):00517         CBasAddrDskFuncList             EQU     $0130           Address of disk basic function list
     0128             (      romdefs.asm):00518         CBasAddrFuncDisp                EQU     $0128           Address of basic function dispatcher
     0126             (      romdefs.asm):00519         CBasAddrFuncList                EQU     $0126           Address of basic function list
     00A6             (      romdefs.asm):00520         CBasAddrSigByte                 EQU     $00A6           Address of current significant bit in command line
     A61C             (      romdefs.asm):00521         CBasAOError                     EQU     $A61C           Print ?AO Error and return to basic
     0005             (      romdefs.asm):00522         CBasArrayEval                   EQU     $0005           Array evaluation flag, 0=eval, 1=dimensioning
     A0B6             (      romdefs.asm):00523         CBasBootBasic                   EQU     $A0B6           Restart basic, as if power on, also deletes current program
     0017             (      romdefs.asm):00524         CBasBotStack                    EQU     $0017           Bottom of stack at last check
     ADC4             (      romdefs.asm):00525         CBasBRARun                      EQU     $ADC4           BRA to main loop, used by DOS
     0000             (      romdefs.asm):00526         CBasBreakFlag                   EQU     $0000           Break flag, +ve=stop,-ve=end
     03D7             (      romdefs.asm):00527         CBasBuffer                      EQU     $03D7           Basic buffer space
     AC1E             (      romdefs.asm):00528         CBasChkArrSpaceMv               EQU     $AC1E           Check memory space at top of arrays + move arrays
     AC33             (      romdefs.asm):00529         CBasChkB2Free                   EQU     $AC33           Check B*2 bytes free above Arrays, OM error if not
     8866             (      romdefs.asm):00530         CBasChkDirect                   EQU     $8866           Check for direct mode, ID Error if so
     009F             (      romdefs.asm):00531         CBasChrGet                      EQU     $009F           Get next basic character routine
     00A5             (      romdefs.asm):00532         CBasChrGetCurr                  EQU     $00A5           Get current basic ccharacter
     00D3             (      romdefs.asm):00533         CBasCloadMOffs                  EQU     $00D3           2s complement of CLOADM offset
     AC73             (      romdefs.asm):00534         CBasCmdMode                     EQU     $AC73           Return to command mode
     0029             (      romdefs.asm):00535         CBasContLine                    EQU     $0029           Line no used by CONT
     0068             (      romdefs.asm):00536         CBasCurrentLine                 EQU     $0068           Current line no $FFFF in direct mode
     0001             (      romdefs.asm):00537         CBasDelim1                      EQU     $0001           First string delimiter
     0002             (      romdefs.asm):00538         CBasDelim2                      EQU     $0002           Second string delimiter
     002F             (      romdefs.asm):00539         CBasDirectTextPtr               EQU     $002F           Direct mode text pointer
     0008             (      romdefs.asm):00540         CBasDisArraySearch              EQU     $0008           Disable array search flag, 0=allow 0<>disable
     A61F             (      romdefs.asm):00541         CBasDNError                     EQU     $A61F           Print ?DN Error and return to basic
     ADD4             (      romdefs.asm):00542         CBasDoDispatch                  EQU     $ADD4           Do command dispatech, X must point to dispatch table
     00D7             (      romdefs.asm):00543         CBasEditorLineLen               EQU     $00D7           Editor line length
     ABAF             (      romdefs.asm):00544         CBasErrorCodeTable              EQU     $ABAF           List of 2 byte error codes eg 'SN' 'OM' 'UL' etc
     009D             (      romdefs.asm):00545         CBasExecAddr                    EQU     $009D           Exec address, on D64, at startup points to routine to boot all ram mode
     B44A             (      romdefs.asm):00546         CBasFCError                     EQU     $B44A           Print ?FC Error and return to basic
     AD01             (      romdefs.asm):00547         CBasFindLineNo                  EQU     $AD01           Find a line number in basic program
     A616             (      romdefs.asm):00548         CBasFMError                     EQU     $A616           Print ?FM Error and return to basic
     0007             (      romdefs.asm):00549         CBasGarbageFlag                 EQU     $0007           Garbage collection flag
     0003             (      romdefs.asm):00550         CBasGenCount                    EQU     $0003           General count/scratch var
     A5A2             (      romdefs.asm):00551         CBasGetDevNo                    EQU     $A5A2           Get dev no from line & validate
     AF67             (      romdefs.asm):00552         CBasGetLineNo                   EQU     $AF67           Get line no and store in BasTempLine
     B6A4             (      romdefs.asm):00553         CBasGetStrFirst                 EQU     $B6A4           Get first character of string into B
     B654             (      romdefs.asm):00554         CBasGetStrLenAddr               EQU     $B654           Get string len in B and address in X of string desc in FPA2
     A755             (      romdefs.asm):00555         CBasicCassBitIn                 EQU     $A755           Cassette bit input
     A749             (      romdefs.asm):00556         CBasicCassByIn                  EQU     $A749           Cassette byte input
     A82A             (      romdefs.asm):00557         CBasicCassByOut                 EQU     $A82A           Cassette byte output
     A7EB             (      romdefs.asm):00558         CBasicCassOff                   EQU     $A7EB           Cassette player motor off
     A7CA             (      romdefs.asm):00559         CBasicCassOn                    EQU     $A7CA           Cassette player motor on
     A77C             (      romdefs.asm):00560         CBasicCassOnRd                  EQU     $A77C           Cassette on for reading
     A199             (      romdefs.asm):00561         CBasicCursorB                   EQU     $A199           Cursor blink
     0000             (      romdefs.asm):00562         CBasicHWInit                    EQU     $0000           Hardware initialisation
     A9DE             (      romdefs.asm):00563         CBasicJoyIn                     EQU     $A9DE           Joystick input
     A1C1             (      romdefs.asm):00564         CBasicKbdIn                     EQU     $A1C1           Keyboard input
     A2BF             (      romdefs.asm):00565         CBasicPrintOut                  EQU     $A2BF           Printer output
     A30A             (      romdefs.asm):00566         CBasicScreenOut                 EQU     $A30A           Screen output
     0000             (      romdefs.asm):00567         CBasicSerIn                     EQU     $0000           Read a byte from serial
     0000             (      romdefs.asm):00568         CBasicSerOut                    EQU     $0000           Write a byte to serial port
     0000             (      romdefs.asm):00569         CBasicSetBaud                   EQU     $0000           Set baud rate
     0000             (      romdefs.asm):00570         CBasicSWInit                    EQU     $0000           Software initialisation
     A7D8             (      romdefs.asm):00571         CBasicWriteLead                 EQU     $A7D8           Cassette write leader
     886C             (      romdefs.asm):00572         CBasIDError                     EQU     $886C           Print ?ID Error and return to basic
     0004             (      romdefs.asm):00573         CBasIfCount                     EQU     $0004           If count - how many in a line
     A39D             (      romdefs.asm):00574         CBasInBuffFromX                 EQU     $A39D           Read input buffer at X as basic input
     0009             (      romdefs.asm):00575         CBasInputFlag                   EQU     $0009           Iinput/read flag, 0=input 0<>read
     A619             (      romdefs.asm):00576         CBasIOError                     EQU     $A619           Print ?IO Error and return to basic
     A9B3             (      romdefs.asm):00577         CBasIRQVec                      EQU     $A9B3           Basic IRQ routine, increments timer
     015A             (      romdefs.asm):00578         CBasJoyVal0                     EQU     $015A           Joystick(0) value
     015B             (      romdefs.asm):00579         CBasJoyVal1                     EQU     $015B           Joystick(1) value
     015C             (      romdefs.asm):00580         CBasJoyVal2                     EQU     $015C           Joystick(2) value
     015D             (      romdefs.asm):00581         CBasJoyVal3                     EQU     $015D           Joystick(3) value
     89E8             (      romdefs.asm):00582         CBasLineInputEntry              EQU     $89E8           Entry into LINE INPUT routine, used by DOS
     02DC             (      romdefs.asm):00583         CBasLinInpBuff                  EQU     $02DC           Basic line input buffer
     02DA             (      romdefs.asm):00584         CBasLinInpHead                  EQU     $02DA           Basic line input buffer header
     B764             (      romdefs.asm):00585         CBasList                        EQU     $B764           List basic program to SysDevN A must be 0 on entry
     0066             (      romdefs.asm):00586         CBasListLine                    EQU     $0066           Current line during list
     96EC             (      romdefs.asm):00587         CBasLocateScreen                EQU     $96EC           Initialise beginning of basic after graphics screen, no of pages in A
     B625             (      romdefs.asm):00588         CBasLSError                     EQU     $B625           Print ?LS Error and return to basic
     8CDD             (      romdefs.asm):00589         CBasNEError                     EQU     $8CDD           Print ?NE Error and return to basic
     AD19             (      romdefs.asm):00590         CBasNew                         EQU     $AD19           Remove current basic program from meory, like NEW command
     A3FB             (      romdefs.asm):00591         CBasNOError                     EQU     $A3FB           Print ?NO Error and return to basic
     0120             (      romdefs.asm):00592         CBasNumCmds                     EQU     $0120           Number of basic commands
     012A             (      romdefs.asm):00593         CBasNumDskCmds                  EQU     $012A           Number of disk basic commands
     012F             (      romdefs.asm):00594         CBasNumDskFuncs                 EQU     $012F           Number of disk basic functions
     0125             (      romdefs.asm):00595         CBasNumFuncs                    EQU     $0125           Number of basic functions
     002D             (      romdefs.asm):00596         CBasOldInputPtr                 EQU     $002D           Pointer to saved input during a STOP
     AC44             (      romdefs.asm):00597         CBasOMError                     EQU     $AC44           Print ?OM Error and return to basic
     BA92             (      romdefs.asm):00598         CBasOVError                     EQU     $BA92           Print ?OV Error and return to basic
     ADEB             (      romdefs.asm):00599         CBasPollKeyboard                EQU     $ADEB           Basic, poll keyboard and check for break
     BF3B             (      romdefs.asm):00600         CBasRandom8                     EQU     $BF3B           Generate an 8 bit random number and place in BasRandomSeed+1
     0115             (      romdefs.asm):00601         CBasRandomSeed                  EQU     $0115           Random number seed for RND function
     000A             (      romdefs.asm):00602         CBasRelateFlag                  EQU     $000A           Relational operator flag
     00D1             (      romdefs.asm):00603         CBasRenumStart                  EQU     $00D1           Renum start line no
     00D5             (      romdefs.asm):00604         CBasRenumStartLine              EQU     $00D5           Renum start line number
     00CF             (      romdefs.asm):00605         CBasRenumVal                    EQU     $00CF           Renum increment value
     AD33             (      romdefs.asm):00606         CBasResetStack                  EQU     $AD33           Reset basic stack to initial position
     B50F             (      romdefs.asm):00607         CBasResStr                      EQU     $B50F           Reserve B bytes of string space return start in X, setup low mem vars
     B56D             (      romdefs.asm):00608         CBasResStr2                     EQU     $B56D           Reserve B bytes of string space return start in X
     00AB             (      romdefs.asm):00609         CBasRndData                     EQU     $00AB           Used by RND
     AD9E             (      romdefs.asm):00610         CBasRun                         EQU     $AD9E           Run basic program in memory, like RUN
     AEBB             (      romdefs.asm):00611         CBasSetProgPtrX                 EQU     $AEBB           Sets basic program pointer to X-1
     80E7             (      romdefs.asm):00612         CBasSignonMess                  EQU     $80E7           Signon message address, for CoCo this is for Extended basic.
     AEB4             (      romdefs.asm):00613         CBasSkipLineNo                  EQU     $AEB4           Skip past line no in basic line, UL error if no line no.
     B277             (      romdefs.asm):00614         CBasSNError                     EQU     $B277           Print ?SN Error and return to basic
     0019             (      romdefs.asm):00615         CBasStartProg                   EQU     $0019           Start addr of basic program
     B553             (      romdefs.asm):00616         CBasSTError                     EQU     $B553           Print ?OM Error and return to basic
     01A9             (      romdefs.asm):00617         CBasStrDescStack                EQU     $01A9           String descriptor stack
     000B             (      romdefs.asm):00618         CBasStrFirstFreeTemp            EQU     $000B           First free temory string space pointer
     000D             (      romdefs.asm):00619         CBasStrLastUsedTemp             EQU     $000D           Last used tempory string space pointer
     0025             (      romdefs.asm):00620         CBasStrUtil                     EQU     $0025           Utility string pointer
     0120             (      romdefs.asm):00621         CBasStub0                       EQU     $0120           Basic Stub 0 (All basic on Dragon, Colour basic on Tandy)
     012A             (      romdefs.asm):00622         CBasStub1                       EQU     $012A           Basic stub 1 (Disk basic on Dragon, Extended basic on Tandy)
     0134             (      romdefs.asm):00623         CBasStub2                       EQU     $0134           Basic Stub 2 (Null on dragon, Disk basic on Tandy)
     013E             (      romdefs.asm):00624         CBasStub3                       EQU     $013E           Basic Stub 3 (do not use on dragon, user stub on Tandy)
     0013             (      romdefs.asm):00625         CBasTempFPA2                    EQU     $0013           Tempory FPA Mantissa for FPA2
     002B             (      romdefs.asm):00626         CBasTempLine                    EQU     $002B           Tempory line no
     000F             (      romdefs.asm):00627         CBasTempPtr                     EQU     $000F           Tempory pointer
     0011             (      romdefs.asm):00628         CBasTempPtr1                    EQU     $0011           Tempory discriptor pointer (stack search)
     003F             (      romdefs.asm):00629         CBasTempRelateFlag              EQU     $003F           Tempory relational operator flag
     003B             (      romdefs.asm):00630         CBasTempVarDesc                 EQU     $003B           Pointer to a tempory var descriptor
     B151             (      romdefs.asm):00631         CBasTMError                     EQU     $B151           Print ?TM Error and return to basic
     00AF             (      romdefs.asm):00632         CBasTronFlag                    EQU     $00AF           Tron flag nonzero=trace on
     AED2             (      romdefs.asm):00633         CBasULError                     EQU     $AED2           Print ?UL Error and return to basic
     0076             (      romdefs.asm):00634         CBasUnused1                     EQU     $0076           2 unused bytes
     00B0             (      romdefs.asm):00635         CBasUSRTableAddr                EQU     $00B0           Address of USR address table
     013E             (      romdefs.asm):00636         CBasUsrVecNoDisk                EQU     $013E           USR vector tabl when basic not installed
     001D             (      romdefs.asm):00637         CBasVarArrayAddr                EQU     $001D           Start address of Array table
     0052             (      romdefs.asm):00638         CBasVarAssign16                 EQU     $0052           Part of FPA1, used for 16bit assigns
     0033             (      romdefs.asm):00639         CBasVarDataAddr                 EQU     $0033           Address of next item in data
     0031             (      romdefs.asm):00640         CBasVarDataLine                 EQU     $0031           Line number of current data statement
     001F             (      romdefs.asm):00641         CBasVarEnd                      EQU     $001F           End of storage in use by basic
     004F             (      romdefs.asm):00642         CBasVarFPAcc1                   EQU     $004F           Floating point acumulator 1
     005C             (      romdefs.asm):00643         CBasVarFPAcc2                   EQU     $005C           Floating point acumulator 2
     0040             (      romdefs.asm):00644         CBasVarFPAcc3                   EQU     $0040           Floating point accumulator 3 (packed)
     0045             (      romdefs.asm):00645         CBasVarFPAcc4                   EQU     $0045           Floating point accumulator 4 (packed)
     004A             (      romdefs.asm):00646         CBasVarFPAcc5                   EQU     $004A           Floating point accumulator 5 (packed)
     0037             (      romdefs.asm):00647         CBasVarLastInUse                EQU     $0037           Pointer to variable last in use
     0039             (      romdefs.asm):00648         CBasVarPtrLast                  EQU     $0039           Poiinter to VARPTR last in use
     001B             (      romdefs.asm):00649         CBasVarSimpleAddr               EQU     $001B           Start address of simple variables
     0021             (      romdefs.asm):00650         CBasVarStringBase               EQU     $0021           Base address of string space (and stack)
     0023             (      romdefs.asm):00651         CBasVarStrTop                   EQU     $0023           Top of string space in use
     0006             (      romdefs.asm):00652         CBasVarType                     EQU     $0006           Variable type flag 0=numeric, $ff=string
     AD21             (      romdefs.asm):00653         CBasVect1                       EQU     $AD21           Sets up various basic vectors (after load), should be followed by call to BasVect2
     AD26             (      romdefs.asm):00654         CBasVect1a                      EQU     $AD26           Same as Vect1, but doesn't reset input pointer
     ACEF             (      romdefs.asm):00655         CBasVect2                       EQU     $ACEF           Finalises setup of basic vectors (after load), should be preceeded by call to BasVect1
     BC06             (      romdefs.asm):00656         CBasZDError                     EQU     $BC06           Print ?ZD Error and return to basic
     01E3             (      romdefs.asm):00657         CCasASCIIFlag                   EQU     $01E3           ASCII flag byte
     A974             (      romdefs.asm):00658         CCasAudioOff                    EQU     $A974           Turn off audio from cassette
     A99D             (      romdefs.asm):00659         CCasAudioOn                     EQU     $A99D           Turn on Audio from cassete to speaker
     0083             (      romdefs.asm):00660         CCasBitCount                    EQU     $0083           Cassette bit counter
     A755             (      romdefs.asm):00661         CCasBitIn                       EQU     $A755           Reads a bity into the 'Z' flag
     A70B             (      romdefs.asm):00662         CCasBlockIn                     EQU     $A70B           Reads a block into the cassete buffer pointed to by CasIOBuffAddr
     007D             (      romdefs.asm):00663         CCasBlockLen                    EQU     $007D           Cassete block length, number of bytes read, or to be written
     A7F4             (      romdefs.asm):00664         CCasBlockOut                    EQU     $A7F4           Write a block to cassete pointed to by CasIOBuffAddr
     007C             (      romdefs.asm):00665         CCasBlockType                   EQU     $007C           Cassete block type, 0=filename, 1=data, 255=EOF
     A749             (      romdefs.asm):00666         CCasByteIn                      EQU     $A749           Reads a single byte into the A register
     A82A             (      romdefs.asm):00667         CCasByteOut                     EQU     $A82A           Write byte in A register to cassete
     0080             (      romdefs.asm):00668         CCasCkSum                       EQU     $0080           Used by cassette routines for calculating checksum
     A429             (      romdefs.asm):00669         CCasClosFiles                   EQU     $A429           Close any open cassete file
     01E5             (      romdefs.asm):00670         CCasEntryAddr                   EQU     $01E5           Entry address for MC programs
     0070             (      romdefs.asm):00671         CCasEOFFlag                     EQU     $0070           Cassette IO Flag, nonzero if EOF reached
     A681             (      romdefs.asm):00672         CCasFindFile                    EQU     $A681           Searches a tape for specified filename
     01D2             (      romdefs.asm):00673         CCasFName                       EQU     $01D2           Cassete filename to search for or write out
     01DA             (      romdefs.asm):00674         CCasFNameFound                  EQU     $01DA           Filename found, when reading
     01D1             (      romdefs.asm):00675         CCasFNameLen                    EQU     $01D1           Length of cassette filename can be 0 to 8
     01E2             (      romdefs.asm):00676         CCasFType                       EQU     $01E2           File type 0=tokenized basic, 1=ASCII data, 2=Binary
     01E4             (      romdefs.asm):00677         CCasGapFlag                     EQU     $01E4           Gap flag byte
     007A             (      romdefs.asm):00678         CCasHeadBuffAddr                EQU     $007A           Address of cassette file header
     01DA             (      romdefs.asm):00679         CCasIOBuff                      EQU     $01DA           COS default IO buffer, if this contains filename block then folloing are valid
     007E             (      romdefs.asm):00680         CCasIOBuffAddr                  EQU     $007E           Cassette IO buffer address, where data will be read/written
     0079             (      romdefs.asm):00681         CCasIOBuffSize                  EQU     $0079           Size of cassette IO buffer
     0081             (      romdefs.asm):00682         CCasIOErrorCode                 EQU     $0081           Cassette IO error code 0=no error, 1=CRC, 2=attempt to load in non-ram area
     006E             (      romdefs.asm):00683         CCasIOFlag                      EQU     $006E           Cassette IO Flag, set to $FF when IO in progress
     0085             (      romdefs.asm):00684         CCasLastSine                    EQU     $0085           Casette last sine tabe entry
     0092             (      romdefs.asm):00685         CCasLeadCount                   EQU     $0092           Cassete leader count, number of $55 bytes in the leader
     01E7             (      romdefs.asm):00686         CCasLoadAddr                    EQU     $01E7           Load address
     0091             (      romdefs.asm):00687         CCasMax12                       EQU     $0091           Cassette Upper limit of 1200Hz
     0092             (      romdefs.asm):00688         CCasMax24                       EQU     $0092           Cassette Upper limit of 2400Hz
     008A             (      romdefs.asm):00689         CCasMotorDelay                  EQU     $008A           Cassette motor on delay (also inter-block gap)
     A7EB             (      romdefs.asm):00690         CCasMotorOff                    EQU     $A7EB           Turn off cassette motor
     A7CA             (      romdefs.asm):00691         CCasMotorOn                     EQU     $A7CA           Turn on motor, and wait for delay in CasMotorDelay
     008F             (      romdefs.asm):00692         CCasPartrt                      EQU     $008F           Cassette 1200/2400 partition
     0084             (      romdefs.asm):00693         CCasPhaseFlag                   EQU     $0084           Cassette Phase flag
     A511             (      romdefs.asm):00694         CCasReadBin                     EQU     $A511           Read in a binary file, similar to CLOADM
     A701             (      romdefs.asm):00695         CCasReadBlock1                  EQU     $A701           Turns on motor, reads header and then first block into CasIOBufAddr
     A77C             (      romdefs.asm):00696         CCasReadLeader                  EQU     $A77C           Turn on motor and read past leader
     0078             (      romdefs.asm):00697         CCasStatus                      EQU     $0078           Cassette status byte, 0=cassette closed, 1=open for input, 2=open for output
     0082             (      romdefs.asm):00698         CCasTemp                        EQU     $0082           Cassette tempory storage
     A469             (      romdefs.asm):00699         CCasWriteBasic                  EQU     $A469           Write tokenized basic program out, similar to CSAVE
     833D             (      romdefs.asm):00700         CCasWriteBin                    EQU     $833D           Write a binary file out push return address, then start,end and entry addresses and then JMP to this
     A7E5             (      romdefs.asm):00701         CCasWriteBlock1                 EQU     $A7E5           Turn on motor, write leader and then first block
     A7D8             (      romdefs.asm):00702         CCasWriteLeader                 EQU     $A7D8           Turn on motor and write out leader
     BC93             (      romdefs.asm):00703         CCmdABS                         EQU     $BC93           Basic Command
     B2D5             (      romdefs.asm):00704         CCmdAND                         EQU     $B2D5           Basic Command
     B6A0             (      romdefs.asm):00705         CCmdASC                         EQU     $B6A0           Basic Command
     83B0             (      romdefs.asm):00706         CCmdATN                         EQU     $83B0           Basic Command
     A990             (      romdefs.asm):00707         CCmdAudio                       EQU     $A990           Basic Command
     B68C             (      romdefs.asm):00708         CCmdCHRS                        EQU     $B68C           Basic Command
     9E9D             (      romdefs.asm):00709         CCmdCircle                      EQU     $9E9D           Basic Command
     AE41             (      romdefs.asm):00710         CCmdClear                       EQU     $AE41           Basic Command
     A498             (      romdefs.asm):00711         CCmdCload                       EQU     $A498           Basic Command
     A416             (      romdefs.asm):00712         CCmdClose                       EQU     $A416           Basic Command
     A910             (      romdefs.asm):00713         CCmdCLS                         EQU     $A910           Basic Command
     9546             (      romdefs.asm):00714         CCmdColor                       EQU     $9546           Basic Command
     AE30             (      romdefs.asm):00715         CCmdCont                        EQU     $AE30           Basic Command
     8378             (      romdefs.asm):00716         CCmdCOS                         EQU     $8378           Basic Command
     A44C             (      romdefs.asm):00717         CCmdCsave                       EQU     $A44C           Basic Command
     AEE0             (      romdefs.asm):00718         CCmdData                        EQU     $AEE0           Basic Command
     8871             (      romdefs.asm):00719         CCmdDef                         EQU     $8871           Basic Command
     8970             (      romdefs.asm):00720         CCmdDelete                      EQU     $8970           Basic Command
     B34E             (      romdefs.asm):00721         CCmdDim                         EQU     $B34E           Basic Command
     BB91             (      romdefs.asm):00722         CCmdDivide                      EQU     $BB91           Basic Command
     8C18             (      romdefs.asm):00723         CCmdDload                       EQU     $8C18           Basic Command
     9CB6             (      romdefs.asm):00724         CCmdDraw                        EQU     $9CB6           Basic Command
     8533             (      romdefs.asm):00725         CCmdEdit                        EQU     $8533           Basic Command
     AE02             (      romdefs.asm):00726         CCmdEnd                         EQU     $AE02           Basic Command
     A5CE             (      romdefs.asm):00727         CCmdEOF                         EQU     $A5CE           Basic Command
     A53E             (      romdefs.asm):00728         CCmdExec                        EQU     $A53E           Basic Command
     84F2             (      romdefs.asm):00729         CCmdEXP                         EQU     $84F2           Basic Command
     011D             (      romdefs.asm):00730         CCmdExponet                     EQU     $011D           Basic Command
     8524             (      romdefs.asm):00731         CCmdFIX                         EQU     $8524           Basic Command
     AD47             (      romdefs.asm):00732         CCmdFor                         EQU     $AD47           Basic Command
     9755             (      romdefs.asm):00733         CCmdGet                         EQU     $9755           Basic Command
     AE86             (      romdefs.asm):00734         CCmdGo                          EQU     $AE86           Basic Command
     8BDD             (      romdefs.asm):00735         CCmdHexS                        EQU     $8BDD           Basic Command
     AF14             (      romdefs.asm):00736         CCmdIF                          EQU     $AF14           Basic Command
     A564             (      romdefs.asm):00737         CCmdInkeyS                      EQU     $A564           Basic Command
     AFF5             (      romdefs.asm):00738         CCmdInput                       EQU     $AFF5           Basic Command
     877E             (      romdefs.asm):00739         CCmdInstr                       EQU     $877E           Basic Command
     BCEE             (      romdefs.asm):00740         CCmdINT                         EQU     $BCEE           Basic Command
     A9C6             (      romdefs.asm):00741         CCmdJoystk                      EQU     $A9C6           Basic Command
     B6AB             (      romdefs.asm):00742         CCmdLeftS                       EQU     $B6AB           Basic Command
     B681             (      romdefs.asm):00743         CCmdLEN                         EQU     $B681           Basic Command
     AF89             (      romdefs.asm):00744         CCmdLet                         EQU     $AF89           Basic Command
     93BB             (      romdefs.asm):00745         CCmdLine                        EQU     $93BB           Basic Command
     89C0             (      romdefs.asm):00746         CCmdLineInput                   EQU     $89C0           Line input command
     B764             (      romdefs.asm):00747         CCmdList                        EQU     $B764           Basic Command
     B75E             (      romdefs.asm):00748         CCmdLList                       EQU     $B75E           Basic Command
     8446             (      romdefs.asm):00749         CCmdLOG                         EQU     $8446           Basic Command
     B4EE             (      romdefs.asm):00750         CCmdMEM                         EQU     $B4EE           Basic Command
     B6CF             (      romdefs.asm):00751         CCmdMidS                        EQU     $B6CF           Basic Command
     B9BC             (      romdefs.asm):00752         CCmdMinus                       EQU     $B9BC           Basic Command
     A7BD             (      romdefs.asm):00753         CCmdMotor                       EQU     $A7BD           Basic Command
     BACC             (      romdefs.asm):00754         CCmdMultiply                    EQU     $BACC           Basic Command
     AD17             (      romdefs.asm):00755         CCmdNew                         EQU     $AD17           Basic Command
     B0F8             (      romdefs.asm):00756         CCmdNext                        EQU     $B0F8           Basic Command
     AF42             (      romdefs.asm):00757         CCmdON                          EQU     $AF42           Basic Command
     A5F6             (      romdefs.asm):00758         CCmdOpen                        EQU     $A5F6           Basic Command
     A603             (      romdefs.asm):00759         CCmdOpenEntry                   EQU     $A603           Entry into Basic open command used by Dragon/SuperDos
     B2D4             (      romdefs.asm):00760         CCmdOR                          EQU     $B2D4           Basic Command
     98EC             (      romdefs.asm):00761         CCmdPaint                       EQU     $98EC           Basic Command
     968B             (      romdefs.asm):00762         CCmdPClear                      EQU     $968B           Basic Command
     9532             (      romdefs.asm):00763         CCmdPCls                        EQU     $9532           Basic Command
     9723             (      romdefs.asm):00764         CCmdPcopy                       EQU     $9723           Basic Command
     B750             (      romdefs.asm):00765         CCmdPeek                        EQU     $B750           Basic Command
     9A22             (      romdefs.asm):00766         CCmdPlay                        EQU     $9A22           Basic Command
     B9C5             (      romdefs.asm):00767         CCmdPlus                        EQU     $B9C5           Basic Command
     9621             (      romdefs.asm):00768         CCmdPmode                       EQU     $9621           Basic Command
     A8F5             (      romdefs.asm):00769         CCmdPoint                       EQU     $A8F5           Basic Command
     B757             (      romdefs.asm):00770         CCmdPoke                        EQU     $B757           Basic Command
     86AC             (      romdefs.asm):00771         CCmdPOS                         EQU     $86AC           Basic Command
     9339             (      romdefs.asm):00772         CCmdPPoint                      EQU     $9339           Basic Command
     9365             (      romdefs.asm):00773         CCmdPReset                      EQU     $9365           Basic Command
     B8F7             (      romdefs.asm):00774         CCmdPrint                       EQU     $B8F7           Basic Command
     9361             (      romdefs.asm):00775         CCmdPset                        EQU     $9361           Basic Command
     9758             (      romdefs.asm):00776         CCmdPut                         EQU     $9758           Basic Command
     B046             (      romdefs.asm):00777         CCmdRead                        EQU     $B046           Basic Command
     B049             (      romdefs.asm):00778         CCmdReadFromX                   EQU     $B049           As basic READ command but ptr in X supplied by caller
     AEE3             (      romdefs.asm):00779         CCmdREM                         EQU     $AEE3           Basic Command
     8A09             (      romdefs.asm):00780         CCmdRenum                       EQU     $8A09           Basic Command
     A8B1             (      romdefs.asm):00781         CCmdReset                       EQU     $A8B1           Basic Command
     ADE4             (      romdefs.asm):00782         CCmdRestore                     EQU     $ADE4           Basic Command
     AEC0             (      romdefs.asm):00783         CCmdReturn                      EQU     $AEC0           Basic Command
     B6C8             (      romdefs.asm):00784         CCmdRightS                      EQU     $B6C8           Basic Command
     BF1F             (      romdefs.asm):00785         CCmdRND                         EQU     $BF1F           Basic Command
     AE75             (      romdefs.asm):00786         CCmdRun                         EQU     $AE75           Basic Command
     9670             (      romdefs.asm):00787         CCmdScreen                      EQU     $9670           Basic Command
     A880             (      romdefs.asm):00788         CCmdSet                         EQU     $A880           Basic Command
     BC7A             (      romdefs.asm):00789         CCmdSGN                         EQU     $BC7A           Basic Command
     BF78             (      romdefs.asm):00790         CCmdSIN                         EQU     $BF78           Basic Command
     A5EC             (      romdefs.asm):00791         CCmdSkipf                       EQU     $A5EC           Basic Command
     A94B             (      romdefs.asm):00792         CCmdSound                       EQU     $A94B           Basic Command
     8480             (      romdefs.asm):00793         CCmdSQR                         EQU     $8480           Basic Command
     AE09             (      romdefs.asm):00794         CCmdStop                        EQU     $AE09           Basic Command
     874E             (      romdefs.asm):00795         CCmdStringS                     EQU     $874E           Basic Command
     B4FD             (      romdefs.asm):00796         CCmdSTRS                        EQU     $B4FD           Basic Command
     8381             (      romdefs.asm):00797         CCmdTAN                         EQU     $8381           Basic Command
     8968             (      romdefs.asm):00798         CCmdTimer                       EQU     $8968           Basic Command
     86A8             (      romdefs.asm):00799         CCmdTroff                       EQU     $86A8           Basic Command
     86A7             (      romdefs.asm):00800         CCmdTron                        EQU     $86A7           Basic Command
     0112             (      romdefs.asm):00801         CCmdUSR                         EQU     $0112           Basic Command
     B716             (      romdefs.asm):00802         CCmdVAL                         EQU     $B716           Basic Command
     86BE             (      romdefs.asm):00803         CCmdVarptr                      EQU     $86BE           Basic Command
     00B3             (      romdefs.asm):00804         CGrBackground                   EQU     $00B3           Current background colour
     00B9             (      romdefs.asm):00805         CGrBytesPerLine                 EQU     $00B9           Number of byts/lin in current mode
     A8D9             (      romdefs.asm):00806         CGrCalcPixelPos                 EQU     $A8D9           Calculates Lo-res pixel pos from data on stack
     00D0             (      romdefs.asm):00807         CGrCircleRadius                 EQU     $00D0           Circle radius
     00CB             (      romdefs.asm):00808         CGrCircleXCo                    EQU     $00CB           Circle command X
     00CD             (      romdefs.asm):00809         CGrCircleYCo                    EQU     $00CD           Circle command Y
     9539             (      romdefs.asm):00810         CGrClearGrScreen                EQU     $9539           Clears grapics screen to value in B
     00C1             (      romdefs.asm):00811         CGrColourSet                    EQU     $00C1           Colour set currently in use
     00B4             (      romdefs.asm):00812         CGrColourTemp                   EQU     $00B4           Tempory colour in use
     00B5             (      romdefs.asm):00813         CGrCurrColour                   EQU     $00B5           Byte value for current colour, to set all pixels in byte to that colour
     00B6             (      romdefs.asm):00814         CGrCurrPmode                    EQU     $00B6           Current PMODE number
     00BD             (      romdefs.asm):00815         CGrCurrX                        EQU     $00BD           Current X cursor pos
     00C7             (      romdefs.asm):00816         CGrCurrXCo                      EQU     $00C7           Current Cursor X
     00BF             (      romdefs.asm):00817         CGrCurrY                        EQU     $00BF           Current Y cursor pos
     00C9             (      romdefs.asm):00818         CGrCurrYCo                      EQU     $00C9           Current Cursor Y
     00DB             (      romdefs.asm):00819         CGrDirtyFlag                    EQU     $00DB           Flag to tell if graphics screen has changed
     00BA             (      romdefs.asm):00820         CGrDisplayStartAddr             EQU     $00BA           Address of first byte in current display
     9CB6             (      romdefs.asm):00821         CGrDraw                         EQU     $9CB6           Draw on pmode screen as in DRAW command
     00E8             (      romdefs.asm):00822         CGrDrawAngle                    EQU     $00E8           Current angle for DRAW command
     00E9             (      romdefs.asm):00823         CGrDrawScale                    EQU     $00E9           Current scale for DRAW command
     00B2             (      romdefs.asm):00824         CGrForeground                   EQU     $00B2           Current foreground colour
     00B7             (      romdefs.asm):00825         CGrLastDisplayAddr              EQU     $00B7           Address of last byte in current display
     00C3             (      romdefs.asm):00826         CGrPixelNoX                     EQU     $00C3           Current horizontal pixel no
     00C5             (      romdefs.asm):00827         CGrPixelNoY                     EQU     $00C5           Current vertical pixel number
     00C2             (      romdefs.asm):00828         CGrPlotFlag                     EQU     $00C2           Plot/Unplot flag, 0=reset, nonzero=set
     9695             (      romdefs.asm):00829         CGrReserveGrRam                 EQU     $9695           Reserves memory for graphics, no graphics pages in B
     A8B5             (      romdefs.asm):00830         CGrResetLRGPixel                EQU     $A8B5           ReSets lo res pixel
     9682             (      romdefs.asm):00831         CGrSelectColourSet              EQU     $9682           Selects colour set dependent on B
     95AA             (      romdefs.asm):00832         CGrSelectDisplay                EQU     $95AA           Sets Text or Graphics screen, if Z=1 then text
     9653             (      romdefs.asm):00833         CGrSelectPage                   EQU     $9653           On entry B contains Pmode page to be used
     9616             (      romdefs.asm):00834         CGrSelectVDGColSet              EQU     $9616           Select colour set from data in GrColourSet
     959A             (      romdefs.asm):00835         CGrSetColours                   EQU     $959A           Sets up colours in low memory
     A88D             (      romdefs.asm):00836         CGrSetLRGPixel                  EQU     $A88D           Sets lo res pixel
     0086             (      romdefs.asm):00837         CGrSetResetData                 EQU     $0086           Data for Lo-res set/reset
     95FB             (      romdefs.asm):00838         CGrSetVDGMode                   EQU     $95FB           Set VDG to mode in A register
     960F             (      romdefs.asm):00839         CGrSetVDGOffset                 EQU     $960F           Set VDG offset to page in A
     00BC             (      romdefs.asm):00840         CGrStartPages                   EQU     $00BC           Page number of Start of graphics pages
     A006             (      romdefs.asm):00841         CIndCasBlockIn                  EQU     $A006           Indirect Read cassette block
     A008             (      romdefs.asm):00842         CIndCasBlockOut                 EQU     $A008           Indirect Write cassete block
     A004             (      romdefs.asm):00843         CIndCasOnRead                   EQU     $A004           Indirect prepare cassette for read
     A00C             (      romdefs.asm):00844         CIndCasWriteLead                EQU     $A00C           Indirect Write cassette leader
     A002             (      romdefs.asm):00845         CIndCharOutput                  EQU     $A002           Indirect Character output
     A00A             (      romdefs.asm):00846         CIndJoystickIn                  EQU     $A00A           Indirect joystick in
     A000             (      romdefs.asm):00847         CIndKeyInput                    EQU     $A000           Indirect keyboard input jsr()
     0072             (      romdefs.asm):00848         CIndVecReset                    EQU     $0072           Secondary Reset vector address, must point to NOP
     008A             (      romdefs.asm):00849         CMisc16BitScratch               EQU     $008A           Misc 16 bit scratch register (always zero ??)
     92DD             (      romdefs.asm):00850         CPixMaskTable2Col               EQU     $92DD           Pixel mask table 2 colour mode
     92E5             (      romdefs.asm):00851         CPixMaskTable4Col               EQU     $92E5           Pixel mask table 4 colour mode
     0000             (      romdefs.asm):00852         CPrinterCRLF                    EQU     $0000           Moves printer head to next line.
     0000             (      romdefs.asm):00853         CPrinterDirOut                  EQU     $0000           Sends character in A register to printer (uncooked)
     A2BF             (      romdefs.asm):00854         CPrinterOut                     EQU     $A2BF           Sends character in A register to printer
     010F             (      romdefs.asm):00855         CSecVecFIRQ                     EQU     $010F           Secondary FIRQ vector JMP+ address
     010C             (      romdefs.asm):00856         CSecVecIRQ                      EQU     $010C           Secondary IRQ vector JMP+ address
     0109             (      romdefs.asm):00857         CSecVecNMI                      EQU     $0109           Secondary NMI vector JMP+ address
     0106             (      romdefs.asm):00858         CSecVecSWI                      EQU     $0106           Secondary NMI vector JMP+ address
     0103             (      romdefs.asm):00859         CSecVecSWI2                     EQU     $0103           Secondary SWI2 vector JMP+ address
     0100             (      romdefs.asm):00860         CSecVecSWI3                     EQU     $0100           Secondary SWI3 vector JMP+ address
     00E6             (      romdefs.asm):00861         CSerDLBaud                      EQU     $00E6           Baud rate for DLOAD, unknown for Dragon
     00E7             (      romdefs.asm):00862         CSerDLTimeout                   EQU     $00E7           Timeourt for DLOAD, unknown for Dragon
     A951             (      romdefs.asm):00863         CSndBeep                        EQU     $A951           Play a beep duration in B, frequency in SndPitch
     A974             (      romdefs.asm):00864         CSndDisable                     EQU     $A974           Disables D/A sound output
     00E5             (      romdefs.asm):00865         CSndDotNoteScale                EQU     $00E5           Dotted note scale factor for Play
     A99E             (      romdefs.asm):00866         CSndDTOAOn                      EQU     $A99E           Turn on audio to D/A converter
     A976             (      romdefs.asm):00867         CSndEnable                      EQU     $A976           Enables D/A sound output
     008D             (      romdefs.asm):00868         CSndLength                      EQU     $008D           Sound duration
     00E1             (      romdefs.asm):00869         CSndNoteLen                     EQU     $00E1           Note length for PLAY
     00DE             (      romdefs.asm):00870         CSndOctave                      EQU     $00DE           Sound octave value for PLAY
     008C             (      romdefs.asm):00871         CSndPitch                       EQU     $008C           Sound pitch value
     9AFF             (      romdefs.asm):00872         CSndPlayNote                    EQU     $9AFF           Plays a note from the A register (ASCII)
     00E2             (      romdefs.asm):00873         CSndTempo                       EQU     $00E2           Tempo for PLAY
     00E3             (      romdefs.asm):00874         CSndTimerPlay                   EQU     $00E3           Timer for the Play command
     00DF             (      romdefs.asm):00875         CSndVolume                      EQU     $00DF           Sound volume for PLAY
     0000             (      romdefs.asm):00876         CSysBoot64                      EQU     $0000           Dragon 64 only, boots basic into all ram mode, with 48K available to basic.
     AC46             (      romdefs.asm):00877         CSysErr                         EQU     $AC46           Report error code in B register, cleanup and return to basic
     AC60             (      romdefs.asm):00878         CSysErr2                        EQU     $AC60           Report error in B, do NOT hook to RAM, or turn of cas etc
     A9DE             (      romdefs.asm):00879         CSysReadJoystick                EQU     $A9DE           Read hardware joystick values & update BasJoyVal0..3
     A027             (      romdefs.asm):00880         CSysReset                       EQU     $A027           Perform soft reset, as if reset button pressed
     A985             (      romdefs.asm):00881         CSysResetDA                     EQU     $A985           Reset D/A converter to $7E
     A9A2             (      romdefs.asm):00882         CSysSelJoystick                 EQU     $A9A2           Select joystick alue to read from A
     0112             (      romdefs.asm):00883         CSysTimeVal                     EQU     $0112           Current value of system timer
     A987             (      romdefs.asm):00884         CSysWriteDA                     EQU     $A987           Write value in A to D/A, bits 0 &1 should be 0
     011A             (      romdefs.asm):00885         CTextCapsLock                   EQU     $011A           Capslock flag, nonzero=uppercase
     A323             (      romdefs.asm):00886         CTextClearLine                  EQU     $A323           Clears a VDU line from current cursor pos to EOL
     A928             (      romdefs.asm):00887         CTextCls                        EQU     $A928           Clear text mode screen, resets cursor to top left
     A92A             (      romdefs.asm):00888         CTextClsChar                    EQU     $A92A           Clears srcrren to character in B register & resets cursor
     008F             (      romdefs.asm):00889         CTextCursFalshCnt               EQU     $008F           Cusrsor flash counter
     006F             (      romdefs.asm):00890         CTextDevN                       EQU     $006F           Current device number
     0035             (      romdefs.asm):00891         CTextKbdBuffAddr                EQU     $0035           Address of keyboard input buffer
     011B             (      romdefs.asm):00892         CTextKbdDelay                   EQU     $011B           Keyboard scan delay constant, used to debounce
     0152             (      romdefs.asm):00893         CTextKbdRollover                EQU     $0152           Rollover table, to check for key releases
     0087             (      romdefs.asm):00894         CTextLastKey                    EQU     $0087           ASCII code of last keypress, not cleard by key release
     A282             (      romdefs.asm):00895         CTextOutChar                    EQU     $A282           Outputs character in A to screen
     B958             (      romdefs.asm):00896         CTextOutCRLF                    EQU     $B958           Outputs an EOL sequence to the screen
     BDCC             (      romdefs.asm):00897         CTextOutNum16                   EQU     $BDCC           Outputs unsigned integer in D to the TextDevN device
     BDD4             (      romdefs.asm):00898         CTextOutNumFPA0                 EQU     $BDD4           Outputs number in FPA0 to screen
     B9AF             (      romdefs.asm):00899         CTextOutQuestion                EQU     $B9AF           Outputs a question mark to screen
     B9AC             (      romdefs.asm):00900         CTextOutSpace                   EQU     $B9AC           Outputs a space to screen
     B99C             (      romdefs.asm):00901         CTextOutString                  EQU     $B99C           Outputs string pointed to by X to screen, X should point to byte before first byte of string
     0148             (      romdefs.asm):00902         CTextPrnAutoCRLF                EQU     $0148           Printer auto EOL flag, nonzero will send EOL sequence at end of line
     0099             (      romdefs.asm):00903         CTextPrnCommaW                  EQU     $0099           Printer comma width
     009C             (      romdefs.asm):00904         CTextPrnCurrCol                 EQU     $009C           Printer current column
     014A             (      romdefs.asm):00905         CTextPrnEOLCnt                  EQU     $014A           Number of characters in EOL sequence 1..4
     014B             (      romdefs.asm):00906         CTextPrnEOLSeq                  EQU     $014B           End of line characters
     009A             (      romdefs.asm):00907         CTextPrnLastComma               EQU     $009A           Printer last comma width, should be printer line width - prinnter comma width
     009B             (      romdefs.asm):00908         CTextPrnLineW                   EQU     $009B           Printer line width
     03FF             (      romdefs.asm):00909         CTextPrnSelFlag                 EQU     $03FF           Dragon 64 printer selection flag, 0=paralell port, nonzero=RS232
     95AC             (      romdefs.asm):00910         CTextResetVDU                   EQU     $95AC           Resets to text mode and screen base address of $400
     A1C1             (      romdefs.asm):00911         CTextScanKbd                    EQU     $A1C1           Scan keyboard, return Char in A, Zero flag set if no key
     0095             (      romdefs.asm):00912         CTextSerBaudRate                EQU     $0095           Serial baud rate, note on Dragon 64, this is the actual hardware baud rate reg.
     0097             (      romdefs.asm):00913         CTextSerEOLDelay                EQU     $0097           End of line delay for serial port on Dragon 64 & CoCo
     A199             (      romdefs.asm):00914         CTextUpdateCurs                 EQU     $A199           Decrements TextCursFlashCnt, if zero resets and flashes cursor
     006A             (      romdefs.asm):00915         CTextVDUCommaW                  EQU     $006A           VDU comma width field
     006C             (      romdefs.asm):00916         CTextVDUCurrCol                 EQU     $006C           Current column for VDU output
     0088             (      romdefs.asm):00917         CTextVDUCursAddr                EQU     $0088           Current VDU cursor address
     006B             (      romdefs.asm):00918         CTextVDULastComma               EQU     $006B           VDU last comma field, should be VDU line width - VDU comma width
     006D             (      romdefs.asm):00919         CTextVDULineW                   EQU     $006D           VDU line width, normally 32
     A30A             (      romdefs.asm):00920         CTextVDUOut                     EQU     $A30A           Outputs Char in A to VDU, does not reset screen.
     ADFB             (      romdefs.asm):00921         CTextWaitKey                    EQU     $ADFB           Wait for a keypress, calls TextScanKbd, also handles break
     8CC6             (      romdefs.asm):00922         CTextWaitKeyCurs                EQU     $8CC6           Same as TextWaitKey, but with cursor
     A171             (      romdefs.asm):00923         CTextWaitKeyCurs2               EQU     $A171           Same as TextWaitKey, but with cursor
     A59A             (      romdefs.asm):00924         CUtilCopyBXtoU                  EQU     $A59A           Copy B bytes from X to U
     B4F2             (      romdefs.asm):00925         CVarAssign16Bit                 EQU     $B4F2           Assigns value in D register to a variable, and returns to basic
     B4F3             (      romdefs.asm):00926         CVarAssign16Bit2                EQU     $B4F3           Assigns value in D register to a variable, and returns to basic (1 less instruction!).
     880E             (      romdefs.asm):00927         CVarAssign16BitB                EQU     $880E           Assigns value in BasVarAssign16 to a variable, and returns to basic
     B4F3             (      romdefs.asm):00928         CVarAssign8Bit                  EQU     $B4F3           Assigns value in B register to a variable, and returns to basic
     B26F             (      romdefs.asm):00929         CVarCKChar                      EQU     $B26F           Check for char in B register in command line, SNError if not
     B267             (      romdefs.asm):00930         CVarCKClBrac                    EQU     $B267           Check for Close bracket ')' in command line, SNError if not
     B26D             (      romdefs.asm):00931         CVarCKComma                     EQU     $B26D           Check for Comma in command line, SNError if not
     B26A             (      romdefs.asm):00932         CVarCKOpBrac                    EQU     $B26A           Check for Open bracket '(' in command line, SNError if not
     B659             (      romdefs.asm):00933         CVarDelVar                      EQU     $B659           Frees up storage used by a variable
     B591             (      romdefs.asm):00934         CVarGarbageCollect              EQU     $B591           Forces garbage collection in string space
     B73D             (      romdefs.asm):00935         CVarGet16Bit                    EQU     $B73D           Returns value of variable in D,FCError if more than 16 bits
     B70B             (      romdefs.asm):00936         CVarGet8Bit                     EQU     $B70B           Returns value of variable in B,FCError if more than 8 bits
     B738             (      romdefs.asm):00937         CVarGetComma8                   EQU     $B738           Checks for comman then gets 8 bit.
     B146             (      romdefs.asm):00938         CVarGetExpr                     EQU     $B146           Evaluate and put the VARPTR of experssion which follows in BasVarAssign16 (carry set)
     B143             (      romdefs.asm):00939         CVarGetExprCC                   EQU     $B143           Evaluate and put the VARPTR of experssion which follows in BasVarAssign16 (carry clear)
     B156             (      romdefs.asm):00940         CVarGetStr                      EQU     $B156           Compiles string and moves to free string space, should be followed by VarGetExpr
     B3E9             (      romdefs.asm):00941         CVarGetUsr                      EQU     $B3E9           Returns argument to USRnn as a 16bit no in D
     B357             (      romdefs.asm):00942         CVarGetVar                      EQU     $B357           Gets VARPTR address of following name and places in BasVarPtrLast
     BA1C             (      romdefs.asm):00943         CVarNormFPA0                    EQU     $BA1C           Normalize FPA0
     01A0             (      romdefs.asm):00944         CVectAccessScreen               EQU     $01A0           Called before CLS, GET & PUT are executed
     019D             (      romdefs.asm):00945         CVectAssignStr                  EQU     $019D           Called before assigning string to string variable
     015E             (      romdefs.asm):00946         CVectBase                       EQU     $015E           Base address of ram hooks/vectors
     0188             (      romdefs.asm):00947         CVectCheckEOF                   EQU     $0188           called before checking for end of file
     017F             (      romdefs.asm):00948         CVectCheckKeys                  EQU     $017F           Called before keyboard is scanned for BREAK,SHIFT-@
     0173             (      romdefs.asm):00949         CVectCloseAllFiles              EQU     $0173           Called before closing all files
     0176             (      romdefs.asm):00950         CVectCloseFile                  EQU     $0176           Called before closing a file
     0185             (      romdefs.asm):00951         CVectCloseFileCmd               EQU     $0185           Called before closing an ASCII file read in as basic
     0179             (      romdefs.asm):00952         CVectCmdInterp                  EQU     $0179           Called before interpreting a token in A
     01A6             (      romdefs.asm):00953         CVectDeTokenize                 EQU     $01A6           Called before a line is de-tokenized
     0164             (      romdefs.asm):00954         CVectDevInit                    EQU     $0164           Called before initialising a device
     0161             (      romdefs.asm):00955         CVectDevNo                      EQU     $0161           Called when a device number is verified
     015E             (      romdefs.asm):00956         CVectDevOpen                    EQU     $015E           Called before a device is opened
     018B             (      romdefs.asm):00957         CVectEvaluateExpr               EQU     $018B           Called before evaluating expression
     019A             (      romdefs.asm):00958         CVectGetNextCmd                 EQU     $019A           Called before fetching next command to be executed by BASIC
     016A             (      romdefs.asm):00959         CVectInChar                     EQU     $016A           Called before inputting a char to A
     016D             (      romdefs.asm):00960         CVectInputFile                  EQU     $016D           Called before inputting from a file
     0182             (      romdefs.asm):00961         CVectLineInputFile              EQU     $0182           Called before LINE INPUT is executed
     0167             (      romdefs.asm):00962         CVectOutChar                    EQU     $0167           Called before outputting char in A to a device
     0170             (      romdefs.asm):00963         CVectOutputFile                 EQU     $0170           Called before outputting to a file
     017C             (      romdefs.asm):00964         CVectReReqestIn                 EQU     $017C           Called before re-requesing input from keyboard
     0197             (      romdefs.asm):00965         CVectResetBasMem                EQU     $0197           Called before changing BASIC memory vectors after LOAD etc
     0194             (      romdefs.asm):00966         CVectRunLink                    EQU     $0194           Called when RUN about to be executed
     0191             (      romdefs.asm):00967         CVectSysError                   EQU     $0191           Can be patched by system to trap error messages
     01A3             (      romdefs.asm):00968         CVectTokenize                   EQU     $01A3           Called before an ASCII line is tokenized
     018E             (      romdefs.asm):00969         CVectUserError                  EQU     $018E           Can be patched by user to trap error messages
     80C0             (      romdefs.asm):00970         CWarmStart                      EQU     $80C0           Warm start routine
     0071             (      romdefs.asm):00971         CWarmStartFlag                  EQU     $0071           Warm start flag $55=warm start, else cold start
                      (      romdefs.asm):00972         
                      (      romdefs.asm):00973                                 ifdef Dragon
                      (      romdefs.asm):00974         
0000                  (      romdefs.asm):00975         StubResWordsOfs         EQU     DStubResWordsOfs
0000                  (      romdefs.asm):00976         StubResLookupOfs                EQU     DStubResLookupOfs
0000                  (      romdefs.asm):00977         StubResJumpOfs                  EQU     DStubResJumpOfs
0000                  (      romdefs.asm):00978         StubFuncsOfs                    EQU     DStubFuncsOfs
0000                  (      romdefs.asm):00979         StubFuncsLookupOfs              EQU     DStubFuncsLookupOfs
0000                  (      romdefs.asm):00980         StubFuncsJumpOfs                EQU     DStubFuncsJumpOfs
0000                  (      romdefs.asm):00981         Skip1                           EQU     DSkip1
0000                  (      romdefs.asm):00982         Skip2                           EQU     DSkip2
0000                  (      romdefs.asm):00983         Skip1LD                         EQU     DSkip1LD
0000                  (      romdefs.asm):00984         Skip2TST                        EQU     DSkip2TST
0000                  (      romdefs.asm):00985         CoCoVec167                      EQU     DCoCoVec167
0000                  (      romdefs.asm):00986         CoCoVect16A                     EQU     DCoCoVect16A
0000                  (      romdefs.asm):00987         CoCoVect176                     EQU     DCoCoVect176
0000                  (      romdefs.asm):00988         CoCoVect179                     EQU     DCoCoVect179
0000                  (      romdefs.asm):00989         CoCoVect18B                     EQU     DCoCoVect18B
0000                  (      romdefs.asm):00990         CoCoVect191                     EQU     DCoCoVect191
0000                  (      romdefs.asm):00991         CoCoVect194                     EQU     DCoCoVect194
0000                  (      romdefs.asm):00992         CoCoVect197                     EQU     DCoCoVect197
0000                  (      romdefs.asm):00993         CoCoVect19A                     EQU     DCoCoVect19A
0000                  (      romdefs.asm):00994         CoCoVect1A3                     EQU     DCoCoVect1A3
0000                  (      romdefs.asm):00995         AddrFWareRamTop                 EQU     DAddrFWareRamTop
0000                  (      romdefs.asm):00996         AddrRamTop                      EQU     DAddrRamTop
0000                  (      romdefs.asm):00997         AddrStack                       EQU     DAddrStack
0000                  (      romdefs.asm):00998         BasAddrCmdDisp                  EQU     DBasAddrCmdDisp
0000                  (      romdefs.asm):00999         BasAddrCmdList                  EQU     DBasAddrCmdList
0000                  (      romdefs.asm):01000         BasAddrDskCmdDisp               EQU     DBasAddrDskCmdDisp
0000                  (      romdefs.asm):01001         BasAddrDskCmdList               EQU     DBasAddrDskCmdList
0000                  (      romdefs.asm):01002         BasAddrDskFuncDisp              EQU     DBasAddrDskFuncDisp
0000                  (      romdefs.asm):01003         BasAddrDskFuncList              EQU     DBasAddrDskFuncList
0000                  (      romdefs.asm):01004         BasAddrFuncDisp                 EQU     DBasAddrFuncDisp
0000                  (      romdefs.asm):01005         BasAddrFuncList                 EQU     DBasAddrFuncList
0000                  (      romdefs.asm):01006         BasAddrSigByte                  EQU     DBasAddrSigByte
0000                  (      romdefs.asm):01007         BasAOError                      EQU     DBasAOError
0000                  (      romdefs.asm):01008         BasArrayEval                    EQU     DBasArrayEval
0000                  (      romdefs.asm):01009         BasBootBasic                    EQU     DBasBootBasic
0000                  (      romdefs.asm):01010         BasBotStack                     EQU     DBasBotStack
0000                  (      romdefs.asm):01011         BasBRARun                       EQU     DBasBRARun
0000                  (      romdefs.asm):01012         BasBreakFlag                    EQU     DBasBreakFlag
0000                  (      romdefs.asm):01013         BasBuffer                       EQU     DBasBuffer
0000                  (      romdefs.asm):01014         BasChkArrSpaceMv                EQU     DBasChkArrSpaceMv
0000                  (      romdefs.asm):01015         BasChkB2Free                    EQU     DBasChkB2Free
0000                  (      romdefs.asm):01016         BasChkDirect                    EQU     DBasChkDirect
0000                  (      romdefs.asm):01017         BasChrGet                       EQU     DBasChrGet
0000                  (      romdefs.asm):01018         BasChrGetCurr                   EQU     DBasChrGetCurr
0000                  (      romdefs.asm):01019         BasCloadMOffs                   EQU     DBasCloadMOffs
0000                  (      romdefs.asm):01020         BasCmdMode                      EQU     DBasCmdMode
0000                  (      romdefs.asm):01021         BasContLine                     EQU     DBasContLine
0000                  (      romdefs.asm):01022         BasCurrentLine                  EQU     DBasCurrentLine
0000                  (      romdefs.asm):01023         BasDelim1                       EQU     DBasDelim1
0000                  (      romdefs.asm):01024         BasDelim2                       EQU     DBasDelim2
0000                  (      romdefs.asm):01025         BasDirectTextPtr                EQU     DBasDirectTextPtr
0000                  (      romdefs.asm):01026         BasDisArraySearch               EQU     DBasDisArraySearch
0000                  (      romdefs.asm):01027         BasDNError                      EQU     DBasDNError
0000                  (      romdefs.asm):01028         BasDoDispatch                   EQU     DBasDoDispatch
0000                  (      romdefs.asm):01029         BasEditorLineLen                EQU     DBasEditorLineLen
0000                  (      romdefs.asm):01030         BasErrorCodeTable               EQU     DBasErrorCodeTable
0000                  (      romdefs.asm):01031         BasExecAddr                     EQU     DBasExecAddr
0000                  (      romdefs.asm):01032         BasFCError                      EQU     DBasFCError
0000                  (      romdefs.asm):01033         BasFindLineNo                   EQU     DBasFindLineNo
0000                  (      romdefs.asm):01034         BasFMError                      EQU     DBasFMError
0000                  (      romdefs.asm):01035         BasGarbageFlag                  EQU     DBasGarbageFlag
0000                  (      romdefs.asm):01036         BasGenCount                     EQU     DBasGenCount
0000                  (      romdefs.asm):01037         BasGetDevNo                     EQU     DBasGetDevNo
0000                  (      romdefs.asm):01038         BasGetLineNo                    EQU     DBasGetLineNo
0000                  (      romdefs.asm):01039         BasGetStrFirst                  EQU     DBasGetStrFirst
0000                  (      romdefs.asm):01040         BasGetStrLenAddr                EQU     DBasGetStrLenAddr
0000                  (      romdefs.asm):01041         BasicCassBitIn                  EQU     DBasicCassBitIn
0000                  (      romdefs.asm):01042         BasicCassByIn                   EQU     DBasicCassByIn
0000                  (      romdefs.asm):01043         BasicCassByOut                  EQU     DBasicCassByOut
0000                  (      romdefs.asm):01044         BasicCassOff                    EQU     DBasicCassOff
0000                  (      romdefs.asm):01045         BasicCassOn                     EQU     DBasicCassOn
0000                  (      romdefs.asm):01046         BasicCassOnRd                   EQU     DBasicCassOnRd
0000                  (      romdefs.asm):01047         BasicCursorB                    EQU     DBasicCursorB
0000                  (      romdefs.asm):01048         BasicHWInit                     EQU     DBasicHWInit
0000                  (      romdefs.asm):01049         BasicJoyIn                      EQU     DBasicJoyIn
0000                  (      romdefs.asm):01050         BasicKbdIn                      EQU     DBasicKbdIn
0000                  (      romdefs.asm):01051         BasicPrintOut                   EQU     DBasicPrintOut
0000                  (      romdefs.asm):01052         BasicScreenOut                  EQU     DBasicScreenOut
0000                  (      romdefs.asm):01053         BasicSerIn                      EQU     DBasicSerIn
0000                  (      romdefs.asm):01054         BasicSerOut                     EQU     DBasicSerOut
0000                  (      romdefs.asm):01055         BasicSetBaud                    EQU     DBasicSetBaud
0000                  (      romdefs.asm):01056         BasicSWInit                     EQU     DBasicSWInit
0000                  (      romdefs.asm):01057         BasicWriteLead                  EQU     DBasicWriteLead
0000                  (      romdefs.asm):01058         BasIDError                      EQU     DBasIDError
0000                  (      romdefs.asm):01059         BasIfCount                      EQU     DBasIfCount
0000                  (      romdefs.asm):01060         BasInBuffFromX                  EQU     DBasInBuffFromX
0000                  (      romdefs.asm):01061         BasInputFlag                    EQU     DBasInputFlag
0000                  (      romdefs.asm):01062         BasIOError                      EQU     DBasIOError
0000                  (      romdefs.asm):01063         BasIRQVec                       EQU     DBasIRQVec
0000                  (      romdefs.asm):01064         BasJoyVal0                      EQU     DBasJoyVal0
0000                  (      romdefs.asm):01065         BasJoyVal1                      EQU     DBasJoyVal1
0000                  (      romdefs.asm):01066         BasJoyVal2                      EQU     DBasJoyVal2
0000                  (      romdefs.asm):01067         BasJoyVal3                      EQU     DBasJoyVal3
0000                  (      romdefs.asm):01068         BasLineInputEntry               EQU     DBasLineInputEntry
0000                  (      romdefs.asm):01069         BasLinInpBuff                   EQU     DBasLinInpBuff
0000                  (      romdefs.asm):01070         BasLinInpHead                   EQU     DBasLinInpHead
0000                  (      romdefs.asm):01071         BasList                         EQU     DBasList
0000                  (      romdefs.asm):01072         BasListLine                     EQU     DBasListLine
0000                  (      romdefs.asm):01073         BasLocateScreen                 EQU     DBasLocateScreen
0000                  (      romdefs.asm):01074         BasLSError                      EQU     DBasLSError
0000                  (      romdefs.asm):01075         BasNEError                      EQU     DBasNEError
0000                  (      romdefs.asm):01076         BasNew                          EQU     DBasNew
0000                  (      romdefs.asm):01077         BasNOError                      EQU     DBasNOError
0000                  (      romdefs.asm):01078         BasNumCmds                      EQU     DBasNumCmds
0000                  (      romdefs.asm):01079         BasNumDskCmds                   EQU     DBasNumDskCmds
0000                  (      romdefs.asm):01080         BasNumDskFuncs                  EQU     DBasNumDskFuncs
0000                  (      romdefs.asm):01081         BasNumFuncs                     EQU     DBasNumFuncs
0000                  (      romdefs.asm):01082         BasOldInputPtr                  EQU     DBasOldInputPtr
0000                  (      romdefs.asm):01083         BasOMError                      EQU     DBasOMError
0000                  (      romdefs.asm):01084         BasOVError                      EQU     DBasOVError
0000                  (      romdefs.asm):01085         BasPollKeyboard                 EQU     DBasPollKeyboard
0000                  (      romdefs.asm):01086         BasRandom8                      EQU     DBasRandom8
0000                  (      romdefs.asm):01087         BasRandomSeed                   EQU     DBasRandomSeed
0000                  (      romdefs.asm):01088         BasRelateFlag                   EQU     DBasRelateFlag
0000                  (      romdefs.asm):01089         BasRenumStart                   EQU     DBasRenumStart
0000                  (      romdefs.asm):01090         BasRenumStartLine               EQU     DBasRenumStartLine
0000                  (      romdefs.asm):01091         BasRenumVal                     EQU     DBasRenumVal
0000                  (      romdefs.asm):01092         BasResetStack                   EQU     DBasResetStack
0000                  (      romdefs.asm):01093         BasResStr                       EQU     DBasResStr
0000                  (      romdefs.asm):01094         BasResStr2                      EQU     DBasResStr2
0000                  (      romdefs.asm):01095         BasRndData                      EQU     DBasRndData
0000                  (      romdefs.asm):01096         BasRun                          EQU     DBasRun
0000                  (      romdefs.asm):01097         BasSetProgPtrX                  EQU     DBasSetProgPtrX
0000                  (      romdefs.asm):01098         BasSignonMess                   EQU     DBasSignonMess
0000                  (      romdefs.asm):01099         BasSkipLineNo                   EQU     DBasSkipLineNo
0000                  (      romdefs.asm):01100         BasSNError                      EQU     DBasSNError
0000                  (      romdefs.asm):01101         BasStartProg                    EQU     DBasStartProg
0000                  (      romdefs.asm):01102         BasSTError                      EQU     DBasSTError
0000                  (      romdefs.asm):01103         BasStrDescStack                 EQU     DBasStrDescStack
0000                  (      romdefs.asm):01104         BasStrFirstFreeTemp             EQU     DBasStrFirstFreeTemp
0000                  (      romdefs.asm):01105         BasStrLastUsedTemp              EQU     DBasStrLastUsedTemp
0000                  (      romdefs.asm):01106         BasStrUtil                      EQU     DBasStrUtil
0000                  (      romdefs.asm):01107         BasStub0                        EQU     DBasStub0
0000                  (      romdefs.asm):01108         BasStub1                        EQU     DBasStub1
0000                  (      romdefs.asm):01109         BasStub2                        EQU     DBasStub2
0000                  (      romdefs.asm):01110         BasStub3                        EQU     DBasStub3
0000                  (      romdefs.asm):01111         BasTempFPA2                     EQU     DBasTempFPA2
0000                  (      romdefs.asm):01112         BasTempLine                     EQU     DBasTempLine
0000                  (      romdefs.asm):01113         BasTempPtr                      EQU     DBasTempPtr
0000                  (      romdefs.asm):01114         BasTempPtr1                     EQU     DBasTempPtr1
0000                  (      romdefs.asm):01115         BasTempRelateFlag               EQU     DBasTempRelateFlag
0000                  (      romdefs.asm):01116         BasTempVarDesc                  EQU     DBasTempVarDesc
0000                  (      romdefs.asm):01117         BasTMError                      EQU     DBasTMError
0000                  (      romdefs.asm):01118         BasTronFlag                     EQU     DBasTronFlag
0000                  (      romdefs.asm):01119         BasULError                      EQU     DBasULError
0000                  (      romdefs.asm):01120         BasUnused1                      EQU     DBasUnused1
0000                  (      romdefs.asm):01121         BasUSRTableAddr                 EQU     DBasUSRTableAddr
0000                  (      romdefs.asm):01122         BasUsrVecNoDisk                 EQU     DBasUsrVecNoDisk
0000                  (      romdefs.asm):01123         BasVarArrayAddr                 EQU     DBasVarArrayAddr
0000                  (      romdefs.asm):01124         BasVarAssign16                  EQU     DBasVarAssign16
0000                  (      romdefs.asm):01125         BasVarDataAddr                  EQU     DBasVarDataAddr
0000                  (      romdefs.asm):01126         BasVarDataLine                  EQU     DBasVarDataLine
0000                  (      romdefs.asm):01127         BasVarEnd                       EQU     DBasVarEnd
0000                  (      romdefs.asm):01128         BasVarFPAcc1                    EQU     DBasVarFPAcc1
0000                  (      romdefs.asm):01129         BasVarFPAcc2                    EQU     DBasVarFPAcc2
0000                  (      romdefs.asm):01130         BasVarFPAcc3                    EQU     DBasVarFPAcc3
0000                  (      romdefs.asm):01131         BasVarFPAcc4                    EQU     DBasVarFPAcc4
0000                  (      romdefs.asm):01132         BasVarFPAcc5                    EQU     DBasVarFPAcc5
0000                  (      romdefs.asm):01133         BasVarLastInUse                 EQU     DBasVarLastInUse
0000                  (      romdefs.asm):01134         BasVarPtrLast                   EQU     DBasVarPtrLast
0000                  (      romdefs.asm):01135         BasVarSimpleAddr                EQU     DBasVarSimpleAddr
0000                  (      romdefs.asm):01136         BasVarStringBase                EQU     DBasVarStringBase
0000                  (      romdefs.asm):01137         BasVarStrTop                    EQU     DBasVarStrTop
0000                  (      romdefs.asm):01138         BasVarType                      EQU     DBasVarType
0000                  (      romdefs.asm):01139         BasVect1                        EQU     DBasVect1
0000                  (      romdefs.asm):01140         BasVect1a                       EQU     DBasVect1a
0000                  (      romdefs.asm):01141         BasVect2                        EQU     DBasVect2
0000                  (      romdefs.asm):01142         BasZDError                      EQU     DBasZDError
0000                  (      romdefs.asm):01143         CasASCIIFlag                    EQU     DCasASCIIFlag
0000                  (      romdefs.asm):01144         CasAudioOff                     EQU     DCasAudioOff
0000                  (      romdefs.asm):01145         CasAudioOn                      EQU     DCasAudioOn
0000                  (      romdefs.asm):01146         CasBitCount                     EQU     DCasBitCount
0000                  (      romdefs.asm):01147         CasBitIn                        EQU     DCasBitIn
0000                  (      romdefs.asm):01148         CasBlockIn                      EQU     DCasBlockIn
0000                  (      romdefs.asm):01149         CasBlockLen                     EQU     DCasBlockLen
0000                  (      romdefs.asm):01150         CasBlockOut                     EQU     DCasBlockOut
0000                  (      romdefs.asm):01151         CasBlockType                    EQU     DCasBlockType
0000                  (      romdefs.asm):01152         CasByteIn                       EQU     DCasByteIn
0000                  (      romdefs.asm):01153         CasByteOut                      EQU     DCasByteOut
0000                  (      romdefs.asm):01154         CasCkSum                        EQU     DCasCkSum
0000                  (      romdefs.asm):01155         CasClosFiles                    EQU     DCasClosFiles
0000                  (      romdefs.asm):01156         CasEntryAddr                    EQU     DCasEntryAddr
0000                  (      romdefs.asm):01157         CasEOFFlag                      EQU     DCasEOFFlag
0000                  (      romdefs.asm):01158         CasFindFile                     EQU     DCasFindFile
0000                  (      romdefs.asm):01159         CasFName                        EQU     DCasFName
0000                  (      romdefs.asm):01160         CasFNameFound                   EQU     DCasFNameFound
0000                  (      romdefs.asm):01161         CasFNameLen                     EQU     DCasFNameLen
0000                  (      romdefs.asm):01162         CasFType                        EQU     DCasFType
0000                  (      romdefs.asm):01163         CasGapFlag                      EQU     DCasGapFlag
0000                  (      romdefs.asm):01164         CasHeadBuffAddr                 EQU     DCasHeadBuffAddr
0000                  (      romdefs.asm):01165         CasIOBuff                       EQU     DCasIOBuff
0000                  (      romdefs.asm):01166         CasIOBuffAddr                   EQU     DCasIOBuffAddr
0000                  (      romdefs.asm):01167         CasIOBuffSize                   EQU     DCasIOBuffSize
0000                  (      romdefs.asm):01168         CasIOErrorCode                  EQU     DCasIOErrorCode
0000                  (      romdefs.asm):01169         CasIOFlag                       EQU     DCasIOFlag
0000                  (      romdefs.asm):01170         CasLastSine                     EQU     DCasLastSine
0000                  (      romdefs.asm):01171         CasLeadCount                    EQU     DCasLeadCount
0000                  (      romdefs.asm):01172         CasLoadAddr                     EQU     DCasLoadAddr
0000                  (      romdefs.asm):01173         CasMax12                        EQU     DCasMax12
0000                  (      romdefs.asm):01174         CasMax24                        EQU     DCasMax24
0000                  (      romdefs.asm):01175         CasMotorDelay                   EQU     DCasMotorDelay
0000                  (      romdefs.asm):01176         CasMotorOff                     EQU     DCasMotorOff
0000                  (      romdefs.asm):01177         CasMotorOn                      EQU     DCasMotorOn
0000                  (      romdefs.asm):01178         CasPartrt                       EQU     DCasPartrt
0000                  (      romdefs.asm):01179         CasPhaseFlag                    EQU     DCasPhaseFlag
0000                  (      romdefs.asm):01180         CasReadBin                      EQU     DCasReadBin
0000                  (      romdefs.asm):01181         CasReadBlock1                   EQU     DCasReadBlock1
0000                  (      romdefs.asm):01182         CasReadLeader                   EQU     DCasReadLeader
0000                  (      romdefs.asm):01183         CasStatus                       EQU     DCasStatus
0000                  (      romdefs.asm):01184         CasTemp                         EQU     DCasTemp
0000                  (      romdefs.asm):01185         CasWriteBasic                   EQU     DCasWriteBasic
0000                  (      romdefs.asm):01186         CasWriteBin                     EQU     DCasWriteBin
0000                  (      romdefs.asm):01187         CasWriteBlock1                  EQU     DCasWriteBlock1
0000                  (      romdefs.asm):01188         CasWriteLeader                  EQU     DCasWriteLeader
0000                  (      romdefs.asm):01189         CmdABS                          EQU     DCmdABS
0000                  (      romdefs.asm):01190         CmdAND                          EQU     DCmdAND
0000                  (      romdefs.asm):01191         CmdASC                          EQU     DCmdASC
0000                  (      romdefs.asm):01192         CmdATN                          EQU     DCmdATN
0000                  (      romdefs.asm):01193         CmdAudio                        EQU     DCmdAudio
0000                  (      romdefs.asm):01194         CmdCHRS                         EQU     DCmdCHRS
0000                  (      romdefs.asm):01195         CmdCircle                       EQU     DCmdCircle
0000                  (      romdefs.asm):01196         CmdClear                        EQU     DCmdClear
0000                  (      romdefs.asm):01197         CmdCload                        EQU     DCmdCload
0000                  (      romdefs.asm):01198         CmdClose                        EQU     DCmdClose
0000                  (      romdefs.asm):01199         CmdCLS                          EQU     DCmdCLS
0000                  (      romdefs.asm):01200         CmdColor                        EQU     DCmdColor
0000                  (      romdefs.asm):01201         CmdCont                         EQU     DCmdCont
0000                  (      romdefs.asm):01202         CmdCOS                          EQU     DCmdCOS
0000                  (      romdefs.asm):01203         CmdCsave                        EQU     DCmdCsave
0000                  (      romdefs.asm):01204         CmdData                         EQU     DCmdData
0000                  (      romdefs.asm):01205         CmdDef                          EQU     DCmdDef
0000                  (      romdefs.asm):01206         CmdDelete                       EQU     DCmdDelete
0000                  (      romdefs.asm):01207         CmdDim                          EQU     DCmdDim
0000                  (      romdefs.asm):01208         CmdDivide                       EQU     DCmdDivide
0000                  (      romdefs.asm):01209         CmdDload                        EQU     DCmdDload
0000                  (      romdefs.asm):01210         CmdDraw                         EQU     DCmdDraw
0000                  (      romdefs.asm):01211         CmdEdit                         EQU     DCmdEdit
0000                  (      romdefs.asm):01212         CmdEnd                          EQU     DCmdEnd
0000                  (      romdefs.asm):01213         CmdEOF                          EQU     DCmdEOF
0000                  (      romdefs.asm):01214         CmdExec                         EQU     DCmdExec
0000                  (      romdefs.asm):01215         CmdEXP                          EQU     DCmdEXP
0000                  (      romdefs.asm):01216         CmdExponet                      EQU     DCmdExponet
0000                  (      romdefs.asm):01217         CmdFIX                          EQU     DCmdFIX
0000                  (      romdefs.asm):01218         CmdFor                          EQU     DCmdFor
0000                  (      romdefs.asm):01219         CmdGet                          EQU     DCmdGet
0000                  (      romdefs.asm):01220         CmdGo                           EQU     DCmdGo
0000                  (      romdefs.asm):01221         CmdHexS                         EQU     DCmdHexS
0000                  (      romdefs.asm):01222         CmdIF                           EQU     DCmdIF
0000                  (      romdefs.asm):01223         CmdInkeyS                       EQU     DCmdInkeyS
0000                  (      romdefs.asm):01224         CmdInput                        EQU     DCmdInput
0000                  (      romdefs.asm):01225         CmdInstr                        EQU     DCmdInstr
0000                  (      romdefs.asm):01226         CmdINT                          EQU     DCmdINT
0000                  (      romdefs.asm):01227         CmdJoystk                       EQU     DCmdJoystk
0000                  (      romdefs.asm):01228         CmdLeftS                        EQU     DCmdLeftS
0000                  (      romdefs.asm):01229         CmdLEN                          EQU     DCmdLEN
0000                  (      romdefs.asm):01230         CmdLet                          EQU     DCmdLet
0000                  (      romdefs.asm):01231         CmdLine                         EQU     DCmdLine
0000                  (      romdefs.asm):01232         CmdLineInput                    EQU     DCmdLineInput
0000                  (      romdefs.asm):01233         CmdList                         EQU     DCmdList
0000                  (      romdefs.asm):01234         CmdLList                        EQU     DCmdLList
0000                  (      romdefs.asm):01235         CmdLOG                          EQU     DCmdLOG
0000                  (      romdefs.asm):01236         CmdMEM                          EQU     DCmdMEM
0000                  (      romdefs.asm):01237         CmdMidS                         EQU     DCmdMidS
0000                  (      romdefs.asm):01238         CmdMinus                        EQU     DCmdMinus
0000                  (      romdefs.asm):01239         CmdMotor                        EQU     DCmdMotor
0000                  (      romdefs.asm):01240         CmdMultiply                     EQU     DCmdMultiply
0000                  (      romdefs.asm):01241         CmdNew                          EQU     DCmdNew
0000                  (      romdefs.asm):01242         CmdNext                         EQU     DCmdNext
0000                  (      romdefs.asm):01243         CmdON                           EQU     DCmdON
0000                  (      romdefs.asm):01244         CmdOpen                         EQU     DCmdOpen
0000                  (      romdefs.asm):01245         CmdOpenEntry                    EQU     DCmdOpenEntry
0000                  (      romdefs.asm):01246         CmdOR                           EQU     DCmdOR
0000                  (      romdefs.asm):01247         CmdPaint                        EQU     DCmdPaint
0000                  (      romdefs.asm):01248         CmdPClear                       EQU     DCmdPClear
0000                  (      romdefs.asm):01249         CmdPCls                         EQU     DCmdPCls
0000                  (      romdefs.asm):01250         CmdPcopy                        EQU     DCmdPcopy
0000                  (      romdefs.asm):01251         CmdPeek                         EQU     DCmdPeek
0000                  (      romdefs.asm):01252         CmdPlay                         EQU     DCmdPlay
0000                  (      romdefs.asm):01253         CmdPlus                         EQU     DCmdPlus
0000                  (      romdefs.asm):01254         CmdPmode                        EQU     DCmdPmode
0000                  (      romdefs.asm):01255         CmdPoint                        EQU     DCmdPoint
0000                  (      romdefs.asm):01256         CmdPoke                         EQU     DCmdPoke
0000                  (      romdefs.asm):01257         CmdPOS                          EQU     DCmdPOS
0000                  (      romdefs.asm):01258         CmdPPoint                       EQU     DCmdPPoint
0000                  (      romdefs.asm):01259         CmdPReset                       EQU     DCmdPReset
0000                  (      romdefs.asm):01260         CmdPrint                        EQU     DCmdPrint
0000                  (      romdefs.asm):01261         CmdPset                         EQU     DCmdPset
0000                  (      romdefs.asm):01262         CmdPut                          EQU     DCmdPut
0000                  (      romdefs.asm):01263         CmdRead                         EQU     DCmdRead
0000                  (      romdefs.asm):01264         CmdReadFromX                    EQU     DCmdReadFromX
0000                  (      romdefs.asm):01265         CmdREM                          EQU     DCmdREM
0000                  (      romdefs.asm):01266         CmdRenum                        EQU     DCmdRenum
0000                  (      romdefs.asm):01267         CmdReset                        EQU     DCmdReset
0000                  (      romdefs.asm):01268         CmdRestore                      EQU     DCmdRestore
0000                  (      romdefs.asm):01269         CmdReturn                       EQU     DCmdReturn
0000                  (      romdefs.asm):01270         CmdRightS                       EQU     DCmdRightS
0000                  (      romdefs.asm):01271         CmdRND                          EQU     DCmdRND
0000                  (      romdefs.asm):01272         CmdRun                          EQU     DCmdRun
0000                  (      romdefs.asm):01273         CmdScreen                       EQU     DCmdScreen
0000                  (      romdefs.asm):01274         CmdSet                          EQU     DCmdSet
0000                  (      romdefs.asm):01275         CmdSGN                          EQU     DCmdSGN
0000                  (      romdefs.asm):01276         CmdSIN                          EQU     DCmdSIN
0000                  (      romdefs.asm):01277         CmdSkipf                        EQU     DCmdSkipf
0000                  (      romdefs.asm):01278         CmdSound                        EQU     DCmdSound
0000                  (      romdefs.asm):01279         CmdSQR                          EQU     DCmdSQR
0000                  (      romdefs.asm):01280         CmdStop                         EQU     DCmdStop
0000                  (      romdefs.asm):01281         CmdStringS                      EQU     DCmdStringS
0000                  (      romdefs.asm):01282         CmdSTRS                         EQU     DCmdSTRS
0000                  (      romdefs.asm):01283         CmdTAN                          EQU     DCmdTAN
0000                  (      romdefs.asm):01284         CmdTimer                        EQU     DCmdTimer
0000                  (      romdefs.asm):01285         CmdTroff                        EQU     DCmdTroff
0000                  (      romdefs.asm):01286         CmdTron                         EQU     DCmdTron
0000                  (      romdefs.asm):01287         CmdUSR                          EQU     DCmdUSR
0000                  (      romdefs.asm):01288         CmdVAL                          EQU     DCmdVAL
0000                  (      romdefs.asm):01289         CmdVarptr                       EQU     DCmdVarptr
0000                  (      romdefs.asm):01290         GrBackground                    EQU     DGrBackground
0000                  (      romdefs.asm):01291         GrBytesPerLine                  EQU     DGrBytesPerLine
0000                  (      romdefs.asm):01292         GrCalcPixelPos                  EQU     DGrCalcPixelPos
0000                  (      romdefs.asm):01293         GrCircleRadius                  EQU     DGrCircleRadius
0000                  (      romdefs.asm):01294         GrCircleXCo                     EQU     DGrCircleXCo
0000                  (      romdefs.asm):01295         GrCircleYCo                     EQU     DGrCircleYCo
0000                  (      romdefs.asm):01296         GrClearGrScreen                 EQU     DGrClearGrScreen
0000                  (      romdefs.asm):01297         GrColourSet                     EQU     DGrColourSet
0000                  (      romdefs.asm):01298         GrColourTemp                    EQU     DGrColourTemp
0000                  (      romdefs.asm):01299         GrCurrColour                    EQU     DGrCurrColour
0000                  (      romdefs.asm):01300         GrCurrPmode                     EQU     DGrCurrPmode
0000                  (      romdefs.asm):01301         GrCurrX                         EQU     DGrCurrX
0000                  (      romdefs.asm):01302         GrCurrXCo                       EQU     DGrCurrXCo
0000                  (      romdefs.asm):01303         GrCurrY                         EQU     DGrCurrY
0000                  (      romdefs.asm):01304         GrCurrYCo                       EQU     DGrCurrYCo
0000                  (      romdefs.asm):01305         GrDirtyFlag                     EQU     DGrDirtyFlag
0000                  (      romdefs.asm):01306         GrDisplayStartAddr              EQU     DGrDisplayStartAddr
0000                  (      romdefs.asm):01307         GrDraw                          EQU     DGrDraw
0000                  (      romdefs.asm):01308         GrDrawAngle                     EQU     DGrDrawAngle
0000                  (      romdefs.asm):01309         GrDrawScale                     EQU     DGrDrawScale
0000                  (      romdefs.asm):01310         GrForeground                    EQU     DGrForeground
0000                  (      romdefs.asm):01311         GrLastDisplayAddr               EQU     DGrLastDisplayAddr
0000                  (      romdefs.asm):01312         GrPixelNoX                      EQU     DGrPixelNoX
0000                  (      romdefs.asm):01313         GrPixelNoY                      EQU     DGrPixelNoY
0000                  (      romdefs.asm):01314         GrPlotFlag                      EQU     DGrPlotFlag
0000                  (      romdefs.asm):01315         GrReserveGrRam                  EQU     DGrReserveGrRam
0000                  (      romdefs.asm):01316         GrResetLRGPixel                 EQU     DGrResetLRGPixel
0000                  (      romdefs.asm):01317         GrSelectColourSet               EQU     DGrSelectColourSet
0000                  (      romdefs.asm):01318         GrSelectDisplay                 EQU     DGrSelectDisplay
0000                  (      romdefs.asm):01319         GrSelectPage                    EQU     DGrSelectPage
0000                  (      romdefs.asm):01320         GrSelectVDGColSet               EQU     DGrSelectVDGColSet
0000                  (      romdefs.asm):01321         GrSetColours                    EQU     DGrSetColours
0000                  (      romdefs.asm):01322         GrSetLRGPixel                   EQU     DGrSetLRGPixel
0000                  (      romdefs.asm):01323         GrSetResetData                  EQU     DGrSetResetData
0000                  (      romdefs.asm):01324         GrSetVDGMode                    EQU     DGrSetVDGMode
0000                  (      romdefs.asm):01325         GrSetVDGOffset                  EQU     DGrSetVDGOffset
0000                  (      romdefs.asm):01326         GrStartPages                    EQU     DGrStartPages
0000                  (      romdefs.asm):01327         IndCasBlockIn                   EQU     DIndCasBlockIn
0000                  (      romdefs.asm):01328         IndCasBlockOut                  EQU     DIndCasBlockOut
0000                  (      romdefs.asm):01329         IndCasOnRead                    EQU     DIndCasOnRead
0000                  (      romdefs.asm):01330         IndCasWriteLead                 EQU     DIndCasWriteLead
0000                  (      romdefs.asm):01331         IndCharOutput                   EQU     DIndCharOutput
0000                  (      romdefs.asm):01332         IndJoystickIn                   EQU     DIndJoystickIn
0000                  (      romdefs.asm):01333         IndKeyInput                     EQU     DIndKeyInput
0000                  (      romdefs.asm):01334         IndVecReset                     EQU     DIndVecReset
0000                  (      romdefs.asm):01335         Misc16BitScratch                EQU     DMisc16BitScratch
0000                  (      romdefs.asm):01336         PixMaskTable2Col                EQU     DPixMaskTable2Col
0000                  (      romdefs.asm):01337         PixMaskTable4Col                EQU     DPixMaskTable4Col
0000                  (      romdefs.asm):01338         PrinterCRLF                     EQU     DPrinterCRLF
0000                  (      romdefs.asm):01339         PrinterDirOut                   EQU     DPrinterDirOut
0000                  (      romdefs.asm):01340         PrinterOut                      EQU     DPrinterOut
0000                  (      romdefs.asm):01341         SecVecFIRQ                      EQU     DSecVecFIRQ
0000                  (      romdefs.asm):01342         SecVecIRQ                       EQU     DSecVecIRQ
0000                  (      romdefs.asm):01343         SecVecNMI                       EQU     DSecVecNMI
0000                  (      romdefs.asm):01344         SecVecSWI                       EQU     DSecVecSWI
0000                  (      romdefs.asm):01345         SecVecSWI2                      EQU     DSecVecSWI2
0000                  (      romdefs.asm):01346         SecVecSWI3                      EQU     DSecVecSWI3
0000                  (      romdefs.asm):01347         SerDLBaud                       EQU     DSerDLBaud
0000                  (      romdefs.asm):01348         SerDLTimeout                    EQU     DSerDLTimeout
0000                  (      romdefs.asm):01349         SndBeep                         EQU     DSndBeep
0000                  (      romdefs.asm):01350         SndDisable                      EQU     DSndDisable
0000                  (      romdefs.asm):01351         SndDotNoteScale                 EQU     DSndDotNoteScale
0000                  (      romdefs.asm):01352         SndDTOAOn                       EQU     DSndDTOAOn
0000                  (      romdefs.asm):01353         SndEnable                       EQU     DSndEnable
0000                  (      romdefs.asm):01354         SndLength                       EQU     DSndLength
0000                  (      romdefs.asm):01355         SndNoteLen                      EQU     DSndNoteLen
0000                  (      romdefs.asm):01356         SndOctave                       EQU     DSndOctave
0000                  (      romdefs.asm):01357         SndPitch                        EQU     DSndPitch
0000                  (      romdefs.asm):01358         SndPlayNote                     EQU     DSndPlayNote
0000                  (      romdefs.asm):01359         SndTempo                        EQU     DSndTempo
0000                  (      romdefs.asm):01360         SndTimerPlay                    EQU     DSndTimerPlay
0000                  (      romdefs.asm):01361         SndVolume                       EQU     DSndVolume
0000                  (      romdefs.asm):01362         SysBoot64                       EQU     DSysBoot64
0000                  (      romdefs.asm):01363         SysErr                          EQU     DSysErr
0000                  (      romdefs.asm):01364         SysErr2                         EQU     DSysErr2
0000                  (      romdefs.asm):01365         SysReadJoystick                 EQU     DSysReadJoystick
0000                  (      romdefs.asm):01366         SysReset                        EQU     DSysReset
0000                  (      romdefs.asm):01367         SysResetDA                      EQU     DSysResetDA
0000                  (      romdefs.asm):01368         SysSelJoystick                  EQU     DSysSelJoystick
0000                  (      romdefs.asm):01369         SysTimeVal                      EQU     DSysTimeVal
0000                  (      romdefs.asm):01370         SysWriteDA                      EQU     DSysWriteDA
0000                  (      romdefs.asm):01371         TextCapsLock                    EQU     DTextCapsLock
0000                  (      romdefs.asm):01372         TextClearLine                   EQU     DTextClearLine
0000                  (      romdefs.asm):01373         TextCls                         EQU     DTextCls
0000                  (      romdefs.asm):01374         TextClsChar                     EQU     DTextClsChar
0000                  (      romdefs.asm):01375         TextCursFalshCnt                EQU     DTextCursFalshCnt
0000                  (      romdefs.asm):01376         TextDevN                        EQU     DTextDevN
0000                  (      romdefs.asm):01377         TextKbdBuffAddr                 EQU     DTextKbdBuffAddr
0000                  (      romdefs.asm):01378         TextKbdDelay                    EQU     DTextKbdDelay
0000                  (      romdefs.asm):01379         TextKbdRollover                 EQU     DTextKbdRollover
0000                  (      romdefs.asm):01380         TextLastKey                     EQU     DTextLastKey
0000                  (      romdefs.asm):01381         TextOutChar                     EQU     DTextOutChar
0000                  (      romdefs.asm):01382         TextOutCRLF                     EQU     DTextOutCRLF
0000                  (      romdefs.asm):01383         TextOutNum16                    EQU     DTextOutNum16
0000                  (      romdefs.asm):01384         TextOutNumFPA0                  EQU     DTextOutNumFPA0
0000                  (      romdefs.asm):01385         TextOutQuestion                 EQU     DTextOutQuestion
0000                  (      romdefs.asm):01386         TextOutSpace                    EQU     DTextOutSpace
0000                  (      romdefs.asm):01387         TextOutString                   EQU     DTextOutString
0000                  (      romdefs.asm):01388         TextPrnAutoCRLF                 EQU     DTextPrnAutoCRLF
0000                  (      romdefs.asm):01389         TextPrnCommaW                   EQU     DTextPrnCommaW
0000                  (      romdefs.asm):01390         TextPrnCurrCol                  EQU     DTextPrnCurrCol
0000                  (      romdefs.asm):01391         TextPrnEOLCnt                   EQU     DTextPrnEOLCnt
0000                  (      romdefs.asm):01392         TextPrnEOLSeq                   EQU     DTextPrnEOLSeq
0000                  (      romdefs.asm):01393         TextPrnLastComma                EQU     DTextPrnLastComma
0000                  (      romdefs.asm):01394         TextPrnLineW                    EQU     DTextPrnLineW
0000                  (      romdefs.asm):01395         TextPrnSelFlag                  EQU     DTextPrnSelFlag
0000                  (      romdefs.asm):01396         TextResetVDU                    EQU     DTextResetVDU
0000                  (      romdefs.asm):01397         TextScanKbd                     EQU     DTextScanKbd
0000                  (      romdefs.asm):01398         TextSerBaudRate                 EQU     DTextSerBaudRate
0000                  (      romdefs.asm):01399         TextSerEOLDelay                 EQU     DTextSerEOLDelay
0000                  (      romdefs.asm):01400         TextUpdateCurs                  EQU     DTextUpdateCurs
0000                  (      romdefs.asm):01401         TextVDUCommaW                   EQU     DTextVDUCommaW
0000                  (      romdefs.asm):01402         TextVDUCurrCol                  EQU     DTextVDUCurrCol
0000                  (      romdefs.asm):01403         TextVDUCursAddr                 EQU     DTextVDUCursAddr
0000                  (      romdefs.asm):01404         TextVDULastComma                EQU     DTextVDULastComma
0000                  (      romdefs.asm):01405         TextVDULineW                    EQU     DTextVDULineW
0000                  (      romdefs.asm):01406         TextVDUOut                      EQU     DTextVDUOut
0000                  (      romdefs.asm):01407         TextWaitKey                     EQU     DTextWaitKey
0000                  (      romdefs.asm):01408         TextWaitKeyCurs                 EQU     DTextWaitKeyCurs
0000                  (      romdefs.asm):01409         TextWaitKeyCurs2                EQU     DTextWaitKeyCurs2
0000                  (      romdefs.asm):01410         UtilCopyBXtoU                   EQU     DUtilCopyBXtoU
0000                  (      romdefs.asm):01411         VarAssign16Bit                  EQU     DVarAssign16Bit
0000                  (      romdefs.asm):01412         VarAssign16Bit2                 EQU     DVarAssign16Bit2
0000                  (      romdefs.asm):01413         VarAssign16BitB                 EQU     DVarAssign16BitB
0000                  (      romdefs.asm):01414         VarAssign8Bit                   EQU     DVarAssign8Bit
0000                  (      romdefs.asm):01415         VarCKChar                       EQU     DVarCKChar
0000                  (      romdefs.asm):01416         VarCKClBrac                     EQU     DVarCKClBrac
0000                  (      romdefs.asm):01417         VarCKComma                      EQU     DVarCKComma
0000                  (      romdefs.asm):01418         VarCKOpBrac                     EQU     DVarCKOpBrac
0000                  (      romdefs.asm):01419         VarDelVar                       EQU     DVarDelVar
0000                  (      romdefs.asm):01420         VarGarbageCollect               EQU     DVarGarbageCollect
0000                  (      romdefs.asm):01421         VarGet16Bit                     EQU     DVarGet16Bit
0000                  (      romdefs.asm):01422         VarGet8Bit                      EQU     DVarGet8Bit
0000                  (      romdefs.asm):01423         VarGetComma8                    EQU     DVarGetComma8
0000                  (      romdefs.asm):01424         VarGetExpr                      EQU     DVarGetExpr
0000                  (      romdefs.asm):01425         VarGetExprCC                    EQU     DVarGetExprCC
0000                  (      romdefs.asm):01426         VarGetStr                       EQU     DVarGetStr
0000                  (      romdefs.asm):01427         VarGetUsr                       EQU     DVarGetUsr
0000                  (      romdefs.asm):01428         VarGetVar                       EQU     DVarGetVar
0000                  (      romdefs.asm):01429         VarNormFPA0                     EQU     DVarNormFPA0
0000                  (      romdefs.asm):01430         VectAccessScreen                EQU     DVectAccessScreen
0000                  (      romdefs.asm):01431         VectAssignStr                   EQU     DVectAssignStr
0000                  (      romdefs.asm):01432         VectBase                        EQU     DVectBase
0000                  (      romdefs.asm):01433         VectCheckEOF                    EQU     DVectCheckEOF
0000                  (      romdefs.asm):01434         VectCheckKeys                   EQU     DVectCheckKeys
0000                  (      romdefs.asm):01435         VectCloseAllFiles               EQU     DVectCloseAllFiles
0000                  (      romdefs.asm):01436         VectCloseFile                   EQU     DVectCloseFile
0000                  (      romdefs.asm):01437         VectCloseFileCmd                EQU     DVectCloseFileCmd
0000                  (      romdefs.asm):01438         VectCmdInterp                   EQU     DVectCmdInterp
0000                  (      romdefs.asm):01439         VectDeTokenize                  EQU     DVectDeTokenize
0000                  (      romdefs.asm):01440         VectDevInit                     EQU     DVectDevInit
0000                  (      romdefs.asm):01441         VectDevNo                       EQU     DVectDevNo
0000                  (      romdefs.asm):01442         VectDevOpen                     EQU     DVectDevOpen
0000                  (      romdefs.asm):01443         VectEvaluateExpr                EQU     DVectEvaluateExpr
0000                  (      romdefs.asm):01444         VectGetNextCmd                  EQU     DVectGetNextCmd
0000                  (      romdefs.asm):01445         VectInChar                      EQU     DVectInChar
0000                  (      romdefs.asm):01446         VectInputFile                   EQU     DVectInputFile
0000                  (      romdefs.asm):01447         VectLineInputFile               EQU     DVectLineInputFile
0000                  (      romdefs.asm):01448         VectOutChar                     EQU     DVectOutChar
0000                  (      romdefs.asm):01449         VectOutputFile                  EQU     DVectOutputFile
0000                  (      romdefs.asm):01450         VectReReqestIn                  EQU     DVectReReqestIn
0000                  (      romdefs.asm):01451         VectResetBasMem                 EQU     DVectResetBasMem
0000                  (      romdefs.asm):01452         VectRunLink                     EQU     DVectRunLink
0000                  (      romdefs.asm):01453         VectSysError                    EQU     DVectSysError
0000                  (      romdefs.asm):01454         VectTokenize                    EQU     DVectTokenize
0000                  (      romdefs.asm):01455         VectUserError                   EQU     DVectUserError
0000                  (      romdefs.asm):01456         WarmStart                       EQU     DWarmStart
0000                  (      romdefs.asm):01457         WarmStartFlag                   EQU     DWarmStartFlag
                      (      romdefs.asm):01458         
                      (      romdefs.asm):01459                                 ENDC
                      (      romdefs.asm):01460         
                      (      romdefs.asm):01461                                 ifdef Tandy
                      (      romdefs.asm):01462         
     0000             (      romdefs.asm):01463         StubResWordsOfs                 EQU     CStubResWordsOfs
     0001             (      romdefs.asm):01464         StubResLookupOfs                EQU     CStubResLookupOfs
     0003             (      romdefs.asm):01465         StubResJumpOfs                  EQU     CStubResJumpOfs
     0005             (      romdefs.asm):01466         StubFuncsOfs                    EQU     CStubFuncsOfs
     0006             (      romdefs.asm):01467         StubFuncsLookupOfs              EQU     CStubFuncsLookupOfs
     0008             (      romdefs.asm):01468         StubFuncsJumpOfs                EQU     CStubFuncsJumpOfs
     0021             (      romdefs.asm):01469         Skip1                           EQU     CSkip1
     008C             (      romdefs.asm):01470         Skip2                           EQU     CSkip2
     0086             (      romdefs.asm):01471         Skip1LD                         EQU     CSkip1LD
     007D             (      romdefs.asm):01472         Skip2TST                        EQU     CSkip2TST
     8273             (      romdefs.asm):01473         CoCoVec167                      EQU     CCoCoVec167
     8CF1             (      romdefs.asm):01474         CoCoVect16A                     EQU     CCoCoVect16A
     8286             (      romdefs.asm):01475         CoCoVect176                     EQU     CCoCoVect176
     8E90             (      romdefs.asm):01476         CoCoVect179                     EQU     CCoCoVect179
     8846             (      romdefs.asm):01477         CoCoVect18B                     EQU     CCoCoVect18B
     88F0             (      romdefs.asm):01478         CoCoVect191                     EQU     CCoCoVect191
     829C             (      romdefs.asm):01479         CoCoVect194                     EQU     CCoCoVect194
     87E5             (      romdefs.asm):01480         CoCoVect197                     EQU     CCoCoVect197
     82B9             (      romdefs.asm):01481         CoCoVect19A                     EQU     CCoCoVect19A
     8304             (      romdefs.asm):01482         CoCoVect1A3                     EQU     CCoCoVect1A3
     0027             (      romdefs.asm):01483         AddrFWareRamTop                 EQU     CAddrFWareRamTop
     0074             (      romdefs.asm):01484         AddrRamTop                      EQU     CAddrRamTop
     0021             (      romdefs.asm):01485         AddrStack                       EQU     CAddrStack
     0123             (      romdefs.asm):01486         BasAddrCmdDisp                  EQU     CBasAddrCmdDisp
     0121             (      romdefs.asm):01487         BasAddrCmdList                  EQU     CBasAddrCmdList
     012D             (      romdefs.asm):01488         BasAddrDskCmdDisp               EQU     CBasAddrDskCmdDisp
     012B             (      romdefs.asm):01489         BasAddrDskCmdList               EQU     CBasAddrDskCmdList
     0132             (      romdefs.asm):01490         BasAddrDskFuncDisp              EQU     CBasAddrDskFuncDisp
     0130             (      romdefs.asm):01491         BasAddrDskFuncList              EQU     CBasAddrDskFuncList
     0128             (      romdefs.asm):01492         BasAddrFuncDisp                 EQU     CBasAddrFuncDisp
     0126             (      romdefs.asm):01493         BasAddrFuncList                 EQU     CBasAddrFuncList
     00A6             (      romdefs.asm):01494         BasAddrSigByte                  EQU     CBasAddrSigByte
     A61C             (      romdefs.asm):01495         BasAOError                      EQU     CBasAOError
     0005             (      romdefs.asm):01496         BasArrayEval                    EQU     CBasArrayEval
     A0B6             (      romdefs.asm):01497         BasBootBasic                    EQU     CBasBootBasic
     0017             (      romdefs.asm):01498         BasBotStack                     EQU     CBasBotStack
     ADC4             (      romdefs.asm):01499         BasBRARun                       EQU     CBasBRARun
     0000             (      romdefs.asm):01500         BasBreakFlag                    EQU     CBasBreakFlag
     03D7             (      romdefs.asm):01501         BasBuffer                       EQU     CBasBuffer
     AC1E             (      romdefs.asm):01502         BasChkArrSpaceMv                EQU     CBasChkArrSpaceMv
     AC33             (      romdefs.asm):01503         BasChkB2Free                    EQU     CBasChkB2Free
     8866             (      romdefs.asm):01504         BasChkDirect                    EQU     CBasChkDirect
     009F             (      romdefs.asm):01505         BasChrGet                       EQU     CBasChrGet
     00A5             (      romdefs.asm):01506         BasChrGetCurr                   EQU     CBasChrGetCurr
     00D3             (      romdefs.asm):01507         BasCloadMOffs                   EQU     CBasCloadMOffs
     AC73             (      romdefs.asm):01508         BasCmdMode                      EQU     CBasCmdMode
     0029             (      romdefs.asm):01509         BasContLine                     EQU     CBasContLine
     0068             (      romdefs.asm):01510         BasCurrentLine                  EQU     CBasCurrentLine
     0001             (      romdefs.asm):01511         BasDelim1                       EQU     CBasDelim1
     0002             (      romdefs.asm):01512         BasDelim2                       EQU     CBasDelim2
     002F             (      romdefs.asm):01513         BasDirectTextPtr                EQU     CBasDirectTextPtr
     0008             (      romdefs.asm):01514         BasDisArraySearch               EQU     CBasDisArraySearch
     A61F             (      romdefs.asm):01515         BasDNError                      EQU     CBasDNError
     ADD4             (      romdefs.asm):01516         BasDoDispatch                   EQU     CBasDoDispatch
     00D7             (      romdefs.asm):01517         BasEditorLineLen                EQU     CBasEditorLineLen
     ABAF             (      romdefs.asm):01518         BasErrorCodeTable               EQU     CBasErrorCodeTable
     009D             (      romdefs.asm):01519         BasExecAddr                     EQU     CBasExecAddr
     B44A             (      romdefs.asm):01520         BasFCError                      EQU     CBasFCError
     AD01             (      romdefs.asm):01521         BasFindLineNo                   EQU     CBasFindLineNo
     A616             (      romdefs.asm):01522         BasFMError                      EQU     CBasFMError
     0007             (      romdefs.asm):01523         BasGarbageFlag                  EQU     CBasGarbageFlag
     0003             (      romdefs.asm):01524         BasGenCount                     EQU     CBasGenCount
     A5A2             (      romdefs.asm):01525         BasGetDevNo                     EQU     CBasGetDevNo
     AF67             (      romdefs.asm):01526         BasGetLineNo                    EQU     CBasGetLineNo
     B6A4             (      romdefs.asm):01527         BasGetStrFirst                  EQU     CBasGetStrFirst
     B654             (      romdefs.asm):01528         BasGetStrLenAddr                EQU     CBasGetStrLenAddr
     A755             (      romdefs.asm):01529         BasicCassBitIn                  EQU     CBasicCassBitIn
     A749             (      romdefs.asm):01530         BasicCassByIn                   EQU     CBasicCassByIn
     A82A             (      romdefs.asm):01531         BasicCassByOut                  EQU     CBasicCassByOut
     A7EB             (      romdefs.asm):01532         BasicCassOff                    EQU     CBasicCassOff
     A7CA             (      romdefs.asm):01533         BasicCassOn                     EQU     CBasicCassOn
     A77C             (      romdefs.asm):01534         BasicCassOnRd                   EQU     CBasicCassOnRd
     A199             (      romdefs.asm):01535         BasicCursorB                    EQU     CBasicCursorB
     0000             (      romdefs.asm):01536         BasicHWInit                     EQU     CBasicHWInit
     A9DE             (      romdefs.asm):01537         BasicJoyIn                      EQU     CBasicJoyIn
     A1C1             (      romdefs.asm):01538         BasicKbdIn                      EQU     CBasicKbdIn
     A2BF             (      romdefs.asm):01539         BasicPrintOut                   EQU     CBasicPrintOut
     A30A             (      romdefs.asm):01540         BasicScreenOut                  EQU     CBasicScreenOut
     0000             (      romdefs.asm):01541         BasicSerIn                      EQU     CBasicSerIn
     0000             (      romdefs.asm):01542         BasicSerOut                     EQU     CBasicSerOut
     0000             (      romdefs.asm):01543         BasicSetBaud                    EQU     CBasicSetBaud
     0000             (      romdefs.asm):01544         BasicSWInit                     EQU     CBasicSWInit
     A7D8             (      romdefs.asm):01545         BasicWriteLead                  EQU     CBasicWriteLead
     886C             (      romdefs.asm):01546         BasIDError                      EQU     CBasIDError
     0004             (      romdefs.asm):01547         BasIfCount                      EQU     CBasIfCount
     A39D             (      romdefs.asm):01548         BasInBuffFromX                  EQU     CBasInBuffFromX
     0009             (      romdefs.asm):01549         BasInputFlag                    EQU     CBasInputFlag
     A619             (      romdefs.asm):01550         BasIOError                      EQU     CBasIOError
     A9B3             (      romdefs.asm):01551         BasIRQVec                       EQU     CBasIRQVec
     015A             (      romdefs.asm):01552         BasJoyVal0                      EQU     CBasJoyVal0
     015B             (      romdefs.asm):01553         BasJoyVal1                      EQU     CBasJoyVal1
     015C             (      romdefs.asm):01554         BasJoyVal2                      EQU     CBasJoyVal2
     015D             (      romdefs.asm):01555         BasJoyVal3                      EQU     CBasJoyVal3
     89E8             (      romdefs.asm):01556         BasLineInputEntry               EQU     CBasLineInputEntry
     02DC             (      romdefs.asm):01557         BasLinInpBuff                   EQU     CBasLinInpBuff
     02DA             (      romdefs.asm):01558         BasLinInpHead                   EQU     CBasLinInpHead
     B764             (      romdefs.asm):01559         BasList                         EQU     CBasList
     0066             (      romdefs.asm):01560         BasListLine                     EQU     CBasListLine
     96EC             (      romdefs.asm):01561         BasLocateScreen                 EQU     CBasLocateScreen
     B625             (      romdefs.asm):01562         BasLSError                      EQU     CBasLSError
     8CDD             (      romdefs.asm):01563         BasNEError                      EQU     CBasNEError
     AD19             (      romdefs.asm):01564         BasNew                          EQU     CBasNew
     A3FB             (      romdefs.asm):01565         BasNOError                      EQU     CBasNOError
     0120             (      romdefs.asm):01566         BasNumCmds                      EQU     CBasNumCmds
     012A             (      romdefs.asm):01567         BasNumDskCmds                   EQU     CBasNumDskCmds
     012F             (      romdefs.asm):01568         BasNumDskFuncs                  EQU     CBasNumDskFuncs
     0125             (      romdefs.asm):01569         BasNumFuncs                     EQU     CBasNumFuncs
     002D             (      romdefs.asm):01570         BasOldInputPtr                  EQU     CBasOldInputPtr
     AC44             (      romdefs.asm):01571         BasOMError                      EQU     CBasOMError
     BA92             (      romdefs.asm):01572         BasOVError                      EQU     CBasOVError
     ADEB             (      romdefs.asm):01573         BasPollKeyboard                 EQU     CBasPollKeyboard
     BF3B             (      romdefs.asm):01574         BasRandom8                      EQU     CBasRandom8
     0115             (      romdefs.asm):01575         BasRandomSeed                   EQU     CBasRandomSeed
     000A             (      romdefs.asm):01576         BasRelateFlag                   EQU     CBasRelateFlag
     00D1             (      romdefs.asm):01577         BasRenumStart                   EQU     CBasRenumStart
     00D5             (      romdefs.asm):01578         BasRenumStartLine               EQU     CBasRenumStartLine
     00CF             (      romdefs.asm):01579         BasRenumVal                     EQU     CBasRenumVal
     AD33             (      romdefs.asm):01580         BasResetStack                   EQU     CBasResetStack
     B50F             (      romdefs.asm):01581         BasResStr                       EQU     CBasResStr
     B56D             (      romdefs.asm):01582         BasResStr2                      EQU     CBasResStr2
     00AB             (      romdefs.asm):01583         BasRndData                      EQU     CBasRndData
     AD9E             (      romdefs.asm):01584         BasRun                          EQU     CBasRun
     AEBB             (      romdefs.asm):01585         BasSetProgPtrX                  EQU     CBasSetProgPtrX
     80E7             (      romdefs.asm):01586         BasSignonMess                   EQU     CBasSignonMess
     AEB4             (      romdefs.asm):01587         BasSkipLineNo                   EQU     CBasSkipLineNo
     B277             (      romdefs.asm):01588         BasSNError                      EQU     CBasSNError
     0019             (      romdefs.asm):01589         BasStartProg                    EQU     CBasStartProg
     B553             (      romdefs.asm):01590         BasSTError                      EQU     CBasSTError
     01A9             (      romdefs.asm):01591         BasStrDescStack                 EQU     CBasStrDescStack
     000B             (      romdefs.asm):01592         BasStrFirstFreeTemp             EQU     CBasStrFirstFreeTemp
     000D             (      romdefs.asm):01593         BasStrLastUsedTemp              EQU     CBasStrLastUsedTemp
     0025             (      romdefs.asm):01594         BasStrUtil                      EQU     CBasStrUtil
     0120             (      romdefs.asm):01595         BasStub0                        EQU     CBasStub0
     012A             (      romdefs.asm):01596         BasStub1                        EQU     CBasStub1
     0134             (      romdefs.asm):01597         BasStub2                        EQU     CBasStub2
     013E             (      romdefs.asm):01598         BasStub3                        EQU     CBasStub3
     0013             (      romdefs.asm):01599         BasTempFPA2                     EQU     CBasTempFPA2
     002B             (      romdefs.asm):01600         BasTempLine                     EQU     CBasTempLine
     000F             (      romdefs.asm):01601         BasTempPtr                      EQU     CBasTempPtr
     0011             (      romdefs.asm):01602         BasTempPtr1                     EQU     CBasTempPtr1
     003F             (      romdefs.asm):01603         BasTempRelateFlag               EQU     CBasTempRelateFlag
     003B             (      romdefs.asm):01604         BasTempVarDesc                  EQU     CBasTempVarDesc
     B151             (      romdefs.asm):01605         BasTMError                      EQU     CBasTMError
     00AF             (      romdefs.asm):01606         BasTronFlag                     EQU     CBasTronFlag
     AED2             (      romdefs.asm):01607         BasULError                      EQU     CBasULError
     0076             (      romdefs.asm):01608         BasUnused1                      EQU     CBasUnused1
     00B0             (      romdefs.asm):01609         BasUSRTableAddr                 EQU     CBasUSRTableAddr
     013E             (      romdefs.asm):01610         BasUsrVecNoDisk                 EQU     CBasUsrVecNoDisk
     001D             (      romdefs.asm):01611         BasVarArrayAddr                 EQU     CBasVarArrayAddr
     0052             (      romdefs.asm):01612         BasVarAssign16                  EQU     CBasVarAssign16
     0033             (      romdefs.asm):01613         BasVarDataAddr                  EQU     CBasVarDataAddr
     0031             (      romdefs.asm):01614         BasVarDataLine                  EQU     CBasVarDataLine
     001F             (      romdefs.asm):01615         BasVarEnd                       EQU     CBasVarEnd
     004F             (      romdefs.asm):01616         BasVarFPAcc1                    EQU     CBasVarFPAcc1
     005C             (      romdefs.asm):01617         BasVarFPAcc2                    EQU     CBasVarFPAcc2
     0040             (      romdefs.asm):01618         BasVarFPAcc3                    EQU     CBasVarFPAcc3
     0045             (      romdefs.asm):01619         BasVarFPAcc4                    EQU     CBasVarFPAcc4
     004A             (      romdefs.asm):01620         BasVarFPAcc5                    EQU     CBasVarFPAcc5
     0037             (      romdefs.asm):01621         BasVarLastInUse                 EQU     CBasVarLastInUse
     0039             (      romdefs.asm):01622         BasVarPtrLast                   EQU     CBasVarPtrLast
     001B             (      romdefs.asm):01623         BasVarSimpleAddr                EQU     CBasVarSimpleAddr
     0021             (      romdefs.asm):01624         BasVarStringBase                EQU     CBasVarStringBase
     0023             (      romdefs.asm):01625         BasVarStrTop                    EQU     CBasVarStrTop
     0006             (      romdefs.asm):01626         BasVarType                      EQU     CBasVarType
     AD21             (      romdefs.asm):01627         BasVect1                        EQU     CBasVect1
     AD26             (      romdefs.asm):01628         BasVect1a                       EQU     CBasVect1a
     ACEF             (      romdefs.asm):01629         BasVect2                        EQU     CBasVect2
     BC06             (      romdefs.asm):01630         BasZDError                      EQU     CBasZDError
     01E3             (      romdefs.asm):01631         CasASCIIFlag                    EQU     CCasASCIIFlag
     A974             (      romdefs.asm):01632         CasAudioOff                     EQU     CCasAudioOff
     A99D             (      romdefs.asm):01633         CasAudioOn                      EQU     CCasAudioOn
     0083             (      romdefs.asm):01634         CasBitCount                     EQU     CCasBitCount
     A755             (      romdefs.asm):01635         CasBitIn                        EQU     CCasBitIn
     A70B             (      romdefs.asm):01636         CasBlockIn                      EQU     CCasBlockIn
     007D             (      romdefs.asm):01637         CasBlockLen                     EQU     CCasBlockLen
     A7F4             (      romdefs.asm):01638         CasBlockOut                     EQU     CCasBlockOut
     007C             (      romdefs.asm):01639         CasBlockType                    EQU     CCasBlockType
     A749             (      romdefs.asm):01640         CasByteIn                       EQU     CCasByteIn
     A82A             (      romdefs.asm):01641         CasByteOut                      EQU     CCasByteOut
     0080             (      romdefs.asm):01642         CasCkSum                        EQU     CCasCkSum
     A429             (      romdefs.asm):01643         CasClosFiles                    EQU     CCasClosFiles
     01E5             (      romdefs.asm):01644         CasEntryAddr                    EQU     CCasEntryAddr
     0070             (      romdefs.asm):01645         CasEOFFlag                      EQU     CCasEOFFlag
     A681             (      romdefs.asm):01646         CasFindFile                     EQU     CCasFindFile
     01D2             (      romdefs.asm):01647         CasFName                        EQU     CCasFName
     01DA             (      romdefs.asm):01648         CasFNameFound                   EQU     CCasFNameFound
     01D1             (      romdefs.asm):01649         CasFNameLen                     EQU     CCasFNameLen
     01E2             (      romdefs.asm):01650         CasFType                        EQU     CCasFType
     01E4             (      romdefs.asm):01651         CasGapFlag                      EQU     CCasGapFlag
     007A             (      romdefs.asm):01652         CasHeadBuffAddr                 EQU     CCasHeadBuffAddr
     01DA             (      romdefs.asm):01653         CasIOBuff                       EQU     CCasIOBuff
     007E             (      romdefs.asm):01654         CasIOBuffAddr                   EQU     CCasIOBuffAddr
     0079             (      romdefs.asm):01655         CasIOBuffSize                   EQU     CCasIOBuffSize
     0081             (      romdefs.asm):01656         CasIOErrorCode                  EQU     CCasIOErrorCode
     006E             (      romdefs.asm):01657         CasIOFlag                       EQU     CCasIOFlag
     0085             (      romdefs.asm):01658         CasLastSine                     EQU     CCasLastSine
     0092             (      romdefs.asm):01659         CasLeadCount                    EQU     CCasLeadCount
     01E7             (      romdefs.asm):01660         CasLoadAddr                     EQU     CCasLoadAddr
     0091             (      romdefs.asm):01661         CasMax12                        EQU     CCasMax12
     0092             (      romdefs.asm):01662         CasMax24                        EQU     CCasMax24
     008A             (      romdefs.asm):01663         CasMotorDelay                   EQU     CCasMotorDelay
     A7EB             (      romdefs.asm):01664         CasMotorOff                     EQU     CCasMotorOff
     A7CA             (      romdefs.asm):01665         CasMotorOn                      EQU     CCasMotorOn
     008F             (      romdefs.asm):01666         CasPartrt                       EQU     CCasPartrt
     0084             (      romdefs.asm):01667         CasPhaseFlag                    EQU     CCasPhaseFlag
     A511             (      romdefs.asm):01668         CasReadBin                      EQU     CCasReadBin
     A701             (      romdefs.asm):01669         CasReadBlock1                   EQU     CCasReadBlock1
     A77C             (      romdefs.asm):01670         CasReadLeader                   EQU     CCasReadLeader
     0078             (      romdefs.asm):01671         CasStatus                       EQU     CCasStatus
     0082             (      romdefs.asm):01672         CasTemp                         EQU     CCasTemp
     A469             (      romdefs.asm):01673         CasWriteBasic                   EQU     CCasWriteBasic
     833D             (      romdefs.asm):01674         CasWriteBin                     EQU     CCasWriteBin
     A7E5             (      romdefs.asm):01675         CasWriteBlock1                  EQU     CCasWriteBlock1
     A7D8             (      romdefs.asm):01676         CasWriteLeader                  EQU     CCasWriteLeader
     BC93             (      romdefs.asm):01677         CmdABS                          EQU     CCmdABS
     B2D5             (      romdefs.asm):01678         CmdAND                          EQU     CCmdAND
     B6A0             (      romdefs.asm):01679         CmdASC                          EQU     CCmdASC
     83B0             (      romdefs.asm):01680         CmdATN                          EQU     CCmdATN
     A990             (      romdefs.asm):01681         CmdAudio                        EQU     CCmdAudio
     B68C             (      romdefs.asm):01682         CmdCHRS                         EQU     CCmdCHRS
     9E9D             (      romdefs.asm):01683         CmdCircle                       EQU     CCmdCircle
     AE41             (      romdefs.asm):01684         CmdClear                        EQU     CCmdClear
     A498             (      romdefs.asm):01685         CmdCload                        EQU     CCmdCload
     A416             (      romdefs.asm):01686         CmdClose                        EQU     CCmdClose
     A910             (      romdefs.asm):01687         CmdCLS                          EQU     CCmdCLS
     9546             (      romdefs.asm):01688         CmdColor                        EQU     CCmdColor
     AE30             (      romdefs.asm):01689         CmdCont                         EQU     CCmdCont
     8378             (      romdefs.asm):01690         CmdCOS                          EQU     CCmdCOS
     A44C             (      romdefs.asm):01691         CmdCsave                        EQU     CCmdCsave
     AEE0             (      romdefs.asm):01692         CmdData                         EQU     CCmdData
     8871             (      romdefs.asm):01693         CmdDef                          EQU     CCmdDef
     8970             (      romdefs.asm):01694         CmdDelete                       EQU     CCmdDelete
     B34E             (      romdefs.asm):01695         CmdDim                          EQU     CCmdDim
     BB91             (      romdefs.asm):01696         CmdDivide                       EQU     CCmdDivide
     8C18             (      romdefs.asm):01697         CmdDload                        EQU     CCmdDload
     9CB6             (      romdefs.asm):01698         CmdDraw                         EQU     CCmdDraw
     8533             (      romdefs.asm):01699         CmdEdit                         EQU     CCmdEdit
     AE02             (      romdefs.asm):01700         CmdEnd                          EQU     CCmdEnd
     A5CE             (      romdefs.asm):01701         CmdEOF                          EQU     CCmdEOF
     A53E             (      romdefs.asm):01702         CmdExec                         EQU     CCmdExec
     84F2             (      romdefs.asm):01703         CmdEXP                          EQU     CCmdEXP
     011D             (      romdefs.asm):01704         CmdExponet                      EQU     CCmdExponet
     8524             (      romdefs.asm):01705         CmdFIX                          EQU     CCmdFIX
     AD47             (      romdefs.asm):01706         CmdFor                          EQU     CCmdFor
     9755             (      romdefs.asm):01707         CmdGet                          EQU     CCmdGet
     AE86             (      romdefs.asm):01708         CmdGo                           EQU     CCmdGo
     8BDD             (      romdefs.asm):01709         CmdHexS                         EQU     CCmdHexS
     AF14             (      romdefs.asm):01710         CmdIF                           EQU     CCmdIF
     A564             (      romdefs.asm):01711         CmdInkeyS                       EQU     CCmdInkeyS
     AFF5             (      romdefs.asm):01712         CmdInput                        EQU     CCmdInput
     877E             (      romdefs.asm):01713         CmdInstr                        EQU     CCmdInstr
     BCEE             (      romdefs.asm):01714         CmdINT                          EQU     CCmdINT
     A9C6             (      romdefs.asm):01715         CmdJoystk                       EQU     CCmdJoystk
     B6AB             (      romdefs.asm):01716         CmdLeftS                        EQU     CCmdLeftS
     B681             (      romdefs.asm):01717         CmdLEN                          EQU     CCmdLEN
     AF89             (      romdefs.asm):01718         CmdLet                          EQU     CCmdLet
     93BB             (      romdefs.asm):01719         CmdLine                         EQU     CCmdLine
     89C0             (      romdefs.asm):01720         CmdLineInput                    EQU     CCmdLineInput
     B764             (      romdefs.asm):01721         CmdList                         EQU     CCmdList
     B75E             (      romdefs.asm):01722         CmdLList                        EQU     CCmdLList
     8446             (      romdefs.asm):01723         CmdLOG                          EQU     CCmdLOG
     B4EE             (      romdefs.asm):01724         CmdMEM                          EQU     CCmdMEM
     B6CF             (      romdefs.asm):01725         CmdMidS                         EQU     CCmdMidS
     B9BC             (      romdefs.asm):01726         CmdMinus                        EQU     CCmdMinus
     A7BD             (      romdefs.asm):01727         CmdMotor                        EQU     CCmdMotor
     BACC             (      romdefs.asm):01728         CmdMultiply                     EQU     CCmdMultiply
     AD17             (      romdefs.asm):01729         CmdNew                          EQU     CCmdNew
     B0F8             (      romdefs.asm):01730         CmdNext                         EQU     CCmdNext
     AF42             (      romdefs.asm):01731         CmdON                           EQU     CCmdON
     A5F6             (      romdefs.asm):01732         CmdOpen                         EQU     CCmdOpen
     A603             (      romdefs.asm):01733         CmdOpenEntry                    EQU     CCmdOpenEntry
     B2D4             (      romdefs.asm):01734         CmdOR                           EQU     CCmdOR
     98EC             (      romdefs.asm):01735         CmdPaint                        EQU     CCmdPaint
     968B             (      romdefs.asm):01736         CmdPClear                       EQU     CCmdPClear
     9532             (      romdefs.asm):01737         CmdPCls                         EQU     CCmdPCls
     9723             (      romdefs.asm):01738         CmdPcopy                        EQU     CCmdPcopy
     B750             (      romdefs.asm):01739         CmdPeek                         EQU     CCmdPeek
     9A22             (      romdefs.asm):01740         CmdPlay                         EQU     CCmdPlay
     B9C5             (      romdefs.asm):01741         CmdPlus                         EQU     CCmdPlus
     9621             (      romdefs.asm):01742         CmdPmode                        EQU     CCmdPmode
     A8F5             (      romdefs.asm):01743         CmdPoint                        EQU     CCmdPoint
     B757             (      romdefs.asm):01744         CmdPoke                         EQU     CCmdPoke
     86AC             (      romdefs.asm):01745         CmdPOS                          EQU     CCmdPOS
     9339             (      romdefs.asm):01746         CmdPPoint                       EQU     CCmdPPoint
     9365             (      romdefs.asm):01747         CmdPReset                       EQU     CCmdPReset
     B8F7             (      romdefs.asm):01748         CmdPrint                        EQU     CCmdPrint
     9361             (      romdefs.asm):01749         CmdPset                         EQU     CCmdPset
     9758             (      romdefs.asm):01750         CmdPut                          EQU     CCmdPut
     B046             (      romdefs.asm):01751         CmdRead                         EQU     CCmdRead
     B049             (      romdefs.asm):01752         CmdReadFromX                    EQU     CCmdReadFromX
     AEE3             (      romdefs.asm):01753         CmdREM                          EQU     CCmdREM
     8A09             (      romdefs.asm):01754         CmdRenum                        EQU     CCmdRenum
     A8B1             (      romdefs.asm):01755         CmdReset                        EQU     CCmdReset
     ADE4             (      romdefs.asm):01756         CmdRestore                      EQU     CCmdRestore
     AEC0             (      romdefs.asm):01757         CmdReturn                       EQU     CCmdReturn
     B6C8             (      romdefs.asm):01758         CmdRightS                       EQU     CCmdRightS
     BF1F             (      romdefs.asm):01759         CmdRND                          EQU     CCmdRND
     AE75             (      romdefs.asm):01760         CmdRun                          EQU     CCmdRun
     9670             (      romdefs.asm):01761         CmdScreen                       EQU     CCmdScreen
     A880             (      romdefs.asm):01762         CmdSet                          EQU     CCmdSet
     BC7A             (      romdefs.asm):01763         CmdSGN                          EQU     CCmdSGN
     BF78             (      romdefs.asm):01764         CmdSIN                          EQU     CCmdSIN
     A5EC             (      romdefs.asm):01765         CmdSkipf                        EQU     CCmdSkipf
     A94B             (      romdefs.asm):01766         CmdSound                        EQU     CCmdSound
     8480             (      romdefs.asm):01767         CmdSQR                          EQU     CCmdSQR
     AE09             (      romdefs.asm):01768         CmdStop                         EQU     CCmdStop
     874E             (      romdefs.asm):01769         CmdStringS                      EQU     CCmdStringS
     B4FD             (      romdefs.asm):01770         CmdSTRS                         EQU     CCmdSTRS
     8381             (      romdefs.asm):01771         CmdTAN                          EQU     CCmdTAN
     8968             (      romdefs.asm):01772         CmdTimer                        EQU     CCmdTimer
     86A8             (      romdefs.asm):01773         CmdTroff                        EQU     CCmdTroff
     86A7             (      romdefs.asm):01774         CmdTron                         EQU     CCmdTron
     0112             (      romdefs.asm):01775         CmdUSR                          EQU     CCmdUSR
     B716             (      romdefs.asm):01776         CmdVAL                          EQU     CCmdVAL
     86BE             (      romdefs.asm):01777         CmdVarptr                       EQU     CCmdVarptr
     00B3             (      romdefs.asm):01778         GrBackground                    EQU     CGrBackground
     00B9             (      romdefs.asm):01779         GrBytesPerLine                  EQU     CGrBytesPerLine
     A8D9             (      romdefs.asm):01780         GrCalcPixelPos                  EQU     CGrCalcPixelPos
     00D0             (      romdefs.asm):01781         GrCircleRadius                  EQU     CGrCircleRadius
     00CB             (      romdefs.asm):01782         GrCircleXCo                     EQU     CGrCircleXCo
     00CD             (      romdefs.asm):01783         GrCircleYCo                     EQU     CGrCircleYCo
     9539             (      romdefs.asm):01784         GrClearGrScreen                 EQU     CGrClearGrScreen
     00C1             (      romdefs.asm):01785         GrColourSet                     EQU     CGrColourSet
     00B4             (      romdefs.asm):01786         GrColourTemp                    EQU     CGrColourTemp
     00B5             (      romdefs.asm):01787         GrCurrColour                    EQU     CGrCurrColour
     00B6             (      romdefs.asm):01788         GrCurrPmode                     EQU     CGrCurrPmode
     00BD             (      romdefs.asm):01789         GrCurrX                         EQU     CGrCurrX
     00C7             (      romdefs.asm):01790         GrCurrXCo                       EQU     CGrCurrXCo
     00BF             (      romdefs.asm):01791         GrCurrY                         EQU     CGrCurrY
     00C9             (      romdefs.asm):01792         GrCurrYCo                       EQU     CGrCurrYCo
     00DB             (      romdefs.asm):01793         GrDirtyFlag                     EQU     CGrDirtyFlag
     00BA             (      romdefs.asm):01794         GrDisplayStartAddr              EQU     CGrDisplayStartAddr
     9CB6             (      romdefs.asm):01795         GrDraw                          EQU     CGrDraw
     00E8             (      romdefs.asm):01796         GrDrawAngle                     EQU     CGrDrawAngle
     00E9             (      romdefs.asm):01797         GrDrawScale                     EQU     CGrDrawScale
     00B2             (      romdefs.asm):01798         GrForeground                    EQU     CGrForeground
     00B7             (      romdefs.asm):01799         GrLastDisplayAddr               EQU     CGrLastDisplayAddr
     00C3             (      romdefs.asm):01800         GrPixelNoX                      EQU     CGrPixelNoX
     00C5             (      romdefs.asm):01801         GrPixelNoY                      EQU     CGrPixelNoY
     00C2             (      romdefs.asm):01802         GrPlotFlag                      EQU     CGrPlotFlag
     9695             (      romdefs.asm):01803         GrReserveGrRam                  EQU     CGrReserveGrRam
     A8B5             (      romdefs.asm):01804         GrResetLRGPixel                 EQU     CGrResetLRGPixel
     9682             (      romdefs.asm):01805         GrSelectColourSet               EQU     CGrSelectColourSet
     95AA             (      romdefs.asm):01806         GrSelectDisplay                 EQU     CGrSelectDisplay
     9653             (      romdefs.asm):01807         GrSelectPage                    EQU     CGrSelectPage
     9616             (      romdefs.asm):01808         GrSelectVDGColSet               EQU     CGrSelectVDGColSet
     959A             (      romdefs.asm):01809         GrSetColours                    EQU     CGrSetColours
     A88D             (      romdefs.asm):01810         GrSetLRGPixel                   EQU     CGrSetLRGPixel
     0086             (      romdefs.asm):01811         GrSetResetData                  EQU     CGrSetResetData
     95FB             (      romdefs.asm):01812         GrSetVDGMode                    EQU     CGrSetVDGMode
     960F             (      romdefs.asm):01813         GrSetVDGOffset                  EQU     CGrSetVDGOffset
     00BC             (      romdefs.asm):01814         GrStartPages                    EQU     CGrStartPages
     A006             (      romdefs.asm):01815         IndCasBlockIn                   EQU     CIndCasBlockIn
     A008             (      romdefs.asm):01816         IndCasBlockOut                  EQU     CIndCasBlockOut
     A004             (      romdefs.asm):01817         IndCasOnRead                    EQU     CIndCasOnRead
     A00C             (      romdefs.asm):01818         IndCasWriteLead                 EQU     CIndCasWriteLead
     A002             (      romdefs.asm):01819         IndCharOutput                   EQU     CIndCharOutput
     A00A             (      romdefs.asm):01820         IndJoystickIn                   EQU     CIndJoystickIn
     A000             (      romdefs.asm):01821         IndKeyInput                     EQU     CIndKeyInput
     0072             (      romdefs.asm):01822         IndVecReset                     EQU     CIndVecReset
     008A             (      romdefs.asm):01823         Misc16BitScratch                EQU     CMisc16BitScratch
     92DD             (      romdefs.asm):01824         PixMaskTable2Col                EQU     CPixMaskTable2Col
     92E5             (      romdefs.asm):01825         PixMaskTable4Col                EQU     CPixMaskTable4Col
     0000             (      romdefs.asm):01826         PrinterCRLF                     EQU     CPrinterCRLF
     0000             (      romdefs.asm):01827         PrinterDirOut                   EQU     CPrinterDirOut
     A2BF             (      romdefs.asm):01828         PrinterOut                      EQU     CPrinterOut
     010F             (      romdefs.asm):01829         SecVecFIRQ                      EQU     CSecVecFIRQ
     010C             (      romdefs.asm):01830         SecVecIRQ                       EQU     CSecVecIRQ
     0109             (      romdefs.asm):01831         SecVecNMI                       EQU     CSecVecNMI
     0106             (      romdefs.asm):01832         SecVecSWI                       EQU     CSecVecSWI
     0103             (      romdefs.asm):01833         SecVecSWI2                      EQU     CSecVecSWI2
     0100             (      romdefs.asm):01834         SecVecSWI3                      EQU     CSecVecSWI3
     00E6             (      romdefs.asm):01835         SerDLBaud                       EQU     CSerDLBaud
     00E7             (      romdefs.asm):01836         SerDLTimeout                    EQU     CSerDLTimeout
     A951             (      romdefs.asm):01837         SndBeep                         EQU     CSndBeep
     A974             (      romdefs.asm):01838         SndDisable                      EQU     CSndDisable
     00E5             (      romdefs.asm):01839         SndDotNoteScale                 EQU     CSndDotNoteScale
     A99E             (      romdefs.asm):01840         SndDTOAOn                       EQU     CSndDTOAOn
     A976             (      romdefs.asm):01841         SndEnable                       EQU     CSndEnable
     008D             (      romdefs.asm):01842         SndLength                       EQU     CSndLength
     00E1             (      romdefs.asm):01843         SndNoteLen                      EQU     CSndNoteLen
     00DE             (      romdefs.asm):01844         SndOctave                       EQU     CSndOctave
     008C             (      romdefs.asm):01845         SndPitch                        EQU     CSndPitch
     9AFF             (      romdefs.asm):01846         SndPlayNote                     EQU     CSndPlayNote
     00E2             (      romdefs.asm):01847         SndTempo                        EQU     CSndTempo
     00E3             (      romdefs.asm):01848         SndTimerPlay                    EQU     CSndTimerPlay
     00DF             (      romdefs.asm):01849         SndVolume                       EQU     CSndVolume
     0000             (      romdefs.asm):01850         SysBoot64                       EQU     CSysBoot64
     AC46             (      romdefs.asm):01851         SysErr                          EQU     CSysErr
     AC60             (      romdefs.asm):01852         SysErr2                         EQU     CSysErr2
     A9DE             (      romdefs.asm):01853         SysReadJoystick                 EQU     CSysReadJoystick
     A027             (      romdefs.asm):01854         SysReset                        EQU     CSysReset
     A985             (      romdefs.asm):01855         SysResetDA                      EQU     CSysResetDA
     A9A2             (      romdefs.asm):01856         SysSelJoystick                  EQU     CSysSelJoystick
     0112             (      romdefs.asm):01857         SysTimeVal                      EQU     CSysTimeVal
     A987             (      romdefs.asm):01858         SysWriteDA                      EQU     CSysWriteDA
     011A             (      romdefs.asm):01859         TextCapsLock                    EQU     CTextCapsLock
     A323             (      romdefs.asm):01860         TextClearLine                   EQU     CTextClearLine
     A928             (      romdefs.asm):01861         TextCls                         EQU     CTextCls
     A92A             (      romdefs.asm):01862         TextClsChar                     EQU     CTextClsChar
     008F             (      romdefs.asm):01863         TextCursFalshCnt                EQU     CTextCursFalshCnt
     006F             (      romdefs.asm):01864         TextDevN                        EQU     CTextDevN
     0035             (      romdefs.asm):01865         TextKbdBuffAddr                 EQU     CTextKbdBuffAddr
     011B             (      romdefs.asm):01866         TextKbdDelay                    EQU     CTextKbdDelay
     0152             (      romdefs.asm):01867         TextKbdRollover                 EQU     CTextKbdRollover
     0087             (      romdefs.asm):01868         TextLastKey                     EQU     CTextLastKey
     A282             (      romdefs.asm):01869         TextOutChar                     EQU     CTextOutChar
     B958             (      romdefs.asm):01870         TextOutCRLF                     EQU     CTextOutCRLF
     BDCC             (      romdefs.asm):01871         TextOutNum16                    EQU     CTextOutNum16
     BDD4             (      romdefs.asm):01872         TextOutNumFPA0                  EQU     CTextOutNumFPA0
     B9AF             (      romdefs.asm):01873         TextOutQuestion                 EQU     CTextOutQuestion
     B9AC             (      romdefs.asm):01874         TextOutSpace                    EQU     CTextOutSpace
     B99C             (      romdefs.asm):01875         TextOutString                   EQU     CTextOutString
     0148             (      romdefs.asm):01876         TextPrnAutoCRLF                 EQU     CTextPrnAutoCRLF
     0099             (      romdefs.asm):01877         TextPrnCommaW                   EQU     CTextPrnCommaW
     009C             (      romdefs.asm):01878         TextPrnCurrCol                  EQU     CTextPrnCurrCol
     014A             (      romdefs.asm):01879         TextPrnEOLCnt                   EQU     CTextPrnEOLCnt
     014B             (      romdefs.asm):01880         TextPrnEOLSeq                   EQU     CTextPrnEOLSeq
     009A             (      romdefs.asm):01881         TextPrnLastComma                EQU     CTextPrnLastComma
     009B             (      romdefs.asm):01882         TextPrnLineW                    EQU     CTextPrnLineW
     03FF             (      romdefs.asm):01883         TextPrnSelFlag                  EQU     CTextPrnSelFlag
     95AC             (      romdefs.asm):01884         TextResetVDU                    EQU     CTextResetVDU
     A1C1             (      romdefs.asm):01885         TextScanKbd                     EQU     CTextScanKbd
     0095             (      romdefs.asm):01886         TextSerBaudRate                 EQU     CTextSerBaudRate
     0097             (      romdefs.asm):01887         TextSerEOLDelay                 EQU     CTextSerEOLDelay
     A199             (      romdefs.asm):01888         TextUpdateCurs                  EQU     CTextUpdateCurs
     006A             (      romdefs.asm):01889         TextVDUCommaW                   EQU     CTextVDUCommaW
     006C             (      romdefs.asm):01890         TextVDUCurrCol                  EQU     CTextVDUCurrCol
     0088             (      romdefs.asm):01891         TextVDUCursAddr                 EQU     CTextVDUCursAddr
     006B             (      romdefs.asm):01892         TextVDULastComma                EQU     CTextVDULastComma
     006D             (      romdefs.asm):01893         TextVDULineW                    EQU     CTextVDULineW
     A30A             (      romdefs.asm):01894         TextVDUOut                      EQU     CTextVDUOut
     ADFB             (      romdefs.asm):01895         TextWaitKey                     EQU     CTextWaitKey
     8CC6             (      romdefs.asm):01896         TextWaitKeyCurs                 EQU     CTextWaitKeyCurs
     A171             (      romdefs.asm):01897         TextWaitKeyCurs2                EQU     CTextWaitKeyCurs2
     A59A             (      romdefs.asm):01898         UtilCopyBXtoU                   EQU     CUtilCopyBXtoU
     B4F2             (      romdefs.asm):01899         VarAssign16Bit                  EQU     CVarAssign16Bit
     B4F3             (      romdefs.asm):01900         VarAssign16Bit2                 EQU     CVarAssign16Bit2
     880E             (      romdefs.asm):01901         VarAssign16BitB                 EQU     CVarAssign16BitB
     B4F3             (      romdefs.asm):01902         VarAssign8Bit                   EQU     CVarAssign8Bit
     B26F             (      romdefs.asm):01903         VarCKChar                       EQU     CVarCKChar
     B267             (      romdefs.asm):01904         VarCKClBrac                     EQU     CVarCKClBrac
     B26D             (      romdefs.asm):01905         VarCKComma                      EQU     CVarCKComma
     B26A             (      romdefs.asm):01906         VarCKOpBrac                     EQU     CVarCKOpBrac
     B659             (      romdefs.asm):01907         VarDelVar                       EQU     CVarDelVar
     B591             (      romdefs.asm):01908         VarGarbageCollect               EQU     CVarGarbageCollect
     B73D             (      romdefs.asm):01909         VarGet16Bit                     EQU     CVarGet16Bit
     B70B             (      romdefs.asm):01910         VarGet8Bit                      EQU     CVarGet8Bit
     B738             (      romdefs.asm):01911         VarGetComma8                    EQU     CVarGetComma8
     B146             (      romdefs.asm):01912         VarGetExpr                      EQU     CVarGetExpr
     B143             (      romdefs.asm):01913         VarGetExprCC                    EQU     CVarGetExprCC
     B156             (      romdefs.asm):01914         VarGetStr                       EQU     CVarGetStr
     B3E9             (      romdefs.asm):01915         VarGetUsr                       EQU     CVarGetUsr
     B357             (      romdefs.asm):01916         VarGetVar                       EQU     CVarGetVar
     BA1C             (      romdefs.asm):01917         VarNormFPA0                     EQU     CVarNormFPA0
     01A0             (      romdefs.asm):01918         VectAccessScreen                EQU     CVectAccessScreen
     019D             (      romdefs.asm):01919         VectAssignStr                   EQU     CVectAssignStr
     015E             (      romdefs.asm):01920         VectBase                        EQU     CVectBase
     0188             (      romdefs.asm):01921         VectCheckEOF                    EQU     CVectCheckEOF
     017F             (      romdefs.asm):01922         VectCheckKeys                   EQU     CVectCheckKeys
     0173             (      romdefs.asm):01923         VectCloseAllFiles               EQU     CVectCloseAllFiles
     0176             (      romdefs.asm):01924         VectCloseFile                   EQU     CVectCloseFile
     0185             (      romdefs.asm):01925         VectCloseFileCmd                EQU     CVectCloseFileCmd
     0179             (      romdefs.asm):01926         VectCmdInterp                   EQU     CVectCmdInterp
     01A6             (      romdefs.asm):01927         VectDeTokenize                  EQU     CVectDeTokenize
     0164             (      romdefs.asm):01928         VectDevInit                     EQU     CVectDevInit
     0161             (      romdefs.asm):01929         VectDevNo                       EQU     CVectDevNo
     015E             (      romdefs.asm):01930         VectDevOpen                     EQU     CVectDevOpen
     018B             (      romdefs.asm):01931         VectEvaluateExpr                EQU     CVectEvaluateExpr
     019A             (      romdefs.asm):01932         VectGetNextCmd                  EQU     CVectGetNextCmd
     016A             (      romdefs.asm):01933         VectInChar                      EQU     CVectInChar
     016D             (      romdefs.asm):01934         VectInputFile                   EQU     CVectInputFile
     0182             (      romdefs.asm):01935         VectLineInputFile               EQU     CVectLineInputFile
     0167             (      romdefs.asm):01936         VectOutChar                     EQU     CVectOutChar
     0170             (      romdefs.asm):01937         VectOutputFile                  EQU     CVectOutputFile
     017C             (      romdefs.asm):01938         VectReReqestIn                  EQU     CVectReReqestIn
     0197             (      romdefs.asm):01939         VectResetBasMem                 EQU     CVectResetBasMem
     0194             (      romdefs.asm):01940         VectRunLink                     EQU     CVectRunLink
     0191             (      romdefs.asm):01941         VectSysError                    EQU     CVectSysError
     01A3             (      romdefs.asm):01942         VectTokenize                    EQU     CVectTokenize
     018E             (      romdefs.asm):01943         VectUserError                   EQU     CVectUserError
     80C0             (      romdefs.asm):01944         WarmStart                       EQU     CWarmStart
     0071             (      romdefs.asm):01945         WarmStartFlag                   EQU     CWarmStartFlag
                      (      romdefs.asm):01946         
                      (      romdefs.asm):01947                                 ENDC
                      (      romdefs.asm):01948                                 
     008A             (      romdefs.asm):01949         DBZero          EQU     Misc16BitScratch ; this is always set to Zero.
                      (      romdefs.asm):01950                                 
     003A             (      romdefs.asm):01951         StackBuf        equ     $3A             ; stack buffer size
     003D             (      romdefs.asm):01952         RelPTR          equ     $03D            ; Tempory arithmetic/logical table ptr
     00FA             (      romdefs.asm):01953         LineBufMax      equ     250             ; maximum line buffer length
                      (      romdefs.asm):01954         
                      (      romdefs.asm):01955         ; For compatibility with CoCo ROM listings
                      (      romdefs.asm):01956         ; first floating point accumulator
     004F             (      romdefs.asm):01957         FP0EXP          equ     BasVarFPAcc1    ; exponent
     0050             (      romdefs.asm):01958         FPA0            equ     BasVarFPAcc1+1  ; mantissa
     0054             (      romdefs.asm):01959         FP0SGN          equ     BasVarFPAcc1+5  ; sign
     0055             (      romdefs.asm):01960         COEFCT          equ     BasVarFPAcc1+6  ; polynomial coeficient counter
     0056             (      romdefs.asm):01961         StrDesc         equ     BasVarFPAcc1+7  ; tempory string descriptor (5 bytes)
                      (      romdefs.asm):01962         
                      (      romdefs.asm):01963         ; second floating point accumulator
     005C             (      romdefs.asm):01964         FP1EXP          equ     BasVarFPAcc2    ; exponent $5C
     005D             (      romdefs.asm):01965         FPA1            equ     BasVarFPAcc2+1  ; mantissa $5D
     0061             (      romdefs.asm):01966         FP1SGN          equ     BasVarFPAcc2+5  ; sign $61
     0062             (      romdefs.asm):01967         ResSGN          equ     BasVarFPAcc2+6  ; sign of result of FP operation $62
     0063             (      romdefs.asm):01968         FPSByte         equ     BasVarFPAcc2+7  ; floating point sub byte $63
     0064             (      romdefs.asm):01969         CoefPTR         equ     BasVarFPAcc2+8  ; Coeficient pointer
                      (      romdefs.asm):01970         
     005B             (      romdefs.asm):01971         FPCARY          equ     $005B   
                      (      romdefs.asm):01972         
     0013             (      romdefs.asm):01973         FPA2            equ     BasTempFPA2     ; FPA2
                      (      romdefs.asm):01974         
     00AB             (      romdefs.asm):01975         VarAB           equ     $00AB           ; temp vars / RND
     00AC             (      romdefs.asm):01976         VarAC           equ     $00AC           ; temp vars / RND
     00AD             (      romdefs.asm):01977         VarAD           equ     $00AD           ; temp vars / RND
     00AE             (      romdefs.asm):01978         VarAE           equ     $00AE           ; temp vars / RND
                      (      romdefs.asm):01979         
                      (      romdefs.asm):01980         ;
                      (      romdefs.asm):01981         ; Device numbers
                      (      romdefs.asm):01982         ;
                      (      romdefs.asm):01983         
     0000             (      romdefs.asm):01984         DevConsole      equ     0               ; console
     FFFF             (      romdefs.asm):01985         DevCasette      equ     -1              ; cassette
     FFFE             (      romdefs.asm):01986         DevPrinter      equ     -2              ; printer
                      (      romdefs.asm):01987                 
                      (      romdefs.asm):01988         ;
                      (      romdefs.asm):01989         ; Cassette file types
                      (      romdefs.asm):01990         ;
     0055             (      romdefs.asm):01991         SyncByte        equ     $55             ; Sync byte in cassete files
     003C             (      romdefs.asm):01992         BlockBegin      equ     $3C             ; Begining of block marker
                      (      romdefs.asm):01993         
                      (      romdefs.asm):01994         ;Block Types
     0000             (      romdefs.asm):01995         BtFileName      equ     $00             ; File name block
     0001             (      romdefs.asm):01996         BtData          equ     $01             ; Data block
     00FF             (      romdefs.asm):01997         BtEOF           equ     $FF             ; End of file block
                      (      romdefs.asm):01998         
     000F             (      romdefs.asm):01999         FNameBlockLen   equ     15              ; 15 bytes in header block
     0008             (      romdefs.asm):02000         CasFilenameLen  equ     8               ; Cassette filename length
     00FA             (      romdefs.asm):02001         DefBlockSize    equ     250             ; Default block size
                      (      romdefs.asm):02002         
                      (      romdefs.asm):02003         ;File Types, as stored in filename block
     0000             (      romdefs.asm):02004         FtBasic         equ     $00             ; Basic program
     0001             (      romdefs.asm):02005         FtDataFile      equ     $01             ; Data file
     0002             (      romdefs.asm):02006         FtMachineCode   equ     $02             ; Machine code program
     0003             (      romdefs.asm):02007         FtBinary        equ     $03             ; Binary file
     0088             (      romdefs.asm):02008         FtDream         equ     $88             ; Dream Assembler source file
     00FF             (      romdefs.asm):02009         FtHeaderless    equ     $FF             ; Headerless
                      (      romdefs.asm):02010         
                      (      romdefs.asm):02011         ;Ascii/Binary flag from filename block
     00FF             (      romdefs.asm):02012         AsAscii         equ     $FF             ; ASCII file
     0000             (      romdefs.asm):02013         AsBinary        equ     $00             ; Binary file (tokenised basic)
                      (      romdefs.asm):02014         
                      (      romdefs.asm):02015         ; Gap Flag from filename block
     0000             (      romdefs.asm):02016         GfUngapped      equ     $00             ; No gaps
     00FF             (      romdefs.asm):02017         GfGapped        equ     $FF             ; Gaps between blocks
                      (      romdefs.asm):02018         
                      (      romdefs.asm):02019         ; Cassette file IO types
     0001             (      romdefs.asm):02020         CasInputFile    equ     1               ; input file
     0002             (      romdefs.asm):02021         CasOutputFile   equ     2               ; output file
                      (      romdefs.asm):02022         
                      (      romdefs.asm):02023         ;
                      (      romdefs.asm):02024         ; Screen metrics.
                      (      romdefs.asm):02025         ;
     00FF             (      romdefs.asm):02026         GrMaxX          equ     255             ; Maximum X co-ordinate
     00BF             (      romdefs.asm):02027         GrMaxY          equ     191             ; Maximum Y co-ordinate
     0008             (      romdefs.asm):02028         GrMaxColour     equ     8               ; maximum colour number
     0004             (      romdefs.asm):02029         GrMaxPmode      equ     4               ; maximum pmode 
     0001             (      romdefs.asm):02030         GrMaxColourSet  equ     1               ; maximum colour set    
     0008             (      romdefs.asm):02031         GrMaxPages      equ     8               ; maximum PCLEAR pages
     0600             (      romdefs.asm):02032         GrPageSize      equ     $600            ; Graphic (pclear) page size in bytes
                      (      romdefs.asm):02033         
     0006             (      romdefs.asm):02034         GrStartPage     equ     $06             ; default start page for graphics memory $0600
     001E             (      romdefs.asm):02035         BasStartPage    equ     $1E             ; default start page for basic program $1E00
                      (      romdefs.asm):02036         
     0400             (      romdefs.asm):02037         TextScreenBase  equ     $0400           ; base of text screen
     0600             (      romdefs.asm):02038         GrScreenBase    equ     $0600           ; base of graphics pages
     0200             (      romdefs.asm):02039         TextScreenLen   equ     $0200           ; Length of text screen
     05FF             (      romdefs.asm):02040         TextScreenLast  equ     (TextScreenBase+TextScreenLen)-1        ; last character of text screen
                      (      romdefs.asm):02041         
                      (      romdefs.asm):02042         ;
                      (      romdefs.asm):02043         ; Lo-res colour masks
                      (      romdefs.asm):02044         ;
                      (      romdefs.asm):02045         
     0000             (      romdefs.asm):02046         MaskGreen       equ     $00             ; Green
     0010             (      romdefs.asm):02047         MaskYellow      equ     $10             ; Yellow
     0020             (      romdefs.asm):02048         MaskBlue        equ     $20             ; Blue
     0030             (      romdefs.asm):02049         MaskRed         equ     $30             ; red
     0040             (      romdefs.asm):02050         MaskBuff        equ     $40             ; buff / white
     0050             (      romdefs.asm):02051         MaskCyan        equ     $50             ; cyan
     0060             (      romdefs.asm):02052         MaskMagenta     equ     $60             ; magenta
     0070             (      romdefs.asm):02053         MaskOrange      equ     $70             ; orange
                      (      romdefs.asm):02054         
     0010             (      romdefs.asm):02055         LRGColourDiff   equ     $10             ; difference between colours    
                      (      romdefs.asm):02056         
                      (      romdefs.asm):02057         ;
                      (      romdefs.asm):02058         ; Lo-res pixel masks
                      (      romdefs.asm):02059         ;
     0008             (      romdefs.asm):02060         MaskUpR         equ     $08             ; upper right
     0004             (      romdefs.asm):02061         MaskUpL         equ     $04             ; upper left
     0002             (      romdefs.asm):02062         MaskLowR        equ     $02             ; lower right
     0001             (      romdefs.asm):02063         MaskLowL        equ     $01             ; lower left
     000F             (      romdefs.asm):02064         MaskAllOn       equ     (MaskUpR+MaskUpL+MaskLowR+MaskLowL)     ; all on
     0000             (      romdefs.asm):02065         MaskAllOff      equ     $00             ; all off
                      (      romdefs.asm):02066         
     0080             (      romdefs.asm):02067         MaskLRG         equ     $80             ; low res graphics
                      (      romdefs.asm):02068         
                      (      romdefs.asm):02069         ; 
                      (      romdefs.asm):02070         ; Lo-res (semigraphics) and text screen metrics.
                      (      romdefs.asm):02071         ;
                      (      romdefs.asm):02072         
     003F             (      romdefs.asm):02073         LoMaxX          equ     63              ; Maximum lo-res X co-ordinate
     001F             (      romdefs.asm):02074         LoMaxY          equ     31              ; Maximum lo-res Y co-ordinate
     0008             (      romdefs.asm):02075         LoMaxColour     equ     8               ; max lo-res colour
     0020             (      romdefs.asm):02076         TextCharsLine   equ     32              ; Text/Lo-res character cells per line
                      (      romdefs.asm):02077         
                      (      romdefs.asm):02078         ;
                      (      romdefs.asm):02079         ; Cartridge entry points
                      (      romdefs.asm):02080         ;
                      (      romdefs.asm):02081         
     C000             (      romdefs.asm):02082         CartBase        equ     $c000           ; cartridge area base
     C000             (      romdefs.asm):02083         CartEntryFIRQ   equ     CartBase        ; entry point when FIRQ generated
     C002             (      romdefs.asm):02084         CartEntryDOS    equ     CartBase+2      ; entry point when dos flag found 'DK' at $C000
     444B             (      romdefs.asm):02085         CartDOSFlag     equ     $444B           ; Dos flag word : 'DK' 
                      (      romdefs.asm):02086         
                      (      romdefs.asm):02087         ;
                      (      romdefs.asm):02088         ; Dragon 64 RAM basic stuff
                      (      romdefs.asm):02089         ;
                      (      romdefs.asm):02090         
     C000             (      romdefs.asm):02091         D64RAMBase      equ     $C000           ; Dragon 64 RAM basic starts at $c000
     FEFF             (      romdefs.asm):02092         D64RAMTop       equ     $FEFF           ; Dragon 64 RAM ends here 
                      (      romdefs.asm):02093         
                      (      romdefs.asm):02094         ;
                      (      romdefs.asm):02095         ; Firmware flag used by warm start and RAM basic boot
                      (      romdefs.asm):02096         ;
     0055             (      romdefs.asm):02097         FFlagTrue       equ     $55             ; flag initialised / true
     0012             (      romdefs.asm):02098         NOPFlag         equ     $12             ; op-code fro NOP, used to mark start of reset vector           
                      (      romdefs.asm):02099         
                      (      romdefs.asm):02100         ;
                      (      romdefs.asm):02101         ; General evaluation vars, multiple uses
                      (      romdefs.asm):02102         ;
                      (      romdefs.asm):02103         
     0037             (      romdefs.asm):02104         Eval37  equ     $37
     0038             (      romdefs.asm):02105         Eval38  equ     $38
     0039             (      romdefs.asm):02106         Eval39  equ     $39
     003A             (      romdefs.asm):02107         Eval3A  equ     $3A
     003B             (      romdefs.asm):02108         Eval3B  equ     $3B
     003C             (      romdefs.asm):02109         Eval3C  equ     $3C
     003E             (      romdefs.asm):02110         Eval3E  equ     $3E
     003F             (      romdefs.asm):02111         Eval3F  equ     $3F
                      (      romdefs.asm):02112         
     0040             (      romdefs.asm):02113         Eval40  equ     $40
     0041             (      romdefs.asm):02114         Eval41  equ     $41
     0042             (      romdefs.asm):02115         Eval42  equ     $42
     0043             (      romdefs.asm):02116         Eval43  equ     $43
     0044             (      romdefs.asm):02117         Eval44  equ     $44
     0045             (      romdefs.asm):02118         Eval45  equ     $45
     0046             (      romdefs.asm):02119         Eval46  equ     $46
     0047             (      romdefs.asm):02120         Eval47  equ     $47
     0048             (      romdefs.asm):02121         Eval48  equ     $48
     0049             (      romdefs.asm):02122         Eval49  equ     $49
     004A             (      romdefs.asm):02123         Eval4A  equ     $4A
     004B             (      romdefs.asm):02124         Eval4B  equ     $4B
     004C             (      romdefs.asm):02125         Eval4C  equ     $4C
     004D             (      romdefs.asm):02126         Eval4D  equ     $4D
     004E             (      romdefs.asm):02127         Eval4E  equ     $4E
                      (      romdefs.asm):02128         
     00CF             (      romdefs.asm):02129         EvalCF  equ     $CF
                      (      romdefs.asm):02130         
     00D1             (      romdefs.asm):02131         EvalD1  equ     $D1
     00D2             (      romdefs.asm):02132         EvalD2  equ     $D2
     00D3             (      romdefs.asm):02133         EvalD3  equ     $D3
     00D4             (      romdefs.asm):02134         EvalD4  equ     $D4
     00D5             (      romdefs.asm):02135         EvalD5  equ     $D5
     00D6             (      romdefs.asm):02136         EvalD6  equ     $D6
     00D7             (      romdefs.asm):02137         EvalD7  equ     $D7
     00D8             (      romdefs.asm):02138         EvalD8  equ     $D8
     00D9             (      romdefs.asm):02139         EvalD9  equ     $D9
     00DA             (      romdefs.asm):02140         EvalDA  equ     $DA
     00DB             (      romdefs.asm):02141         EvalDB  equ     $DB
     00DC             (      romdefs.asm):02142         EvalDC  equ     $DC     
                      (      romdefs.asm):02143         
     0047             (      romdefs.asm):02144         BasFoundLineNo  EQU     Eval47          ; Address of line number found by BasFindLineNo
                      (    DragonMMC.asm):00116                                 use             mmc2def.asm
                      (      mmc2def.asm):00001         ; /*
                      (      mmc2def.asm):00002         ; mmc2def.h Symbolic defines for DragonMMC
                      (      mmc2def.asm):00003         
                      (      mmc2def.asm):00004         ; 2011-05-25, Phill Harvey-Smith.
                      (      mmc2def.asm):00005         
                      (      mmc2def.asm):00006         ; // Register definitions, these are offsets from 0xFF50 on the Dragon side.
                      (      mmc2def.asm):00007         
                      (      mmc2def.asm):00008         ;; Old mappings                        
                      (      mmc2def.asm):00009         ;CMD_REG                 equ $00
                      (      mmc2def.asm):00010         ;LATCH_REG               equ $01
                      (      mmc2def.asm):00011         ;READ_DATA_REG           equ $02
                      (      mmc2def.asm):00012         ;WRITE_DATA_REG          equ $03
                      (      mmc2def.asm):00013         ;WRITE_DATA_REG          equ READ_DATA_REG
                      (      mmc2def.asm):00014         
     0000             (      mmc2def.asm):00015         CMD_REG                 equ $00
     0001             (      mmc2def.asm):00016         LATCH_REG               equ $01
     0002             (      mmc2def.asm):00017         READ_DATA_REG           equ $02
     0002             (      mmc2def.asm):00018         WRITE_DATA_REG          equ READ_DATA_REG
                      (      mmc2def.asm):00019         
                      (      mmc2def.asm):00020         
                      (      mmc2def.asm):00021         ; // DIR_CMD_REG commands
     0000             (      mmc2def.asm):00022         CMD_DIR_OPEN            equ $00
     0001             (      mmc2def.asm):00023         CMD_DIR_READ            equ $01
     0002             (      mmc2def.asm):00024         CMD_DIR_CWD             equ $02
     0003             (      mmc2def.asm):00025         CMD_DIR_GETCWD                  equ $03
     0004             (      mmc2def.asm):00026         CMD_DIR_MAKE                    equ     $04
     0005             (      mmc2def.asm):00027         CMD_DIR_REMOVE                  equ     $05
     0006             (      mmc2def.asm):00028         CMD_DIR_SET_SNAPPATH    equ $06
     0007             (      mmc2def.asm):00029         CMD_DIR_GET_SNAPPATH    equ $07
                      (      mmc2def.asm):00030         
                      (      mmc2def.asm):00031         ; // CMD_REG_COMMANDS
     0010             (      mmc2def.asm):00032         CMD_FILE_CLOSE          equ $10
     0011             (      mmc2def.asm):00033         CMD_FILE_OPEN_READ      equ $11
     0012             (      mmc2def.asm):00034         CMD_FILE_OPEN_IMG       equ $12
     0013             (      mmc2def.asm):00035         CMD_FILE_OPEN_WRITE     equ $13
     0014             (      mmc2def.asm):00036         CMD_FILE_DELETE         equ $14
     0015             (      mmc2def.asm):00037         CMD_FILE_GETINFO        equ $15
     0016             (      mmc2def.asm):00038         CMD_FILE_OPENAUTOD      equ $16
     0017             (      mmc2def.asm):00039         CMD_FILE_OPENAUTOC      equ $17
     0018             (      mmc2def.asm):00040         CMD_FILE_OPEN_OVERWRITE equ $18
     0019             (      mmc2def.asm):00041         CMD_FILE_OPEN_SNAPR             equ $19
     001A             (      mmc2def.asm):00042         CMD_FILE_OPEN_SNAPW             equ $1A
     001B             (      mmc2def.asm):00043         CMD_FILE_OPEN_STREAMR   equ     $1B
     001C             (      mmc2def.asm):00044         CMD_FILE_OPEN_STREAMW   equ     $1C
     001D             (      mmc2def.asm):00045         CMD_FILE_COPY                   equ $1D
     001E             (      mmc2def.asm):00046         CMD_FILE_RENAME                 equ     $1E
     001F             (      mmc2def.asm):00047         CMD_FILE_OPENCRE_IMG    equ     $1F
                      (      mmc2def.asm):00048         
     0020             (      mmc2def.asm):00049         CMD_INIT_READ           equ $20
     0021             (      mmc2def.asm):00050         CMD_INIT_WRITE          equ $21
     0022             (      mmc2def.asm):00051         CMD_READ_BYTES          equ $22
     0023             (      mmc2def.asm):00052         CMD_WRITE_BYTES         equ $23
     0024             (      mmc2def.asm):00053         CMD_REWIND                          equ $24
     0025             (      mmc2def.asm):00054         CMD_SEEK                            equ $25
     0026             (      mmc2def.asm):00055         CMD_TELL                            equ $26
     0027             (      mmc2def.asm):00056         CMD_GET_FID                         equ $27
                      (      mmc2def.asm):00057         
                      (      mmc2def.asm):00058         ; // READ_DATA_REG "commands"
                      (      mmc2def.asm):00059         
                      (      mmc2def.asm):00060         ; // Utility commands
     0030             (      mmc2def.asm):00061         CMD_GET_STRLEN                  equ $30
                      (      mmc2def.asm):00062         
                      (      mmc2def.asm):00063         ; // EXEC_PACKET_REG "commands"
     003F             (      mmc2def.asm):00064         CMD_EXEC_PACKET         equ $3F
                      (      mmc2def.asm):00065         
                      (      mmc2def.asm):00066         ; // SDOS_LBA_REG commands
     0040             (      mmc2def.asm):00067         CMD_LOAD_LBA            equ $40
     0041             (      mmc2def.asm):00068         CMD_GET_IMG_STATUS      equ $41
     0042             (      mmc2def.asm):00069         CMD_GET_IMG_NAME        equ $42
     0043             (      mmc2def.asm):00070         CMD_READ_IMG_SEC        equ $43
     0044             (      mmc2def.asm):00071         CMD_WRITE_IMG_SEC       equ $44
     0045             (      mmc2def.asm):00072         CMD_SER_IMG_INFO        equ $45
     0046             (      mmc2def.asm):00073         CMD_VALID_IMG_NAMES     equ $46
     0047             (      mmc2def.asm):00074         CMD_IMG_UNMOUNT         equ $47
     0048             (      mmc2def.asm):00075         CMD_IMG_SEEK                    equ $48
     0049             (      mmc2def.asm):00076         CMD_CREATE_IMG                  equ $49
     004A             (      mmc2def.asm):00077         CMD_GET_FDC_STATUS              equ $4A
     004B             (      mmc2def.asm):00078         CMD_READ_NEXT_IMG_SEC   equ $4B
     004C             (      mmc2def.asm):00079         CMD_LOAD_HR             equ $4C
                      (      mmc2def.asm):00080         
                      (      mmc2def.asm):00081         ; // Cassette file commands
                      (      mmc2def.asm):00082         
     0050             (      mmc2def.asm):00083         CMD_CAS_FTYPE                   equ $50
     005F             (      mmc2def.asm):00084         CMD_CAS_EMULATE         equ $5F
                      (      mmc2def.asm):00085         
                      (      mmc2def.asm):00086         ; // UTIL_CMD_REG commands
     0080             (      mmc2def.asm):00087         CMD_GET_CARD_TYPE       equ $80
     0090             (      mmc2def.asm):00088         CMD_SET_BUSY                    equ $90
     0091             (      mmc2def.asm):00089         CMD_NOP                             equ $91
     0092             (      mmc2def.asm):00090         CMD_SYNC                                equ $92
                      (      mmc2def.asm):00091         
     00A0             (      mmc2def.asm):00092         CMD_GET_PORT_DDR        equ $A0
     00A1             (      mmc2def.asm):00093         CMD_SET_PORT_DDR        equ $A1
     00A2             (      mmc2def.asm):00094         CMD_READ_PORT           equ $A2
     00A3             (      mmc2def.asm):00095         CMD_WRITE_PORT          equ $A3
                      (      mmc2def.asm):00096         
     00C0             (      mmc2def.asm):00097         CMD_GET_DATETIME        equ $C0
     00C1             (      mmc2def.asm):00098         CMD_SET_DATETIME        equ $C1
                      (      mmc2def.asm):00099         
     00E0             (      mmc2def.asm):00100         CMD_GET_FW_VER          equ $E0
     00E1             (      mmc2def.asm):00101         CMD_GET_BL_VER          equ $E1
                      (      mmc2def.asm):00102         
     00E8             (      mmc2def.asm):00103         CMD_GET_RAM_CTRL                equ $E8
     00E9             (      mmc2def.asm):00104         CMD_SET_RAM_CTRL                equ $E9
                      (      mmc2def.asm):00105         
     00EF             (      mmc2def.asm):00106         CMD_GET_SAMBITS                 equ     $EF
                      (      mmc2def.asm):00107         
     00F0             (      mmc2def.asm):00108         CMD_GET_CFG_BYTE        equ $F0
     00F1             (      mmc2def.asm):00109         CMD_SET_CFG_BYTE        equ $F1
     00F2             (      mmc2def.asm):00110         CMD_SET_PLATFORM                equ     $F2
     00FD             (      mmc2def.asm):00111         CMD_READ_AUX            equ $FD
     00FE             (      mmc2def.asm):00112         CMD_GET_HEARTBEAT       equ $FE
                      (      mmc2def.asm):00113         
                      (      mmc2def.asm):00114         
                      (      mmc2def.asm):00115         ;// Status codes
                      (      mmc2def.asm):00116         ;// Unlike AtoMMC, DragonMMC should return with STATUS_COMPLETE set when 
                      (      mmc2def.asm):00117         ;// a command completes.
                      (      mmc2def.asm):00118         ;// If an error condition occours, then STATUS_ERROR should be set, this 
                      (      mmc2def.asm):00119         ;// way we can use the 6809 BITA / BITB instructions to test for error.
                      (      mmc2def.asm):00120         ;// this also allows us to BMI on error.
                      (      mmc2def.asm):00121         ;//
                      (      mmc2def.asm):00122         ;// Multi-phase commands like getting directory entries return status 
                      (      mmc2def.asm):00123         ;// complete after each entry. On the last entry this is or'd with 
                      (      mmc2def.asm):00124         ;// STATUS_LAST.
                      (      mmc2def.asm):00125         ;//
     0080             (      mmc2def.asm):00126         STATUS_ERROR                    equ $80
     0040             (      mmc2def.asm):00127         STATUS_COMPLETE                 equ $40
                      (      mmc2def.asm):00128         
     007F             (      mmc2def.asm):00129         ERROR_MASK                          equ $7F
                      (      mmc2def.asm):00130         
                      (      mmc2def.asm):00131         ;// To be or'd with STATUS_COMPLETE
     0001             (      mmc2def.asm):00132         STATUS_LAST                         equ $01
                      (      mmc2def.asm):00133         
                      (      mmc2def.asm):00134         ; FATFS Errors 
     0000             (      mmc2def.asm):00135         FR_OK                               equ $00     ; /* (0) Succeeded */
     0001             (      mmc2def.asm):00136         FR_DISK_ERR                         equ $01 ; /* (1) A hard error occured in the low level disk I/O layer */
     0002             (      mmc2def.asm):00137         FR_INT_ERR                          equ $02 ; /* (2) Assertion failed */
     0003             (      mmc2def.asm):00138         FR_NOT_READY                    equ $03 ; /* (3) The physical drive cannot work */
     0004             (      mmc2def.asm):00139         FR_NO_FILE                          equ $04 ; /* (4) Could not find the file */
     0005             (      mmc2def.asm):00140         FR_NO_PATH                          equ $05 ; /* (5) Could not find the path */
     0006             (      mmc2def.asm):00141         FR_INVALID_NAME                 equ $06 ; /* (6) The path name format is invalid */
     0007             (      mmc2def.asm):00142         FR_DENIED                           equ $07 ; /* (7) Acces denied due to prohibited access or directory full */
     0008             (      mmc2def.asm):00143         FR_EXIST                            equ $08 ; /* (8) Acces denied due to prohibited access */
     0009             (      mmc2def.asm):00144         FR_INVALID_OBJECT               equ $09 ; /* (9) The file/directory object is invalid */
     000A             (      mmc2def.asm):00145         FR_WRITE_PROTECTED              equ $0A ; /* (10) The physical drive is write protected */
     000B             (      mmc2def.asm):00146         FR_INVALID_DRIVE                equ $0B ; /* (11) The logical drive number is invalid */
     000C             (      mmc2def.asm):00147         FR_NOT_ENABLED                  equ $0C ; /* (12) The volume has no work area */
     000D             (      mmc2def.asm):00148         FR_NO_FILESYSTEM                equ $0D ; /* (13) There is no valid FAT volume */
     000E             (      mmc2def.asm):00149         FR_MKFS_ABORTED                 equ $0E ; /* (14) The f_mkfs() aborted due to any parameter error */
     000F             (      mmc2def.asm):00150         FR_TIMEOUT                          equ $0F ; /* (15) Could not get a grant to access the volume within defined period */
     0010             (      mmc2def.asm):00151         FR_LOCKED                           equ $10 ; /* (16) The operation is rejected according to the file shareing policy */
     0011             (      mmc2def.asm):00152         FR_NOT_ENOUGH_CORE              equ $11 ; /* (17) LFN working buffer could not be allocated */
     0012             (      mmc2def.asm):00153         FR_TOO_MANY_OPEN_FILES  equ $12 ; /* (18) Number of open files > _FS_SHARE */
     0013             (      mmc2def.asm):00154         FR_INVALID_PARAMETER    equ $13 ; /* (19) Given parameter is invalid */
                      (      mmc2def.asm):00155                 
                      (      mmc2def.asm):00156         ; // To be or'd with STATUS_ERROR
     0020             (      mmc2def.asm):00157         ERROR_INVALID_CMD               equ $20
     0021             (      mmc2def.asm):00158         ERROR_INVALID_IMAGE             equ $21
     0022             (      mmc2def.asm):00159         ERROR_NO_DATA           equ $22
     0023             (      mmc2def.asm):00160         ERROR_INVALID_DRIVE     equ $23
     0024             (      mmc2def.asm):00161         ERROR_READ_ONLY         equ $24
     0025             (      mmc2def.asm):00162         ERROR_ALREADY_MOUNT     equ $25
     0026             (      mmc2def.asm):00163         ERROR_INVALID_TIME      equ $26
     0027             (      mmc2def.asm):00164         ERROR_INVALID_FID               equ $27
     0028             (      mmc2def.asm):00165         ERROR_INVALID_PARAM             equ $28
     0029             (      mmc2def.asm):00166         ERROR_NO_FREE_FID               equ $29
                      (      mmc2def.asm):00167         
                      (      mmc2def.asm):00168         ; // Config bit flags (system)
     0080             (      mmc2def.asm):00169         CFG_ENABLE_BOOTLOAD             equ $80 
     0004             (      mmc2def.asm):00170         CFG_BACKUP_FILE                 equ     $04
     0002             (      mmc2def.asm):00171         CFG_HIDE_MAC            equ $02
     0001             (      mmc2def.asm):00172         CFG_DEBUG_LOG               equ $01
                      (      mmc2def.asm):00173         
                      (      mmc2def.asm):00174         ; // Config bit flags (Dragon, CoCo)
                      (      mmc2def.asm):00175         
     0040             (      mmc2def.asm):00176         CFG_ENABLE_AUTOBOOT             equ $40
     0020             (      mmc2def.asm):00177         CFG_ENABLE_DOS                  equ $20
     0010             (      mmc2def.asm):00178         CFG_SHOW_DATETIME       equ $10
     0008             (      mmc2def.asm):00179         CFG_SHOW_COMPILE        equ $08
                      (      mmc2def.asm):00180         
                      (      mmc2def.asm):00181         ; File ids....
     0006             (      mmc2def.asm):00182         NO_FILES                                equ 6
     0000             (      mmc2def.asm):00183         CAS_FILE                                equ     0
                      (    DragonMMC.asm):00117                                 use             DragonMMCdef.asm
     FF00             ( DragonMMCdef.asm):00001         IO_BASE                         EQU             $ff00                                   ; I/O Page
     0050             ( DragonMMCdef.asm):00002         DP_REG_BASE                 EQU     $50                                 ; MMC reg base (DP offset)
                      ( DragonMMCdef.asm):00003         
     0050             ( DragonMMCdef.asm):00004         DP_D_CMD_REG            EQU         DP_REG_BASE+CMD_REG         ; command register
     0051             ( DragonMMCdef.asm):00005         DP_D_LATCH_REG          EQU         DP_REG_BASE+LATCH_REG           ; Latch register for command params
     0052             ( DragonMMCdef.asm):00006         DP_D_READ_DATA_REG      EQU     DP_REG_BASE+READ_DATA_REG       ; Read data register for AVR->Dragon
     0052             ( DragonMMCdef.asm):00007         DP_D_WRITE_DATA_REG     EQU         DP_REG_BASE+WRITE_DATA_REG  ; Write data reg for Dragon->AVR
                      ( DragonMMCdef.asm):00008         
     FF50             ( DragonMMCdef.asm):00009         D_CMD_REG                       EQU         IO_BASE+DP_D_CMD_REG            ; command register
     FF51             ( DragonMMCdef.asm):00010         D_LATCH_REG                     EQU         IO_BASE+DP_D_LATCH_REG          ; Latch register for command params
     FF52             ( DragonMMCdef.asm):00011         D_READ_DATA_REG         EQU     IO_BASE+DP_D_READ_DATA_REG      ; Read data register for AVR->Dragon
     FF52             ( DragonMMCdef.asm):00012         D_WRITE_DATA_REG        EQU         IO_BASE+DP_D_WRITE_DATA_REG ; Write data reg for Dragon->AVR
                      ( DragonMMCdef.asm):00013         
     0053             ( DragonMMCdef.asm):00014         DP_D_STATUS_REG         EQU         $53                                         ; Status register.
     FF53             ( DragonMMCdef.asm):00015         D_STATUS_REG            EQU         IO_BASE+DP_D_STATUS_REG             ; Status register.
                      ( DragonMMCdef.asm):00016         
                      ( DragonMMCdef.asm):00017         ;STATUS_FLAG_BUSY       EQU         $01                             ; AVR Busy (old)
     0080             ( DragonMMCdef.asm):00018         STATUS_FLAG_BUSY        EQU         $80                             ; Pico Busy (bmi...)
     0002             ( DragonMMCdef.asm):00019         STATUS_FLAG_READ        EQU         $02                             ; AVR has read our byte
     0004             ( DragonMMCdef.asm):00020         STATUS_FLAG_WRITTEN     EQU         $04                             ; AVR has written a byte
                      ( DragonMMCdef.asm):00021         
                      ( DragonMMCdef.asm):00022         ;
                      ( DragonMMCdef.asm):00023         ; The DragonMMC CPLD contains logic that allows reads from the PIA A side data register
                      ( DragonMMCdef.asm):00024         ; at $FF20 to be substituted with data comeing from the AVR. 
                      ( DragonMMCdef.asm):00025         ; This allows the AVR to generate an FSK'd signal that the default ROM will read
                      ( DragonMMCdef.asm):00026         ; as if it where coming from a real tape. This allows us to bootload the ROM flash program
                      ( DragonMMCdef.asm):00027         ; **BEFORE** the rom contains any valid code.
                      ( DragonMMCdef.asm):00028         ;
                      ( DragonMMCdef.asm):00029         ; Not used in Pico.
                      ( DragonMMCdef.asm):00030         
                      ( DragonMMCdef.asm):00031         ;DP_D_PIA_MAP        EQU     $55                        ; PIA MAP
                      ( DragonMMCdef.asm):00032         ;D_PIA_MAP           EQU     IO_BASE+DP_D_PIA_MAP       ; PIA MAP
                      ( DragonMMCdef.asm):00033         ;D_PIA_MAP_ENABLE    equ     $01                     ; Enable PIA map
                      ( DragonMMCdef.asm):00034         
                      ( DragonMMCdef.asm):00035         ;
                      ( DragonMMCdef.asm):00036         ; The DragonMMC board includes a 32K static RAM chip that can be mapped into the
                      ( DragonMMCdef.asm):00037         ; $8000-$FFEF area, which is normally occupied by the system and cartrige ROMS.
                      ( DragonMMCdef.asm):00038         ; This is done so that the roms can be copied accross and patched for MMC use without
                      ( DragonMMCdef.asm):00039         ; having to have an overlay rom, containing a patched copy of the Dragon's ROM, 
                      ( DragonMMCdef.asm):00040         ; this way I don't end up having to distribute Microsoft owned code.
                      ( DragonMMCdef.asm):00041         ;
                      ( DragonMMCdef.asm):00042         ; Shortly to be retired in favor of a command.
     0054             ( DragonMMCdef.asm):00043         DP_D_RAM_CTRL           EQU         $54                                 ; RAM control reg 
                      ( DragonMMCdef.asm):00044         
     FF54             ( DragonMMCdef.asm):00045         D_RAM_CTRL                  EQU     IO_BASE+DP_D_RAM_CTRL   ; RAM control reg
                      ( DragonMMCdef.asm):00046         
                      ( DragonMMCdef.asm):00047         ; D_RAM_CTRL bit encodings
                      ( DragonMMCdef.asm):00048         ; Not all of these are used in Pico implementation.
                      ( DragonMMCdef.asm):00049         
     0001             ( DragonMMCdef.asm):00050         D_RAM_ENABLE            EQU     $01                                 ; set to enable overlay ram, clear to disable
     0002             ( DragonMMCdef.asm):00051         D_RAM_VEC                   EQU     $02                             ; Read interrupt vectors from ROM (0) or RAM (1)
     0004             ( DragonMMCdef.asm):00052         D_FIRQ_ENABLE           EQU         $04                             ; Enable routing of clock to FIRQ for cart auto-start
     0008             ( DragonMMCdef.asm):00053         D_ROM_A14           EQU     $08                     ; A14 line to the rom, used to select Dragon (0) or CoCo (1)
                      ( DragonMMCdef.asm):00054         
     0010             ( DragonMMCdef.asm):00055         D_RAM_WP                    EQU     $10                             ; set to write protect ram, clear to write enable
     0020             ( DragonMMCdef.asm):00056         D_RAM_VEC_WP        EQU     $20                             ; Write protect area of RAM containing int vectors.
     0040             ( DragonMMCdef.asm):00057         D_NMI_ENABLE        EQU     $40                     ; Enable generation of NMI on snap button press.
                      ( DragonMMCdef.asm):00058         
     00F7             ( DragonMMCdef.asm):00059         D_SEL_DRAGON        EQU     $FF-D_ROM_A14           ; Select dragon
     0008             ( DragonMMCdef.asm):00060         D_SEL_COCO                  EQU     D_ROM_A14                   ; Select coco
                      ( DragonMMCdef.asm):00061         
                      ( DragonMMCdef.asm):00062         ;D_RAM_COLDBOOT      EQU     
                      ( DragonMMCdef.asm):00063         
                      ( DragonMMCdef.asm):00064         ;
                      ( DragonMMCdef.asm):00065         ; The DragonMMC CPLD contains logic that allows it to record writes to the SAM's write only
                      ( DragonMMCdef.asm):00066         ; configuration bits. This allows these to be saved and restored when a snapshot is created.
                      ( DragonMMCdef.asm):00067         ; Since there are 16 SAM control bits the register accupies 2 loacations MSB first, so may
                      ( DragonMMCdef.asm):00068         ; be loaded directly into a 16 bit register : D, X, Y, U, S.
                      ( DragonMMCdef.asm):00069         ;
                      ( DragonMMCdef.asm):00070         ; These are now handled by command CMD_GET_SAMBITS.
                      ( DragonMMCdef.asm):00071         
     0000             ( DragonMMCdef.asm):00072         PLAT_BOOTLOAD       EQU     $00                     ; Bootloader flags
     0001             ( DragonMMCdef.asm):00073         PLAT_DRAGON         EQU     $01                         ; Dragon platform
     0002             ( DragonMMCdef.asm):00074         PLAT_COCO                   EQU     $02                         ; CoCo platform
     00FF             ( DragonMMCdef.asm):00075         PLAT_INVALID        EQU     $FF                     ; Invalid platform flag
                      ( DragonMMCdef.asm):00076         
     0000             ( DragonMMCdef.asm):00077         PLAT_LOW            EQU     PLAT_BOOTLOAD           ; Lowest valid platform
     0002             ( DragonMMCdef.asm):00078         PLAT_HIGH           EQU     PLAT_COCO               ; Highest valid platform
                      ( DragonMMCdef.asm):00079         
     0600             ( DragonMMCdef.asm):00080         VarsBase                    EQU     $600                                ; base of vars
                      ( DragonMMCdef.asm):00081         
                      ( DragonMMCdef.asm):00082         ;NewUsrVec                  EQU     VarsBase+$00                    ; new USR vectors
     00EC             ( DragonMMCdef.asm):00083         NewUsrVec                   EQU     $EC                             ; Unused if dos not present.
                      ( DragonMMCdef.asm):00084         
     0024             ( DragonMMCdef.asm):00085         Dollar                      EQU     '$'
     003C             ( DragonMMCdef.asm):00086         BlkBegin                    EQU     '<'                             ; Cassette block begin byte
                      ( DragonMMCdef.asm):00087         ;SyncByte                   EQU     'U'                             ; Cassette sync byte
     0028             ( DragonMMCdef.asm):00088         OpenBrac                    EQU     '('                             ; Open bracket
     0029             ( DragonMMCdef.asm):00089         CloseBrac                   EQU     ')'                             ; Open bracket
     002C             ( DragonMMCdef.asm):00090         Comma                       EQU     ','                             ; Comma
                      ( DragonMMCdef.asm):00091         
                      ( DragonMMCdef.asm):00092         ; Offsets within file header, compatible with DragonDos/SuperDos
     0000             ( DragonMMCdef.asm):00093         HdrID55                     EQU     $00                             ; magic marker byte #1
     0001             ( DragonMMCdef.asm):00094         HdrType                     EQU     $01                             ; file type see filetypes below
     0002             ( DragonMMCdef.asm):00095         HdrLoad                     EQU     $02                             ; Load address of file
     0004             ( DragonMMCdef.asm):00096         HdrLen                      EQU     $04                             ; length of file
     0006             ( DragonMMCdef.asm):00097         HdrExec                     EQU     $06                             ; entry address of file
     0008             ( DragonMMCdef.asm):00098         HdrIDAA                     EQU     $08                             ; magic marker byte #2
                      ( DragonMMCdef.asm):00099         
     0009             ( DragonMMCdef.asm):00100         FileHeadLen                 EQU     $09
                      ( DragonMMCdef.asm):00101         
                      ( DragonMMCdef.asm):00102         ; File types
                      ( DragonMMCdef.asm):00103         
     0001             ( DragonMMCdef.asm):00104         FTypeBas                    EQU     $01                             ; Basic files
     0002             ( DragonMMCdef.asm):00105         FTypeBin                    EQU     $02                             ; Binary file types
                      ( DragonMMCdef.asm):00106         
                      ( DragonMMCdef.asm):00107         ; Marker bytes
     0055             ( DragonMMCdef.asm):00108         MarkerHeadStart     EQU     $55
     00AA             ( DragonMMCdef.asm):00109         MarkerHeadEnd       EQU     $AA
                      ( DragonMMCdef.asm):00110         
                      ( DragonMMCdef.asm):00111         ; Tempory vars
                      ( DragonMMCdef.asm):00112         
     0076             ( DragonMMCdef.asm):00113         CFGByte                     EQU     BasUnused1                  ; put it in unused byte at $76
                      ( DragonMMCdef.asm):00114         
     2112             ( DragonMMCdef.asm):00115         SignatureWord           EQU         $2112
                      (    DragonMMC.asm):00118                                 use             BasicTokens.asm
                      (  BasicTokens.asm):00001         ;
                      (  BasicTokens.asm):00002         ; BasicTokens.asm
                      (  BasicTokens.asm):00003         ;
                      (  BasicTokens.asm):00004         ; Values for Dragon and CoCo basic tokens.
                      (  BasicTokens.asm):00005         ;
                      (  BasicTokens.asm):00006         
                      (  BasicTokens.asm):00007         ;
                      (  BasicTokens.asm):00008         ; Dragon Commands
                      (  BasicTokens.asm):00009         ;
                      (  BasicTokens.asm):00010         
     0080             (  BasicTokens.asm):00011         DTokFOR         EQU     $80
     0081             (  BasicTokens.asm):00012         DTokGO          EQU     $81
     0082             (  BasicTokens.asm):00013         DTokREM         EQU     $82
     0083             (  BasicTokens.asm):00014         DTokREMComma    EQU     $83
     0084             (  BasicTokens.asm):00015         DTokELSE        EQU     $84
     0085             (  BasicTokens.asm):00016         DTokIF          EQU     $85
     0086             (  BasicTokens.asm):00017         DTokDATA        EQU     $86
     0087             (  BasicTokens.asm):00018         DTokPRINT       EQU     $87
     0088             (  BasicTokens.asm):00019         DTokON          EQU     $88
     0089             (  BasicTokens.asm):00020         DTokINPUT       EQU     $89
     008A             (  BasicTokens.asm):00021         DTokEND         EQU     $8A
     008B             (  BasicTokens.asm):00022         DTokNEXT        EQU     $8B
     008C             (  BasicTokens.asm):00023         DTokDIM         EQU     $8C
     008D             (  BasicTokens.asm):00024         DTokREAD        EQU     $8D
     008E             (  BasicTokens.asm):00025         DTokLET         EQU     $8E
     008F             (  BasicTokens.asm):00026         DTokRUN         EQU     $8F
     0090             (  BasicTokens.asm):00027         DTokRESTORE     EQU     $90
     0091             (  BasicTokens.asm):00028         DTokRETURN      EQU     $91
     0092             (  BasicTokens.asm):00029         DTokSTOP        EQU     $92
     0093             (  BasicTokens.asm):00030         DTokPOKE        EQU     $93
     0094             (  BasicTokens.asm):00031         DTokCONT        EQU     $94
     0095             (  BasicTokens.asm):00032         DTokLIST        EQU     $95
     0096             (  BasicTokens.asm):00033         DTokCLEAR       EQU     $96
     0097             (  BasicTokens.asm):00034         DTokNEW         EQU     $97
     0098             (  BasicTokens.asm):00035         DTokDEF         EQU     $98
     0099             (  BasicTokens.asm):00036         DTokCLOAD       EQU     $99
     009A             (  BasicTokens.asm):00037         DTokCSAVE       EQU     $9A
     009B             (  BasicTokens.asm):00038         DTokOPEN        EQU     $9B
     009C             (  BasicTokens.asm):00039         DTokCLOSE       EQU     $9C
     009D             (  BasicTokens.asm):00040         DTokLLIST       EQU     $9D
     009E             (  BasicTokens.asm):00041         DTokSET         EQU     $9E
     009F             (  BasicTokens.asm):00042         DTokRESET       EQU     $9F
     00A0             (  BasicTokens.asm):00043         DTokCLS         EQU     $A0
     00A1             (  BasicTokens.asm):00044         DTokMOTOR       EQU     $A1
     00A2             (  BasicTokens.asm):00045         DTokSOUND       EQU     $A2
     00A3             (  BasicTokens.asm):00046         DTokAUDIO       EQU     $A3
     00A4             (  BasicTokens.asm):00047         DTokEXEC        EQU     $A4
     00A5             (  BasicTokens.asm):00048         DTokSKIPF       EQU     $A5
     00A6             (  BasicTokens.asm):00049         DTokDELETE      EQU     $A6
     00A7             (  BasicTokens.asm):00050         DTokEDIT        EQU     $A7
     00A8             (  BasicTokens.asm):00051         DTokTRON        EQU     $A8
     00A9             (  BasicTokens.asm):00052         DTokTROFF       EQU     $A9
     00AA             (  BasicTokens.asm):00053         DTokLINE        EQU     $AA
     00AB             (  BasicTokens.asm):00054         DTokPCLS        EQU     $AB
     00AC             (  BasicTokens.asm):00055         DTokPSET        EQU     $AC
     00AD             (  BasicTokens.asm):00056         DTokPRESET      EQU     $AD
     00AE             (  BasicTokens.asm):00057         DTokSCREEN      EQU     $AE
     00AF             (  BasicTokens.asm):00058         DTokPCLEAR      EQU     $AF
     00B0             (  BasicTokens.asm):00059         DTokCOLOR       EQU     $B0
     00B1             (  BasicTokens.asm):00060         DTokCIRCLE      EQU     $B1
     00B2             (  BasicTokens.asm):00061         DTokPAINT       EQU     $B2
     00B3             (  BasicTokens.asm):00062         DTokGET         EQU     $B3
     00B4             (  BasicTokens.asm):00063         DTokPUT         EQU     $B4
     00B5             (  BasicTokens.asm):00064         DTokDRAW        EQU     $B5
     00B6             (  BasicTokens.asm):00065         DTokPCOPY       EQU     $B6
     00B7             (  BasicTokens.asm):00066         DTokPMODE       EQU     $B7
     00B8             (  BasicTokens.asm):00067         DTokPLAY        EQU     $B8
     00B9             (  BasicTokens.asm):00068         DTokDLOAD       EQU     $B9
     00BA             (  BasicTokens.asm):00069         DTokRENUM       EQU     $BA
     00BB             (  BasicTokens.asm):00070         DTokTAB         EQU     $BB
     00BC             (  BasicTokens.asm):00071         DTokTO          EQU     $BC
     00BD             (  BasicTokens.asm):00072         DTokSUB         EQU     $BD
     00BE             (  BasicTokens.asm):00073         DTokFN          EQU     $BE
     00BF             (  BasicTokens.asm):00074         DTokTHEN        EQU     $BF
     00C0             (  BasicTokens.asm):00075         DTokNOT         EQU     $C0
     00C1             (  BasicTokens.asm):00076         DTokSTEP        EQU     $C1
     00C2             (  BasicTokens.asm):00077         DTokOFF         EQU     $C2
     00C3             (  BasicTokens.asm):00078         DTokPLUS        EQU     $C3
     00C4             (  BasicTokens.asm):00079         DTokMINUS       EQU     $C4
     00C5             (  BasicTokens.asm):00080         DTokTIMES       EQU     $C5
     00C6             (  BasicTokens.asm):00081         DTokDIVIDE      EQU     $C6
     00C7             (  BasicTokens.asm):00082         DTokAT          EQU     $C7
     00C8             (  BasicTokens.asm):00083         DTokAND         EQU     $C8
     00C9             (  BasicTokens.asm):00084         DTokOR          EQU     $C9
     00CA             (  BasicTokens.asm):00085         DTokGREATER     EQU     $CA
     00CB             (  BasicTokens.asm):00086         DTokEQUAL       EQU     $CB
     00CC             (  BasicTokens.asm):00087         DTokLESS        EQU     $CC
     00CD             (  BasicTokens.asm):00088         DTokUSING       EQU     $CD
                      (  BasicTokens.asm):00089         
                      (  BasicTokens.asm):00090         ;
                      (  BasicTokens.asm):00091         ; Dragon Functions
                      (  BasicTokens.asm):00092         ; Tokens are preceeded by $FF
                      (  BasicTokens.asm):00093         ;
                      (  BasicTokens.asm):00094         
     0080             (  BasicTokens.asm):00095         DTokSGN         EQU     $80
     0081             (  BasicTokens.asm):00096         DTokINT         EQU     $81
     0082             (  BasicTokens.asm):00097         DTokABS         EQU     $82
     0083             (  BasicTokens.asm):00098         DTokPOS         EQU     $83
     0084             (  BasicTokens.asm):00099         DTokRND         EQU     $84
     0085             (  BasicTokens.asm):00100         DTokSQR         EQU     $85
     0086             (  BasicTokens.asm):00101         DTokLOG         EQU     $86
     0087             (  BasicTokens.asm):00102         DTokEXP         EQU     $87
     0088             (  BasicTokens.asm):00103         DTokSIN         EQU     $88
     0089             (  BasicTokens.asm):00104         DTokCOS         EQU     $89
     008A             (  BasicTokens.asm):00105         DTokTAN         EQU     $8A
     008B             (  BasicTokens.asm):00106         DTokATN         EQU     $8B
     008C             (  BasicTokens.asm):00107         DTokPEEK        EQU     $8C
     008D             (  BasicTokens.asm):00108         DTokLEN         EQU     $8D
     008E             (  BasicTokens.asm):00109         DTokSTRS        EQU     $8E
     008F             (  BasicTokens.asm):00110         DTokVAL         EQU     $8F
     0090             (  BasicTokens.asm):00111         DTokASC         EQU     $90
     0091             (  BasicTokens.asm):00112         DTokCHRS        EQU     $91
     0092             (  BasicTokens.asm):00113         DTokEOF         EQU     $92
     0093             (  BasicTokens.asm):00114         DTokJOYSTK      EQU     $93
     0094             (  BasicTokens.asm):00115         DTokFIX         EQU     $94
     0095             (  BasicTokens.asm):00116         DTokHEXS        EQU     $95
     0096             (  BasicTokens.asm):00117         DTokLEFTS       EQU     $96
     0097             (  BasicTokens.asm):00118         DTokRIGHTS      EQU     $97
     0098             (  BasicTokens.asm):00119         DTokMIDS        EQU     $98
     0099             (  BasicTokens.asm):00120         DTokPOINT       EQU     $99
     009A             (  BasicTokens.asm):00121         DTokINKEYS      EQU     $9A
     009B             (  BasicTokens.asm):00122         DTokMEM         EQU     $9B
     009C             (  BasicTokens.asm):00123         DTokVARPTR      EQU     $9C
     009D             (  BasicTokens.asm):00124         DTokINSTR       EQU     $9D
     009E             (  BasicTokens.asm):00125         DTokTIMER       EQU     $9E
     009F             (  BasicTokens.asm):00126         DTokPPOINT      EQU     $9F
     00A0             (  BasicTokens.asm):00127         DTokSTRINGS     EQU     $A0
     00A1             (  BasicTokens.asm):00128         DTokUSR         EQU     $A1
                      (  BasicTokens.asm):00129         
                      (  BasicTokens.asm):00130         ;
                      (  BasicTokens.asm):00131         ; DragonDOS / SuperDOS command tokens
                      (  BasicTokens.asm):00132         ;
     00CE             (  BasicTokens.asm):00133         DDTokAUTO       EQU     $CE     
     00CE             (  BasicTokens.asm):00134         DDTokBACKUP     EQU     $CE
     00D0             (  BasicTokens.asm):00135         DDTokBEEP       EQU     $D0
     00D1             (  BasicTokens.asm):00136         DDTokBOOT       EQU     $D1
     00D2             (  BasicTokens.asm):00137         DDTokCHAIN      EQU     $D2
     00D3             (  BasicTokens.asm):00138         DDTokCOPY       EQU     $D3
     00D4             (  BasicTokens.asm):00139         DDTokCREATE     EQU     $D4
     00D5             (  BasicTokens.asm):00140         DDTokDIR        EQU     $D5
     00D6             (  BasicTokens.asm):00141         DDTokDRIVE      EQU     $D6
     00D7             (  BasicTokens.asm):00142         DDTokDSKINIT    EQU     $D7
     00D8             (  BasicTokens.asm):00143         DDTokFREAD      EQU     $D8
     00D9             (  BasicTokens.asm):00144         DDTokFWRITE     EQU     $D9
     00DA             (  BasicTokens.asm):00145         DDTokERROR      EQU     $DA
     00DB             (  BasicTokens.asm):00146         DDTokKILL       EQU     $DB
     00DC             (  BasicTokens.asm):00147         DDTokLOAD       EQU     $DC
     00DD             (  BasicTokens.asm):00148         DDTokMERGE      EQU     $DD
     00DE             (  BasicTokens.asm):00149         DDTokPROTECT    EQU     $DE
     00DF             (  BasicTokens.asm):00150         DDTokWAIT       EQU     $DF
     00E0             (  BasicTokens.asm):00151         DDTokRENAME     EQU     $E0
     00E1             (  BasicTokens.asm):00152         DDTokSAVE       EQU     $E1
     00E2             (  BasicTokens.asm):00153         DDTokSREAD      EQU     $E2
     00E3             (  BasicTokens.asm):00154         DDTokSWRITE     EQU     $E3
     00E4             (  BasicTokens.asm):00155         DDTokVERIFY     EQU     $E4
     00E5             (  BasicTokens.asm):00156         DDTokFROM       EQU     $E5
     00E6             (  BasicTokens.asm):00157         DDTokFLREAD     EQU     $E6
     00E7             (  BasicTokens.asm):00158         DDTokSWAP       EQU     $E7
                      (  BasicTokens.asm):00159         
     00CE             (  BasicTokens.asm):00160         DDTokFirstC     EQU     DDTokAUTO       ; First + Last Dragondos command Token
     00E7             (  BasicTokens.asm):00161         DDTokLastC      EQU     DDTokSWAP
     001A             (  BasicTokens.asm):00162         DDTokCountC     EQU     (DDTokLastC-DDTokFirstC)+1
                      (  BasicTokens.asm):00163         ;
                      (  BasicTokens.asm):00164         ; DragonDOS / SuperDOS function tokens
                      (  BasicTokens.asm):00165         ;
                      (  BasicTokens.asm):00166         
     00A2             (  BasicTokens.asm):00167         DDTokLOF        EQU     $A2
     00A3             (  BasicTokens.asm):00168         DDTokFREE       EQU     $A3
     00A4             (  BasicTokens.asm):00169         DDTokERL        EQU     $A4
     00A5             (  BasicTokens.asm):00170         DDTokERR        EQU     $A5
     00A6             (  BasicTokens.asm):00171         DDTokHIMEM      EQU     $A6
     00A7             (  BasicTokens.asm):00172         DDTokLOC        EQU     $A7
     00A8             (  BasicTokens.asm):00173         DDTokFRES       EQU     $A8
                      (  BasicTokens.asm):00174         
     00A2             (  BasicTokens.asm):00175         DDTokFirstF     EQU     DDTokLOF        ; First + Last Dragondos function Token
     00A8             (  BasicTokens.asm):00176         DDTokLastF      EQU     DDTokFRES
     0007             (  BasicTokens.asm):00177         DDTokCountF     EQU     (DDTokLastF-DDTokFirstF)+1
                      (  BasicTokens.asm):00178         
                      (  BasicTokens.asm):00179         ; CoCo 1/2 Commands
                      (  BasicTokens.asm):00180         ;
                      (  BasicTokens.asm):00181         
     0080             (  BasicTokens.asm):00182         CTokFOR         EQU     $80
     0081             (  BasicTokens.asm):00183         CTokGO          EQU     $81
     0082             (  BasicTokens.asm):00184         CTokREM         EQU     $82
     0083             (  BasicTokens.asm):00185         CTokREMComma    EQU     $83
     0084             (  BasicTokens.asm):00186         CTokELSE        EQU     $84
     0085             (  BasicTokens.asm):00187         CTokIF          EQU     $85
     0086             (  BasicTokens.asm):00188         CTokDATA        EQU     $86
     0087             (  BasicTokens.asm):00189         CTokPRINT       EQU     $87
     0088             (  BasicTokens.asm):00190         CTokON          EQU     $88
     0089             (  BasicTokens.asm):00191         CTokINPUT       EQU     $89
     008A             (  BasicTokens.asm):00192         CTokEND         EQU     $8A
     008B             (  BasicTokens.asm):00193         CTokNEXT        EQU     $8B
     008C             (  BasicTokens.asm):00194         CTokDIM         EQU     $8C
     008D             (  BasicTokens.asm):00195         CTokREAD        EQU     $8D
     00BA             (  BasicTokens.asm):00196         CTokLET         EQU     $BA
     008E             (  BasicTokens.asm):00197         CTokRUN         EQU     $8E
     008F             (  BasicTokens.asm):00198         CTokRESTORE     EQU     $8F
     0090             (  BasicTokens.asm):00199         CTokRETURN      EQU     $90
     0091             (  BasicTokens.asm):00200         CTokSTOP        EQU     $91
     0092             (  BasicTokens.asm):00201         CTokPOKE        EQU     $92
     0093             (  BasicTokens.asm):00202         CTokCONT        EQU     $93
     0094             (  BasicTokens.asm):00203         CTokLIST        EQU     $94
     0095             (  BasicTokens.asm):00204         CTokCLEAR       EQU     $95
     0096             (  BasicTokens.asm):00205         CTokNEW         EQU     $96
     00B9             (  BasicTokens.asm):00206         CTokDEF         EQU     $B9
     0097             (  BasicTokens.asm):00207         CTokCLOAD       EQU     $97
     0098             (  BasicTokens.asm):00208         CTokCSAVE       EQU     $98
     0099             (  BasicTokens.asm):00209         CTokOPEN        EQU     $99
     009A             (  BasicTokens.asm):00210         CTokCLOSE       EQU     $9A
     009B             (  BasicTokens.asm):00211         CTokLLIST       EQU     $9B
     009C             (  BasicTokens.asm):00212         CTokSET         EQU     $9C
     009D             (  BasicTokens.asm):00213         CTokRESET       EQU     $9D
     009E             (  BasicTokens.asm):00214         CTokCLS         EQU     $9E
     009F             (  BasicTokens.asm):00215         CTokMOTOR       EQU     $9F
     00A0             (  BasicTokens.asm):00216         CTokSOUND       EQU     $A0
     00A1             (  BasicTokens.asm):00217         CTokAUDIO       EQU     $A1
     00A2             (  BasicTokens.asm):00218         CTokEXEC        EQU     $A2
     00A3             (  BasicTokens.asm):00219         CTokSKIPF       EQU     $A3
     00B5             (  BasicTokens.asm):00220         CTokDELETE      EQU     $B5
     00B6             (  BasicTokens.asm):00221         CTokEDIT        EQU     $B6
     00B7             (  BasicTokens.asm):00222         CTokTRON        EQU     $B7
     00B8             (  BasicTokens.asm):00223         CTokTROFF       EQU     $B8
     00BB             (  BasicTokens.asm):00224         CTokLINE        EQU     $BB
     00BC             (  BasicTokens.asm):00225         CTokPCLS        EQU     $BC
     00BD             (  BasicTokens.asm):00226         CTokPSET        EQU     $BD
     00BE             (  BasicTokens.asm):00227         CTokPRESET      EQU     $BE
     00BF             (  BasicTokens.asm):00228         CTokSCREEN      EQU     $BF
     00C0             (  BasicTokens.asm):00229         CTokPCLEAR      EQU     $C0
     00C1             (  BasicTokens.asm):00230         CTokCOLOR       EQU     $C1
     00C2             (  BasicTokens.asm):00231         CTokCIRCLE      EQU     $C2
     00C3             (  BasicTokens.asm):00232         CTokPAINT       EQU     $C3
     00C4             (  BasicTokens.asm):00233         CTokGET         EQU     $C4
     00C5             (  BasicTokens.asm):00234         CTokPUT         EQU     $C5
     00C6             (  BasicTokens.asm):00235         CTokDRAW        EQU     $C6
     00C7             (  BasicTokens.asm):00236         CTokPCOPY       EQU     $C7
     00C8             (  BasicTokens.asm):00237         CTokPMODE       EQU     $C8
     00C9             (  BasicTokens.asm):00238         CTokPLAY        EQU     $C9
     00CA             (  BasicTokens.asm):00239         CTokDLOAD       EQU     $CA
     00CB             (  BasicTokens.asm):00240         CTokRENUM       EQU     $CB
     00A4             (  BasicTokens.asm):00241         CTokTAB         EQU     $A4
     00A5             (  BasicTokens.asm):00242         CTokTO          EQU     $A5
     00A6             (  BasicTokens.asm):00243         CTokSUB         EQU     $A6
     00CC             (  BasicTokens.asm):00244         CTokFN          EQU     $CC
     00A7             (  BasicTokens.asm):00245         CTokTHEN        EQU     $A7
     00A8             (  BasicTokens.asm):00246         CTokNOT         EQU     $A8
     00A9             (  BasicTokens.asm):00247         CTokSTEP        EQU     $A9
     00AA             (  BasicTokens.asm):00248         CTokOFF         EQU     $AA
     00AB             (  BasicTokens.asm):00249         CTokPLUS        EQU     $AB
     00AC             (  BasicTokens.asm):00250         CTokMINUS       EQU     $AC
     00AD             (  BasicTokens.asm):00251         CTokTIMES       EQU     $AD
     00AE             (  BasicTokens.asm):00252         CTokDIVIDE      EQU     $AE
     00AF             (  BasicTokens.asm):00253         CTokAT          EQU     $AF
     00B0             (  BasicTokens.asm):00254         CTokAND         EQU     $B0
     00B1             (  BasicTokens.asm):00255         CTokOR          EQU     $B1
     00B2             (  BasicTokens.asm):00256         CTokGREATER     EQU     $B2
     00B3             (  BasicTokens.asm):00257         CTokEQUAL       EQU     $B3
     00B4             (  BasicTokens.asm):00258         CTokLESS        EQU     $B4
     00CD             (  BasicTokens.asm):00259         CTokUSING       EQU     $CD
                      (  BasicTokens.asm):00260         
                      (  BasicTokens.asm):00261         ;
                      (  BasicTokens.asm):00262         ; CoCo 1/2 Functions
                      (  BasicTokens.asm):00263         ; Tokens are preceeded by $FF
                      (  BasicTokens.asm):00264         ;
                      (  BasicTokens.asm):00265         
     0080             (  BasicTokens.asm):00266         CTokSGN         EQU     $80
     0081             (  BasicTokens.asm):00267         CTokINT         EQU     $81
     0082             (  BasicTokens.asm):00268         CTokABS         EQU     $82
     009A             (  BasicTokens.asm):00269         CTokPOS         EQU     $9A
     0084             (  BasicTokens.asm):00270         CTokRND         EQU     $84
     009B             (  BasicTokens.asm):00271         CTokSQR         EQU     $9B
     0099             (  BasicTokens.asm):00272         CTokLOG         EQU     $99
     0097             (  BasicTokens.asm):00273         CTokEXP         EQU     $97
     0085             (  BasicTokens.asm):00274         CTokSIN         EQU     $85
     0095             (  BasicTokens.asm):00275         CTokCOS         EQU     $95
     0096             (  BasicTokens.asm):00276         CTokTAN         EQU     $96
     0094             (  BasicTokens.asm):00277         CTokATN         EQU     $94
     0086             (  BasicTokens.asm):00278         CTokPEEK        EQU     $86
     0087             (  BasicTokens.asm):00279         CTokLEN         EQU     $87
     0088             (  BasicTokens.asm):00280         CTokSTRS        EQU     $88
     0089             (  BasicTokens.asm):00281         CTokVAL         EQU     $89
     008A             (  BasicTokens.asm):00282         CTokASC         EQU     $8A
     008B             (  BasicTokens.asm):00283         CTokCHRS        EQU     $8B
     008C             (  BasicTokens.asm):00284         CTokEOF         EQU     $8C
     008D             (  BasicTokens.asm):00285         CTokJOYSTK      EQU     $8D
     0098             (  BasicTokens.asm):00286         CTokFIX         EQU     $98
     009C             (  BasicTokens.asm):00287         CTokHEXS        EQU     $9C
     008E             (  BasicTokens.asm):00288         CTokLEFTS       EQU     $8E
     008F             (  BasicTokens.asm):00289         CTokRIGHTS      EQU     $8F
     0090             (  BasicTokens.asm):00290         CTokMIDS        EQU     $90
     0091             (  BasicTokens.asm):00291         CTokPOINT       EQU     $91
     0092             (  BasicTokens.asm):00292         CTokINKEYS      EQU     $92
     0093             (  BasicTokens.asm):00293         CTokMEM         EQU     $93
     009D             (  BasicTokens.asm):00294         CTokVARPTR      EQU     $9D
     009E             (  BasicTokens.asm):00295         CTokINSTR       EQU     $9E
     009F             (  BasicTokens.asm):00296         CTokTIMER       EQU     $9F
     00A0             (  BasicTokens.asm):00297         CTokPPOINT      EQU     $A0
     00A1             (  BasicTokens.asm):00298         CTokSTRINGS     EQU     $A1
     0083             (  BasicTokens.asm):00299         CTokUSR         EQU     $83
                      (  BasicTokens.asm):00300         
                      (  BasicTokens.asm):00301         ;
                      (  BasicTokens.asm):00302         ; CoCo RS-DOS command tokens
                      (  BasicTokens.asm):00303         ;
                      (  BasicTokens.asm):00304         
     00CE             (  BasicTokens.asm):00305         CDTokDIR        EQU     $CE
     00CF             (  BasicTokens.asm):00306         CDTokDRIVE      EQU     $CF
     00D0             (  BasicTokens.asm):00307         CDTokFIELD      EQU     $D0
     00D1             (  BasicTokens.asm):00308         CDTokFILES      EQU     $D1
     00D2             (  BasicTokens.asm):00309         CDTokKILL       EQU     $D2
     00D3             (  BasicTokens.asm):00310         CDTokLOAD       EQU     $D3
     00D4             (  BasicTokens.asm):00311         CDTokLSET       EQU     $D4
     00D5             (  BasicTokens.asm):00312         CDTokMERGE      EQU     $D5
     00D6             (  BasicTokens.asm):00313         CDTokRENAME     EQU     $D6
     00D7             (  BasicTokens.asm):00314         CDTokRSET       EQU     $D7
     00D8             (  BasicTokens.asm):00315         CDTokSAVE       EQU     $D8
     00D9             (  BasicTokens.asm):00316         CDTokWRITE      EQU     $D9
     00DA             (  BasicTokens.asm):00317         CDTokVERIFY     EQU     $DA
     00DB             (  BasicTokens.asm):00318         CDTokUNLOAD     EQU     $DB
     00DC             (  BasicTokens.asm):00319         CDTokDSKINI     EQU     $DC
     00DD             (  BasicTokens.asm):00320         CDTokBACKUP     EQU     $DD
     00DE             (  BasicTokens.asm):00321         CDTokCOPY       EQU     $DE
     00DF             (  BasicTokens.asm):00322         CDTokDISKIS     EQU     $DF
     00E0             (  BasicTokens.asm):00323         CDTokDISKOS     EQU     $E0
                      (  BasicTokens.asm):00324         
     00CE             (  BasicTokens.asm):00325         CDTokFirstC     EQU     CDTokDIR        ; First RS-DOS command Token
     00E0             (  BasicTokens.asm):00326         CDTokLastC      EQU     CDTokDISKOS
     0013             (  BasicTokens.asm):00327         CDTokCountC     EQU     (CDTokLastC-CDTokFirstC)+1
                      (  BasicTokens.asm):00328         
                      (  BasicTokens.asm):00329         ;
                      (  BasicTokens.asm):00330         ; CoCo RS-DOS function tokens
                      (  BasicTokens.asm):00331         ;
                      (  BasicTokens.asm):00332         
     00A2             (  BasicTokens.asm):00333         CDTokCVN        EQU     $A2
     00A3             (  BasicTokens.asm):00334         CDTokFREE       EQU     $A3
     00A4             (  BasicTokens.asm):00335         CDTokLOC        EQU     $A4
     00A5             (  BasicTokens.asm):00336         CDTokLOF        EQU     $A5
     00A6             (  BasicTokens.asm):00337         CDTokMKNS       EQU     $A6
                      (  BasicTokens.asm):00338         
     00A2             (  BasicTokens.asm):00339         CDTokFirstF     EQU     CDTokCVN        ; First RS-DOS function Token
     00A6             (  BasicTokens.asm):00340         CDTokLastF      EQU     CDTokMKNS
     0005             (  BasicTokens.asm):00341         CDTokCountF     EQU     (CDTokLastF-CDTokFirstF)+1
                      (  BasicTokens.asm):00342         
                      (  BasicTokens.asm):00343         
                      (  BasicTokens.asm):00344                         ifdef   Dragon
                      (  BasicTokens.asm):00345         
0000                  (  BasicTokens.asm):00346         DOSTokFirstC    EQU     DDTokFirstC
0000                  (  BasicTokens.asm):00347         DOSTokLastC     EQU     DDTokLastC
0000                  (  BasicTokens.asm):00348         DOSTokCountC    EQU     DDTokCountC
                      (  BasicTokens.asm):00349         
0000                  (  BasicTokens.asm):00350         DOSTokFirstF    EQU     DDTokFirstF
0000                  (  BasicTokens.asm):00351         DOSTokLastF     EQU     DDTokLastF
0000                  (  BasicTokens.asm):00352         DOSTokCountF    EQU     DDTokCountF
                      (  BasicTokens.asm):00353                         else
                      (  BasicTokens.asm):00354         
     00CE             (  BasicTokens.asm):00355         DOSTokFirstC    EQU     CDTokFirstC
     00E0             (  BasicTokens.asm):00356         DOSTokLastC     EQU     CDTokLastC
     0013             (  BasicTokens.asm):00357         DOSTokCountC    EQU     CDTokCountC
                      (  BasicTokens.asm):00358         
     00A2             (  BasicTokens.asm):00359         DOSTokFirstF    EQU     CDTokFirstF
     00A6             (  BasicTokens.asm):00360         DOSTokLastF     EQU     CDTokLastF
     0005             (  BasicTokens.asm):00361         DOSTokCountF    EQU     CDTokCountF
                      (  BasicTokens.asm):00362                         endc
                      (  BasicTokens.asm):00363         
                      (    DragonMMC.asm):00119                                 use     BasicDefs.asm
                      (    BasicDefs.asm):00001         ;
                      (    BasicDefs.asm):00002         ; BasicDefs.asm : definitions for Dragon / CoCo BASIC.
                      (    BasicDefs.asm):00003         ;
                      (    BasicDefs.asm):00004         
     F9FF             (    BasicDefs.asm):00005         BasMaxLineNo    EQU     $F9FF   ; Maximum allowable line number.
                      (    BasicDefs.asm):00006         
                      (    BasicDefs.asm):00007         ;
                      (    BasicDefs.asm):00008         ; Dragon Basic Error codes
                      (    BasicDefs.asm):00009         ; 
     0000             (    BasicDefs.asm):00010         DBErrNF         EQU     $00             ; Next without for              
     0002             (    BasicDefs.asm):00011         DBErrSN         EQU     $02             ; Syntax
     0004             (    BasicDefs.asm):00012         DBErrRG         EQU     $04             ; Return without GOSUB
     0006             (    BasicDefs.asm):00013         DBErrOD         EQU     $06             ; Out of Data
     0008             (    BasicDefs.asm):00014         DBErrFC         EQU     $08             ; Function Call
     000A             (    BasicDefs.asm):00015         DBErrOV         EQU     $0A             ; OVerflow
     000C             (    BasicDefs.asm):00016         DBErrOM         EQU     $0C             ; Out of Memory
     000E             (    BasicDefs.asm):00017         DBErrUL         EQU     $0E             ; Undefined Line
     0010             (    BasicDefs.asm):00018         DBErrBS         EQU     $10             ; Bad Subscript
     0012             (    BasicDefs.asm):00019         DBErrDD         EQU     $12             ; Direct Dimension
     0014             (    BasicDefs.asm):00020         DBErrZD         EQU     $14             ; Zero Divide
     0016             (    BasicDefs.asm):00021         DBErrID         EQU     $16             ; Illegal Direct
     0018             (    BasicDefs.asm):00022         DBErrTM         EQU     $18             ; Type Mismatch
     001A             (    BasicDefs.asm):00023         DBErrOS         EQU     $1A             ; Out of String space
     001C             (    BasicDefs.asm):00024         DBErrLS         EQU     $1C             ; Long String (len > 255)
     001E             (    BasicDefs.asm):00025         DBErrST         EQU     $1E             ; String formula Too complex
     0020             (    BasicDefs.asm):00026         DBErrCN         EQU     $20             ; Can't coNtinue
     0022             (    BasicDefs.asm):00027         DBErrUF         EQU     $22             ; Undefined Function
     0024             (    BasicDefs.asm):00028         DBErrFD         EQU     $24             ; bad File Data
     0026             (    BasicDefs.asm):00029         DBErrAO         EQU     $26             ; Already Open
     0028             (    BasicDefs.asm):00030         DBErrDN         EQU     $28             ; Device Number
     002A             (    BasicDefs.asm):00031         DBErrIO         EQU     $2A             ; Input Output
     002C             (    BasicDefs.asm):00032         DBErrFM         EQU     $2C             ; File Mismatch
     002E             (    BasicDefs.asm):00033         DBErrNO         EQU     $2E             ; file Not Open
     0030             (    BasicDefs.asm):00034         DBErrIE         EQU     $30             ; Input past End of file
     0032             (    BasicDefs.asm):00035         DBErrDS         EQU     $32             ; Direct Statement
     0034             (    BasicDefs.asm):00036         DBErrNE         EQU     $34             ; file does Not Exist
                      (    BasicDefs.asm):00037         
                      (    BasicDefs.asm):00038         ;
                      (    BasicDefs.asm):00039         ; CoCo Basic Error codes.
                      (    BasicDefs.asm):00040         ;
                      (    BasicDefs.asm):00041         
     0000             (    BasicDefs.asm):00042         CBErrNF         EQU     $00             ; Next without for              
     0002             (    BasicDefs.asm):00043         CBErrSN         EQU     $02             ; Syntax
     0004             (    BasicDefs.asm):00044         CBErrRG         EQU     $04             ; Return without GOSUB
     0006             (    BasicDefs.asm):00045         CBErrOD         EQU     $06             ; Out of Data
     0008             (    BasicDefs.asm):00046         CBErrFC         EQU     $08             ; Function Call
     000A             (    BasicDefs.asm):00047         CBErrOV         EQU     $0A             ; OVerflow
     000C             (    BasicDefs.asm):00048         CBErrOM         EQU     $0C             ; Out of Memory
     000E             (    BasicDefs.asm):00049         CBErrUL         EQU     $0E             ; Undefined Line
     0010             (    BasicDefs.asm):00050         CBErrBS         EQU     $10             ; Bad Subscript
     0012             (    BasicDefs.asm):00051         CBErrDD         EQU     $12             ; Direct Dimension
     0014             (    BasicDefs.asm):00052         CBErrZD         EQU     $14             ; Zero Divide
     0016             (    BasicDefs.asm):00053         CBErrID         EQU     $16             ; Illegal Direct
     0018             (    BasicDefs.asm):00054         CBErrTM         EQU     $18             ; Type Mismatch
     001A             (    BasicDefs.asm):00055         CBErrOS         EQU     $1A             ; Out of String space
     001C             (    BasicDefs.asm):00056         CBErrLS         EQU     $1C             ; Long String (len > 255)
     001E             (    BasicDefs.asm):00057         CBErrST         EQU     $1E             ; String formula Too complex
     0020             (    BasicDefs.asm):00058         CBErrCN         EQU     $20             ; Can't coNtinue
                      (    BasicDefs.asm):00059         
     0022             (    BasicDefs.asm):00060         CBErrFD         EQU     $22             ; bad File Data
     0024             (    BasicDefs.asm):00061         CBErrAO         EQU     $24             ; Already Open
     0026             (    BasicDefs.asm):00062         CBErrDN         EQU     $26             ; Device Number
     0028             (    BasicDefs.asm):00063         CBErrIO         EQU     $28             ; Input Output
     002A             (    BasicDefs.asm):00064         CBErrFM         EQU     $2A             ; File Mismatch
     002C             (    BasicDefs.asm):00065         CBErrNO         EQU     $2C             ; file Not Open
     002E             (    BasicDefs.asm):00066         CBErrIE         EQU     $2E             ; Input past End of file
     0030             (    BasicDefs.asm):00067         CBErrDS         EQU     $30             ; Direct Statement
                      (    BasicDefs.asm):00068         
                      (    BasicDefs.asm):00069         ;
                      (    BasicDefs.asm):00070         ; CoCo Extended basic error codes
                      (    BasicDefs.asm):00071         ;
                      (    BasicDefs.asm):00072         
     0032             (    BasicDefs.asm):00073         CBErrUF         EQU     $32             ; Undefined Function
     0034             (    BasicDefs.asm):00074         CBErrNE         EQU     $34             ; file does Not Exist
                      (    BasicDefs.asm):00075         
                      (    BasicDefs.asm):00076                 ifdef   Dragon
0000                  (    BasicDefs.asm):00077         BErrNF          EQU     DBErrNF         ; Next without for              
0000                  (    BasicDefs.asm):00078         BErrSN          EQU     DBErrSN         ; Syntax
0000                  (    BasicDefs.asm):00079         BErrRG          EQU     DBErrRG         ; Return without GOSUB
0000                  (    BasicDefs.asm):00080         BErrOD          EQU     DBErrOD         ; Out of Data
0000                  (    BasicDefs.asm):00081         BErrFC          EQU     DBErrFC         ; Function Call
0000                  (    BasicDefs.asm):00082         BErrOV          EQU     DBErrOV         ; OVerflow
0000                  (    BasicDefs.asm):00083         BErrOM          EQU     DBErrOM         ; Out of Memory
0000                  (    BasicDefs.asm):00084         BErrUL          EQU     DBErrUL         ; Undefined Line
0000                  (    BasicDefs.asm):00085         BErrBS          EQU     DBErrBS         ; Bad Subscript
0000                  (    BasicDefs.asm):00086         BErrDD          EQU     DBErrDD         ; Direct Dimension
0000                  (    BasicDefs.asm):00087         BErrZD          EQU     DBErrZD         ; Zero Divide
0000                  (    BasicDefs.asm):00088         BErrID          EQU     DBErrID         ; Illegal Direct
0000                  (    BasicDefs.asm):00089         BErrTM          EQU     DBErrTM         ; Type Mismatch
0000                  (    BasicDefs.asm):00090         BErrOS          EQU     DBErrOS         ; Out of String space
0000                  (    BasicDefs.asm):00091         BErrLS          EQU     DBErrLS         ; Long String (len > 255)
0000                  (    BasicDefs.asm):00092         BErrST          EQU     DBErrST         ; String formula Too complex
0000                  (    BasicDefs.asm):00093         BErrCN          EQU     DBErrCN         ; Can't coNtinue
0000                  (    BasicDefs.asm):00094         BErrUF          EQU     DBErrUF         ; Undefined Function
0000                  (    BasicDefs.asm):00095         BErrFD          EQU     DBErrFD         ; bad File Data
0000                  (    BasicDefs.asm):00096         BErrAO          EQU     DBErrAO         ; Already Open
0000                  (    BasicDefs.asm):00097         BErrDN          EQU     DBErrDN         ; Device Number
0000                  (    BasicDefs.asm):00098         BErrIO          EQU     DBErrIO         ; Input Output
0000                  (    BasicDefs.asm):00099         BErrFM          EQU     DBErrFM         ; File Mismatch
0000                  (    BasicDefs.asm):00100         BErrNO          EQU     DBErrNO         ; file Not Open
0000                  (    BasicDefs.asm):00101         BErrIE          EQU     DBErrIE         ; Input past End of file
0000                  (    BasicDefs.asm):00102         BErrDS          EQU     DBErrDS         ; Direct Statement
0000                  (    BasicDefs.asm):00103         BErrNE          EQU     DBErrNE         ; file does Not Exist
                      (    BasicDefs.asm):00104                 else
     0000             (    BasicDefs.asm):00105         BErrNF          EQU     CBErrNF         ; Next without for              
     0002             (    BasicDefs.asm):00106         BErrSN          EQU     CBErrSN         ; Syntax
     0004             (    BasicDefs.asm):00107         BErrRG          EQU     CBErrRG         ; Return without GOSUB
     0006             (    BasicDefs.asm):00108         BErrOD          EQU     CBErrOD         ; Out of Data
     0008             (    BasicDefs.asm):00109         BErrFC          EQU     CBErrFC         ; Function Call
     000A             (    BasicDefs.asm):00110         BErrOV          EQU     CBErrOV         ; OVerflow
     000C             (    BasicDefs.asm):00111         BErrOM          EQU     CBErrOM         ; Out of Memory
     000E             (    BasicDefs.asm):00112         BErrUL          EQU     CBErrUL         ; Undefined Line
     0010             (    BasicDefs.asm):00113         BErrBS          EQU     CBErrBS         ; Bad Subscript
     0012             (    BasicDefs.asm):00114         BErrDD          EQU     CBErrDD         ; Direct Dimension
     0014             (    BasicDefs.asm):00115         BErrZD          EQU     CBErrZD         ; Zero Divide
     0016             (    BasicDefs.asm):00116         BErrID          EQU     CBErrID         ; Illegal Direct
     0018             (    BasicDefs.asm):00117         BErrTM          EQU     CBErrTM         ; Type Mismatch
     001A             (    BasicDefs.asm):00118         BErrOS          EQU     CBErrOS         ; Out of String space
     001C             (    BasicDefs.asm):00119         BErrLS          EQU     CBErrLS         ; Long String (len > 255)
     001E             (    BasicDefs.asm):00120         BErrST          EQU     CBErrST         ; String formula Too complex
     0020             (    BasicDefs.asm):00121         BErrCN          EQU     CBErrCN         ; Can't coNtinue
     0032             (    BasicDefs.asm):00122         BErrUF          EQU     CBErrUF         ; Undefined Function
     0022             (    BasicDefs.asm):00123         BErrFD          EQU     CBErrFD         ; bad File Data
     0024             (    BasicDefs.asm):00124         BErrAO          EQU     CBErrAO         ; Already Open
     0026             (    BasicDefs.asm):00125         BErrDN          EQU     CBErrDN         ; Device Number
     0028             (    BasicDefs.asm):00126         BErrIO          EQU     CBErrIO         ; Input Output
     002A             (    BasicDefs.asm):00127         BErrFM          EQU     CBErrFM         ; File Mismatch
     002C             (    BasicDefs.asm):00128         BErrNO          EQU     CBErrNO         ; file Not Open
     002E             (    BasicDefs.asm):00129         BErrIE          EQU     CBErrIE         ; Input past End of file
     0030             (    BasicDefs.asm):00130         BErrDS          EQU     CBErrDS         ; Direct Statement
     0034             (    BasicDefs.asm):00131         BErrNE          EQU     CBErrNE         ; file does Not Exist
                      (    BasicDefs.asm):00132                 endc
                      (    DragonMMC.asm):00120                                 use             samdefs.asm
                      (      samdefs.asm):00001         ;
                      (      samdefs.asm):00002         ; SAM Defs.
                      (      samdefs.asm):00003         ;
                      (      samdefs.asm):00004         
     FFE0             (      samdefs.asm):00005         SAMVectors      equ             $FFE0                   ; SAM vector block at top of memory map
     0020             (      samdefs.asm):00006         SAMVecSize      equ             $20                             ; SAM vector block size
                      (      samdefs.asm):00007         
     FFC0             (      samdefs.asm):00008         SAMBase         equ             $FFC0                   ; Base of SAM bits
                      (      samdefs.asm):00009         
                      (      samdefs.asm):00010         ; V2 V1 V0      Mode(s)
                      (      samdefs.asm):00011         ;  0  0  0      AL, AE, S4, S6
                      (      samdefs.asm):00012         ;  0  0  1      G1C, G1R
                      (      samdefs.asm):00013         ;  0  1  0      G2C
                      (      samdefs.asm):00014         ;  0  1  1      G2R
                      (      samdefs.asm):00015         ;  1  0  0      G3C
                      (      samdefs.asm):00016         ;  1  0  1      G3R
                      (      samdefs.asm):00017         ;  1  1  0      G6C, G6R
                      (      samdefs.asm):00018         ;  1  1  1      DMA
                      (      samdefs.asm):00019         
     FFC0             (      samdefs.asm):00020         SAMCV0          equ             $FFC0                   ; Video mode bits
     FFC1             (      samdefs.asm):00021         SAMSV0          equ             $FFC1
     FFC2             (      samdefs.asm):00022         SAMCV1          equ             $FFC2
     FFC3             (      samdefs.asm):00023         SAMSV1          equ             $FFC3
     FFC4             (      samdefs.asm):00024         SAMCV2          equ             $FFC4
     FFC5             (      samdefs.asm):00025         SAMSV2          equ             $FFC5
                      (      samdefs.asm):00026         
                      (      samdefs.asm):00027         ;
                      (      samdefs.asm):00028         ; Binary offset from $0000, in 512 byte pages.
                      (      samdefs.asm):00029         ;
                      (      samdefs.asm):00030         
     FFC6             (      samdefs.asm):00031         SAMCF0          equ             $FFC6                   ; Display offset
     FFC7             (      samdefs.asm):00032         SAMSF0          equ             $FFC7
     FFC8             (      samdefs.asm):00033         SAMCF1          equ             $FFC8
     FFC9             (      samdefs.asm):00034         SAMSF1          equ             $FFC9
     FFCA             (      samdefs.asm):00035         SAMCF2          equ             $FFCA
     FFCB             (      samdefs.asm):00036         SAMSF2          equ             $FFCB
     FFCC             (      samdefs.asm):00037         SAMCF3          equ             $FFCC
     FFCD             (      samdefs.asm):00038         SAMSF3          equ             $FFCD
     FFCE             (      samdefs.asm):00039         SAMCF4          equ             $FFCE
     FFCF             (      samdefs.asm):00040         SAMSF4          equ             $FFCF
     FFD0             (      samdefs.asm):00041         SAMCF5          equ             $FFD0
     FFD1             (      samdefs.asm):00042         SAMSF5          equ             $FFD1
     FFD2             (      samdefs.asm):00043         SAMCF6          equ             $FFD2
     FFD3             (      samdefs.asm):00044         SAMSF6          equ             $FFD3
                      (      samdefs.asm):00045         
                      (      samdefs.asm):00046         ; Maps 2 pages of 32K into $0000-$7FFF, requires 64K RAM.
                      (      samdefs.asm):00047         
     FFD4             (      samdefs.asm):00048         SAMCP1          equ             $FFD4                   ; Page #1
     FFD5             (      samdefs.asm):00049         SAMSP1          equ             $FFD5
                      (      samdefs.asm):00050         
                      (      samdefs.asm):00051         ; R1 R0
                      (      samdefs.asm):00052         ;  0  0         Slow, 0.89MHz 
                      (      samdefs.asm):00053         ;  0  1         Address dependent 1.7MHz / 0.89MHz
                      (      samdefs.asm):00054         ;  1  0         Fast
                      (      samdefs.asm):00055         ;  1  1         Fast
                      (      samdefs.asm):00056         
     FFD6             (      samdefs.asm):00057         SAMCR0          equ             $FFD6                   ; CPU Rate
     FFD7             (      samdefs.asm):00058         SAMSR0          equ             $FFD7
     FFD8             (      samdefs.asm):00059         SAMCR1          equ             $FFD8
     FFD9             (      samdefs.asm):00060         SAMSR2          equ             $FFD9
                      (      samdefs.asm):00061         
                      (      samdefs.asm):00062         ; M1 M0
                      (      samdefs.asm):00063         ;  0  0          4K dynamic
                      (      samdefs.asm):00064         ;  0  1         16K dynamic
                      (      samdefs.asm):00065         ;  1  0         64K dynamic
                      (      samdefs.asm):00066         ;  1  1         64K static
                      (      samdefs.asm):00067         
     FFDA             (      samdefs.asm):00068         SAMCM0          equ             $FFDA                   ; Memory type
     FFDB             (      samdefs.asm):00069         SAMSM0          equ             $FFDB
     FFDC             (      samdefs.asm):00070         SAMCM1          equ             $FFDC
     FFDD             (      samdefs.asm):00071         SAMSM1          equ             $FFDD
                      (      samdefs.asm):00072         
                      (      samdefs.asm):00073         ; 0= RAM below 32K, ROM above, 1=RAM for entire map 
                      (      samdefs.asm):00074         ; In both map types top 256 bytes reserved for I/O space
                      (      samdefs.asm):00075         
     FFDE             (      samdefs.asm):00076         SAMCTY          equ             $FFDE                   ; Map type
     FFDF             (      samdefs.asm):00077         SAMSTY          equ             $FFDF
                      (      samdefs.asm):00078         
                      (      samdefs.asm):00079         
                      (      samdefs.asm):00080         
                      (      samdefs.asm):00081         
                      (    DragonMMC.asm):00121                                                 
                      (    DragonMMC.asm):00122                                 ORG     $C000
                      (    DragonMMC.asm):00123         
                      (    DragonMMC.asm):00124         
                      (    DragonMMC.asm):00125         ; Disk controler ID, if a cartrage starts with the chars 'DK', then the basic rom routines
                      (    DragonMMC.asm):00126         ; will do a JMP to $C002 to init the cartrage.
                      (    DragonMMC.asm):00127         
C000                  (    DragonMMC.asm):00128         __init
C000 444B             (    DragonMMC.asm):00129         DC000   FCC     /DK/                            
                      (    DragonMMC.asm):00130         
                      (    DragonMMC.asm):00131         ; Jump table.
C002 2008             (    DragonMMC.asm):00132         LC002   BRA    MMCInit
C004                  (    DragonMMC.asm):00133         __init_end
                      (    DragonMMC.asm):00134         
                      (    DragonMMC.asm):00135                         ifdef   BuildDos
                      (    DragonMMC.asm):00136                         ifdef   Dragon
                      (    DragonMMC.asm):00137                         use             dragondos_mmc.asm
                      (    DragonMMC.asm):00138                         endc
                      (    DragonMMC.asm):00139                         
                      (    DragonMMC.asm):00140                         ifdef   Tandy
                      (    DragonMMC.asm):00141                         use             rsdos_mmc.asm
C004                  (    rsdos_mmc.asm):00001         __rsdos
                      (    rsdos_mmc.asm):00002                         use     coco-defs.asm
     C000             (    coco-defs.asm):00001         rompak         equ     $c000                                      
                      (    coco-defs.asm):00002         
     0008             (    coco-defs.asm):00003         bs             equ     $08                      ; backspace                  
     000D             (    coco-defs.asm):00004         cr             equ     $0d                      ; enter key                   
     001B             (    coco-defs.asm):00005         esc            equ     $1b                      ; escape code                       
     000A             (    coco-defs.asm):00006         lf             equ     $0a                      ; line feed                   
     000C             (    coco-defs.asm):00007         formf          equ     $0c                      ; form feed                      
     0020             (    coco-defs.asm):00008         space          equ     $20                      ; space (blank)                           
                      (    coco-defs.asm):00009         
     003A             (    coco-defs.asm):00010         stkbuf         equ     58                       ; stack buffer room                               
     045E             (    coco-defs.asm):00011         debdel         equ     $45e                     ; debounce delay                              
     00FA             (    coco-defs.asm):00012         lbufmx         equ     250                      ; max number of chars in a basic line                                                  
     00FA             (    coco-defs.asm):00013         maxlin         equ     $fa                      ; maximum ms byte of line number                                             
                      (    coco-defs.asm):00014         
     2600             (    coco-defs.asm):00015         dosbuf         equ     $2600                    ; ram load location for the dos command                                                      
                      (    coco-defs.asm):00016         ;fatcon         equ     6                       ; number of control bytes before fat                                               
     0019             (    coco-defs.asm):00017         fcbcon         equ     25                       ; number of control bytes before fcb                                                
     0020             (    coco-defs.asm):00018         dirlen         equ     32                       ; number of bytes in directory entry                                                
     0100             (    coco-defs.asm):00019         seclen         equ     256                      ; length of sector in bytes                                        
     0012             (    coco-defs.asm):00020         secmax         equ     18                       ; maximum number of sectors per track                                                 
     1200             (    coco-defs.asm):00021         trklen         equ     secmax*seclen            ; length of track in bytes                                                   
     0023             (    coco-defs.asm):00022         trkmax         equ     35                       ; max number of tracks                                  
     004A             (    coco-defs.asm):00023         fatlen         equ     ((trkmax-1)*2)+6         ; file allocation table length                                                     
     0044             (    coco-defs.asm):00024         granmx         equ     (trkmax-1)*2             ; maximum number of granules                                                     
     0119             (    coco-defs.asm):00025         fcblen         equ     seclen+25                ; file control block length                                              
     0010             (    coco-defs.asm):00026         inpfil         equ     $10                      ; input file type                              
     0020             (    coco-defs.asm):00027         outfil         equ     $20                      ; output file type                               
     0040             (    coco-defs.asm):00028         ranfil         equ     $40                      ; random/direct file type                                      
                      (    coco-defs.asm):00029         
     0062             (    coco-defs.asm):00030         ressgn          equ     $62                     ; sign of result of floating point operation
     0070             (    coco-defs.asm):00031         cinbfl          equ     $0070                   ;pv console in buffer flag: 00=not empty, $ff=empty                                                              
                      (    coco-defs.asm):00032         
                      (    coco-defs.asm):00033         
                      (    coco-defs.asm):00034         ; extended basic scratch pad variables
     00CB             (    coco-defs.asm):00035         vcb             equ     $00CB
     00CD             (    coco-defs.asm):00036         vcd             equ     $00CD
     00CF             (    coco-defs.asm):00037         vcf             equ     $00CF
     00D1             (    coco-defs.asm):00038         vd1             equ     $00D1
     00D3             (    coco-defs.asm):00039         vd3             equ     $00D3
     00D4             (    coco-defs.asm):00040         vd4             equ     $00D4
     00D5             (    coco-defs.asm):00041         vd5             equ     $00D5
     00D6             (    coco-defs.asm):00042         vd6             equ     $00D6
     00D7             (    coco-defs.asm):00043         vd7             equ     $00D7
     00D8             (    coco-defs.asm):00044         vd8             equ     $00D8
     00D9             (    coco-defs.asm):00045         vd9             equ     $00D9
     00DA             (    coco-defs.asm):00046         vda             equ     $00DA
                      (    coco-defs.asm):00047         
                      (    coco-defs.asm):00048         ; dskcon variables
     00EA             (    coco-defs.asm):00049         dcopc           equ     $00EA                   ;pv dskcon operation code 0-3                                       
     00EB             (    coco-defs.asm):00050         dcdrv           equ     $00EB                   ;pv dskcon drive number 0-3                                     
     00EC             (    coco-defs.asm):00051         dctrk           equ     $00EC                   ;pv dskcon track number 0-34                                      
     00ED             (    coco-defs.asm):00052         dsec            equ     $00ED                   ;pv dskcon sector number 1-18                                      
     00EE             (    coco-defs.asm):00053         dcbpt           equ     $00EE                   ;pv dskcon data pointer                                 
     00F0             (    coco-defs.asm):00054         dcsta           equ     $00F0                   ;pv dskcon status byte                                
                      (    coco-defs.asm):00055         
     00F1             (    coco-defs.asm):00056         fcbtmp          equ     $00F1                   ; temporary fcb pointer                                  
                      (    coco-defs.asm):00057         
                      (    coco-defs.asm):00058         ;start of additional ram variable storage (disk basic only)
     0600             (    coco-defs.asm):00059         dbuf0           equ     $0600                   ; i/o buffer #0                              
     0700             (    coco-defs.asm):00060         dbuf1           equ     $0700                   ; i/o buffer #1                              
     0800             (    coco-defs.asm):00061         fatbl0          equ     $0800                   ; file allocation table - drive 0                                                 
     084A             (    coco-defs.asm):00062         fatbl1          equ     $084A                   ; file allocation table - drive 1                                                 
     0894             (    coco-defs.asm):00063         fatbl2          equ     $0894                   ; file allocation table - drive 2                                                 
     08DE             (    coco-defs.asm):00064         fatbl3          equ     $08DE                   ; file allocation table - drive 3                                                 
     0928             (    coco-defs.asm):00065         fcbv1           equ     $0928                   ; file buffer vectors (15 user, 1 system)                                                                 
     0948             (    coco-defs.asm):00066         rnbfad          equ     $0948                   ; start of free random file buffer area                                                  
     094A             (    coco-defs.asm):00067         fcbadr          equ     $094A                   ; start of file control blocks                                         
     094C             (    coco-defs.asm):00068         dnambf          equ     $094C                   ; disk file name buffer                                  
     0954             (    coco-defs.asm):00069         dextbf          equ     $0954                   ; disk file extension name buffer                                            
                      (    coco-defs.asm):00070         
     0957             (    coco-defs.asm):00071         dfltyp          equ     $0957                   ;dv; disk file type: 0=basic, 1=data, 2=machine                                                          
                      (    coco-defs.asm):00072                                                         ; language, 3=text editor source file
     0958             (    coco-defs.asm):00073         dascfl          equ     $0958                   ;dv; ascii flag: 0=crunched or binary, $ff=ascii                                                           
     0959             (    coco-defs.asm):00074         drunfl          equ     $0959                   ; run flag: (if bit 1=1 then run, if bit 0=1, then close                                                                   
                      (    coco-defs.asm):00075                                                         ; all files before running)
                      (    coco-defs.asm):00076         
     095A             (    coco-defs.asm):00077         defdrv          equ     $095A                   ; default drive number                                 
     095B             (    coco-defs.asm):00078         fcbact          equ     $095B                   ; number of fcbs active                                  
     095C             (    coco-defs.asm):00079         dresfl          equ     $095C                   ; reset flag: <>0 will cause a 'new' & shut down all fcbs                                                                    
                      (    coco-defs.asm):00080         
     095F             (    coco-defs.asm):00081         dusrvc          equ     $095F                   ; disk basic usr command vectors                                            
     097A             (    coco-defs.asm):00082         wfatvl          equ     $097A                   ; write fat value: number of free granules which must be taken                                                                         
                      (    coco-defs.asm):00083                                                         ; from the fat to trigger a write fat to disk sequence
     097C             (    coco-defs.asm):00084         dfflen          equ     $097C                   ; direct access file record length                                             
     097E             (    coco-defs.asm):00085         dr0trk          equ     $097E                   ; current track number, drives 0,1,2,3                                                 
                      (    coco-defs.asm):00086         
     095D             (    coco-defs.asm):00087         dloadfl         equ     $095D                   ; load flag: cause a 'new' following a load error                                                             
     095E             (    coco-defs.asm):00088         dmrgfl          equ     $095E                   ; merge flag: 0=no merge, $ff=merge                                              
                      (    coco-defs.asm):00089         
     0973             (    coco-defs.asm):00090         v973            equ     $0973                   ; sector number                        
     0974             (    coco-defs.asm):00091         v974            equ     $0974                   ; ram directory image address                                      
     0976             (    coco-defs.asm):00092         v976            equ     $0976                   ; first granule number                               
                      (    coco-defs.asm):00093                                                         ; unused file
     0977             (    coco-defs.asm):00094         v977            equ     $0977                   ; sector number                        
     0978             (    coco-defs.asm):00095         v978            equ     $0978                   ; ram directory image address                                      
                      (    coco-defs.asm):00096         
     0982             (    coco-defs.asm):00097         nmiflg          equ     $0982                   ; nmi flag: 0=don't vector <>0=yector out                                                    
     0983             (    coco-defs.asm):00098         dnmivc          equ     $0983                   ; nmi vector: where to jump following an nmi                                                       
                      (    coco-defs.asm):00099         
     0987             (    coco-defs.asm):00100         dverfl          equ     $0987                   ; verify flag: 0=off, $ff=on                                       
     0988             (    coco-defs.asm):00101         attctr          equ     $0988                   ; read/write attempt counter: number of times the                                                            
                      (    coco-defs.asm):00102         
                      (    coco-defs.asm):00103         
     0985             (    coco-defs.asm):00104         rdytmr          equ     $0985                   ; motor turn off timer                                 
     0986             (    coco-defs.asm):00105         drgram          equ     $0986                   ; ram image of dskreg ($ff40)                                        
                      (    coco-defs.asm):00106         
     0989             (    coco-defs.asm):00107         dflbuf          equ     $0989                   ; initialized to seclen by diskbas    
                      (    coco-defs.asm):00108         
     8168             (    coco-defs.asm):00109         l8168           equ     $8168                   ; if not pos, go to exbas sec
     813C             (    coco-defs.asm):00110         l813c           equ     $813c
     8311             (    coco-defs.asm):00111         l8311           equ     $8311                   ; jump to exbas' cload
     8316             (    coco-defs.asm):00112         l8316           equ     $8316                   ; go check for csavem
     836C             (    coco-defs.asm):00113         l836c           equ     $836c                   ; evaluate expression, put ii
     8748             (    coco-defs.asm):00114         l8748           equ     $8748                   ; evaluate a string expression
     8955             (    coco-defs.asm):00115         l8955           equ     $8955                   ; jump to extended basic's irq handler
     8C1B             (    coco-defs.asm):00116         l8c1b           equ     $8c1b                   ; jump to exeas' dload 
                      (    coco-defs.asm):00117         
     962E             (    coco-defs.asm):00118         l962e           equ     $962e                   ; jump to exeas' pmode comman
     9650             (    coco-defs.asm):00119         l9650           equ     $9650                   ; branch if comma
     96CB             (    coco-defs.asm):00120         l96cb           equ     $96cb                   ; readjust line numbers, etc
     975F             (    coco-defs.asm):00121         l975f           equ     $975f                   ; coming from exbas' get/put?
     9FB5             (    coco-defs.asm):00122         l9fb5           equ     $9fb5                   ; mult (unsigned)
                      (    coco-defs.asm):00123         
     A0E2             (    coco-defs.asm):00124         la0e2           equ     $a0e2                   ; back into ecb reset routine.
     A0E8             (    coco-defs.asm):00125         bawmst          equ     $a0e8
     A176             (    coco-defs.asm):00126         la176           equ     $a176                   ; get a char from input buffe
     A35F             (    coco-defs.asm):00127         la35f           equ     $a35f                   ; set print parameters 
     A37C             (    coco-defs.asm):00128         la37c           equ     $a37c                   ; save the print parameters
     A3ED             (    coco-defs.asm):00129         la3ed           equ     $a3ed                   ; verify that the file type
     A3FB             (    coco-defs.asm):00130         la3fb           equ     $a3fb                   ; 'file not open' error
     A406             (    coco-defs.asm):00131         la406           equ     $a406                   ; test device number 
     A426             (    coco-defs.asm):00132         la426           equ     $a426                   ; close all files 
     A42D             (    coco-defs.asm):00133         la42d           equ     $a42d                   ; close file 
     A549             (    coco-defs.asm):00134         la549           equ     $a549                   ; go do a break check
     A5A5             (    coco-defs.asm):00135         la5a5           equ     $a5a5                   ; evaluate an expression (device number)
     A5AE             (    coco-defs.asm):00136         la5ae           equ     $a5ae                   ; strip device number off of input line
     A5C7             (    coco-defs.asm):00137         la5c7           equ     $a5c7                   ; error if any further charac
     A5DA             (    coco-defs.asm):00138         la5da           equ     $a5da                   ; branch back to  basic's eof if not disk file
     A5E4             (    coco-defs.asm):00139         la5e4           equ     $a5e4                   ; link back to basic's eof statement
     A61C             (    coco-defs.asm):00140         la61c           equ     $a61c                   ; 'file already open' error
     A61F             (    coco-defs.asm):00141         la61f           equ     $a61f                   ; 'device number' error
     A7D1             (    coco-defs.asm):00142         la7d1           equ     $a7d1                   ; wait a while 
     A7E9             (    coco-defs.asm):00143         la7e9           equ     $a7e9                   ; turn off the cassette motor
     AC7C             (    coco-defs.asm):00144         lac7c           equ     $ac7c                   ; go to basic's main loop,
     ADC6             (    coco-defs.asm):00145         ladc6           equ     $adc6                   ; loop through basic's main interpretation loop
     AE15             (    coco-defs.asm):00146         lae15           equ     $ae15                   ; go 'stop' the system
     AC37             (    coco-defs.asm):00147         lac37           equ     $ac37                   ; see of enough room in ram
     AF9A             (    coco-defs.asm):00148         laf9a           equ     $af9a
     AFA4             (    coco-defs.asm):00149         lafa4           equ     $afa4                   ; branch back to basic's 'let
     AFB1             (    coco-defs.asm):00150         lafb1           equ     $afb1                   ; branch if string stored 
                      (    coco-defs.asm):00151         
     B00C             (    coco-defs.asm):00152         lb00c           equ     $b00c                   ; return unless coming from basic 'input' statement
     B01E             (    coco-defs.asm):00153         lb01e           equ     $b01e                   ; get modified reentry point
     B069             (    coco-defs.asm):00154         lb069           equ     $b069
     B148             (    coco-defs.asm):00155         lb148           equ     $b148                   ; do a 'tm' check
     B166             (    coco-defs.asm):00156         lb166           equ     $b166                   ; coming from the 'let' comma
     B244             (    coco-defs.asm):00157         lb244           equ     $b244                   ; strip prompt string from basic and put it on the string stack
     B262             (    coco-defs.asm):00158         lb262           equ     $b262                   ; basic check for (
     B2CE             (    coco-defs.asm):00159         lb2ce           equ     $b2ce                   ; jump to basic's secondary ?
     B3E6             (    coco-defs.asm):00160         lb3e6           equ     $b3e6                   ; evaluate expression
     B4F4             (    coco-defs.asm):00161         givabf          equ     $b4f4
     B516             (    coco-defs.asm):00162         lb516           equ     $b516                   ; put on temporary string sta
     B657             (    coco-defs.asm):00163         lb657           equ     $b657                   ; purge the string put on the string stack
     BC5F             (    coco-defs.asm):00164         lbc5f           equ     $bc5f                   ; save number of bytes in ful
     B69B             (    coco-defs.asm):00165         lb69b           equ     $b69b                   ; save string descriptor on 
     B70E             (    coco-defs.asm):00166         lb70e           equ     $b70e                   ;evaluate numeric expression 
     B95C             (    coco-defs.asm):00167         lb95c           equ     $b95c                   ; send a cr to the screen 
     B99F             (    coco-defs.asm):00168         lb99f           equ     $b99f                   ; print string to console out
     B9A2             (    coco-defs.asm):00169         lb9a2           equ     $b9a2                   ; send filename to console ou
     BC14             (    coco-defs.asm):00170         lbc14           equ     $bc14                   ; copy a packed fp number fro
     BC33             (    coco-defs.asm):00171         lbc33           equ     $bc33                   ; if numeric variable, pack 
     BC35             (    coco-defs.asm):00172         lbc35           equ     $bc35                   ; pack fpa0 and store it in s
     BDD9             (    coco-defs.asm):00173         lbdd9           equ     $bdd9                   ; convert fp number to ascii 
                      (    coco-defs.asm):00174         
     FF00             (    coco-defs.asm):00175         pia0           equ                                 $ff00              peripheral interface adapter one                                                       
     FF20             (    coco-defs.asm):00176         pia1           equ                                 $ff20               peripheral interface adapter two                                                        
                      (    coco-defs.asm):00177         
     FF40             (    coco-defs.asm):00178         dskreg         equ      $ff40                   ; disk control register                                  
                      (    coco-defs.asm):00179         
                      (    coco-defs.asm):00180         ; bit0 drive select 0
                      (    coco-defs.asm):00181         ; bit1 drive select 1
                      (    coco-defs.asm):00182         ; bit2 drive select 2
                      (    coco-defs.asm):00183         ; bit3 drive motor enable 0 = motors off 1 = motors on
                      (    coco-defs.asm):00184         ; bit4 write precompensation 0 = no precomp 1 = precomp
                      (    coco-defs.asm):00185         ; bit5 density flag 0 = single 1 = double
                      (    coco-defs.asm):00186         ; bit6 drive select 3
                      (    coco-defs.asm):00187         ; bit7 halt flag 0 = disabled 1 = enabled
                      (    coco-defs.asm):00188         
                      (    coco-defs.asm):00189         ; floppy disk controller internal registers
                      (    coco-defs.asm):00190         
                      (    coco-defs.asm):00191         ; commands      type    command         code
                      (    coco-defs.asm):00192         ;               i       restore         $03
                      (    coco-defs.asm):00193         ;               i       seek            $17
                      (    coco-defs.asm):00194         ;               i       step            $23
                      (    coco-defs.asm):00195         ;               i       step in         $43
                      (    coco-defs.asm):00196         ;               i       step out        $53
                      (    coco-defs.asm):00197         ;               ii      read sector     $80
                      (    coco-defs.asm):00198         ;               ii      write sector    $a0
                      (    coco-defs.asm):00199         ;               iii     read address    $c0
                      (    coco-defs.asm):00200         ;               iii     read track      $e4
                      (    coco-defs.asm):00201         ;               iii     write track     $f4
                      (    coco-defs.asm):00202         ;               iv      force interrupt $d0
                      (    coco-defs.asm):00203         
                      (    coco-defs.asm):00204         ; status bit    type i          read address/sector/track write sector/track
                      (    coco-defs.asm):00205         ; s0            busy            busy                            busy
                      (    coco-defs.asm):00206         ; s1            index           drq                             drq
                      (    coco-defs.asm):00207         ; s2            track 0         lost data                       lost data
                      (    coco-defs.asm):00208         ; s3            crc error       crc error (except track)        crc error (except track)
                      (    coco-defs.asm):00209         ; s4            seek error      rnf (except track)              rnf (except track)
                      (    coco-defs.asm):00210         ; s5            head loaded     record type (sector only)       write fault
                      (    coco-defs.asm):00211         ; s6            write protect   write protect
                      (    coco-defs.asm):00212         ; s7            not ready       not ready                       not ready
                      (    coco-defs.asm):00213         
     FF48             (    coco-defs.asm):00214         fdcreg         equ     $ff48                    ; status/command register                                    
     FF49             (    coco-defs.asm):00215         fdctrack       equ     $ff49                    ; track register                     
     FF4A             (    coco-defs.asm):00216         fdcsect        equ     $ff4a                    ; sector register                      
     FF4B             (    coco-defs.asm):00217         fdcdata        equ     $ff4b                    ; data register                    
                      (    coco-defs.asm):00218                                                       
                      (    rsdos_mmc.asm):00003                         
     00E1             (    rsdos_mmc.asm):00004         dhitok         equ     $e1                      ; highest 1.1 disk token                                     
     0032             (    rsdos_mmc.asm):00005         cyear          equ     '2'                                      
                      (    rsdos_mmc.asm):00006         
                      (    rsdos_mmc.asm):00007         
                      (    rsdos_mmc.asm):00008         ;wd27           equ     $08                     ; uncomment this if using wd2797 on dragon/rs contoler
                      (    rsdos_mmc.asm):00009         ;wd27            equ     $00                     ; uncomment this if using standard rs-dos or wd2793
                      (    rsdos_mmc.asm):00010         
                      (    rsdos_mmc.asm):00011         ;WDRestore       equ     WDCmdRestore+StepRate30ms
                      (    rsdos_mmc.asm):00012         ;WDSeek          equ     WDCmdSeek+WDFlagVerify+StepRate30ms
                      (    rsdos_mmc.asm):00013         ;WDStepIn        equ     WDCmdStepIn+WDFlagUpdate+StepRate30ms
                      (    rsdos_mmc.asm):00014         ;WDStepOut       equ     WDCmdStepOut+WDFlagUpdate+StepRate30ms
                      (    rsdos_mmc.asm):00015         ;WDReadSector    equ     WDCmdReadSec+wd27       ; read sector command
                      (    rsdos_mmc.asm):00016         ;WDWriteSector   equ     WDCmdWriteSec+wd27      ; write sector command
                      (    rsdos_mmc.asm):00017         ;WDWriteTrack    equ     WDCmdWriteTrack
                      (    rsdos_mmc.asm):00018         
                      (    rsdos_mmc.asm):00019         ;
                      (    rsdos_mmc.asm):00020         ;
                      (    rsdos_mmc.asm):00021         ;
                      (    rsdos_mmc.asm):00022         ; file allocation table format
                      (    rsdos_mmc.asm):00023         ;
                      (    rsdos_mmc.asm):00024         ;
                      (    rsdos_mmc.asm):00025         ; the file allocation table (fat) contains the status of the granules on a diskette.
                      (    rsdos_mmc.asm):00026         ; the fat contains 6 control bytes followed by 68 data bytes (one per granule). only the
                      (    rsdos_mmc.asm):00027         ; first two of the six control bytes are used. a value of $ff is saved in unallocated
                      (    rsdos_mmc.asm):00028         ; granules. if bits 6 & 7 of the data byte are set, the granule is the last granule
                      (    rsdos_mmc.asm):00029         ; in a file and bits 0-5 are the number of used sectors in that granule. if bits 6 & 7
                      (    rsdos_mmc.asm):00030         ; are not set, the data byte contains the number of the next granule in the file.
                      (    rsdos_mmc.asm):00031         
                      (    rsdos_mmc.asm):00032         ; offsets to fat control bytes
     0000             (    rsdos_mmc.asm):00033         fat0           equ     0                        ; active file counter : disk to ram fat image disable                                                              
     0001             (    rsdos_mmc.asm):00034         fat1           equ     1                        ; valid data flag: 0=disk data valid, <> 0 = new fat                                                             
                      (    rsdos_mmc.asm):00035         ;                                         data - disk data invalid
                      (    rsdos_mmc.asm):00036         ;                2 to 5                   not used
     0006             (    rsdos_mmc.asm):00037         fatcon         equ     6                        ; offset to start of fat data (68 bytes)                                                   
                      (    rsdos_mmc.asm):00038         ;
                      (    rsdos_mmc.asm):00039         ;;
                      (    rsdos_mmc.asm):00040         ;;;; directory entry format
                      (    rsdos_mmc.asm):00041         ;;
                      (    rsdos_mmc.asm):00042         ;
                      (    rsdos_mmc.asm):00043         ; the directory is used to keep track of how many files are stored on a diskette
                      (    rsdos_mmc.asm):00044         ; and where the file is stored on the disk. the first granule used by the file will
                      (    rsdos_mmc.asm):00045         ; allow the fat to track down all of the granules used by the file. if the first
                      (    rsdos_mmc.asm):00046         ; byte of the directory entry is zero, the file has been killed;
                      (    rsdos_mmc.asm):00047         ; if the first byte is $ff then the directory entry has never been used.
                      (    rsdos_mmc.asm):00048         ;
                      (    rsdos_mmc.asm):00049         ;                byte                                description
                      (    rsdos_mmc.asm):00050         
     0000             (    rsdos_mmc.asm):00051         dirnam         equ     0                        ; file name                      
     0008             (    rsdos_mmc.asm):00052         dirext         equ     8                        ; file extension                           
     000B             (    rsdos_mmc.asm):00053         dirtyp         equ     11                       ; file type                       
     000C             (    rsdos_mmc.asm):00054         dirasc         equ     12                       ; ascii flag                        
     000D             (    rsdos_mmc.asm):00055         dirgrn         equ     13                       ; first granule in file                                   
     000E             (    rsdos_mmc.asm):00056         dirlst         equ     14                       ; number of bytes in last sector                                            
                      (    rsdos_mmc.asm):00057         ;                16 to 31                            unused
                      (    rsdos_mmc.asm):00058         ;
                      (    rsdos_mmc.asm):00059         ;;
                      (    rsdos_mmc.asm):00060         ;;;; file control block format
                      (    rsdos_mmc.asm):00061         ;;
                      (    rsdos_mmc.asm):00062         ;
                      (    rsdos_mmc.asm):00063         ; the file structure of color trs dos is controlled by a file control block (fcb)
                      (    rsdos_mmc.asm):00064         ; the fcb contains 25 control bytes and a sector long (256 bytes) data buffer.
                      (    rsdos_mmc.asm):00065         ; the control bytes control the orderly flow of data from the computer's ram to
                      (    rsdos_mmc.asm):00066         ; the diskette and vice versa. the open command initializes the fcb; the input,
                      (    rsdos_mmc.asm):00067         ; output, write, print, get and put commands transfer data through the fcb and
                      (    rsdos_mmc.asm):00068         ; the close command turns off the fcb.
                      (    rsdos_mmc.asm):00069         
                      (    rsdos_mmc.asm):00070         ; tables of offsets to fcb control bytes
                      (    rsdos_mmc.asm):00071         
                      (    rsdos_mmc.asm):00072         ;;;;; random file
                      (    rsdos_mmc.asm):00073         ;                byte                                description
     0000             (    rsdos_mmc.asm):00074         fcbtyp         equ     0                        ; file type: $40=random/direct, 0=closed                                                   
     0001             (    rsdos_mmc.asm):00075         fcbdrv         equ     1                        ; drive number                         
     0002             (    rsdos_mmc.asm):00076         fcbfgr         equ     2                        ; first granule in file                                  
     0003             (    rsdos_mmc.asm):00077         fcbcgr         equ     3                        ; current granule being used                                       
     0004             (    rsdos_mmc.asm):00078         fcbsec         equ     4                        ; current sector being used (1-9)                                            
                      (    rsdos_mmc.asm):00079         ;                5                                   unused
     0006             (    rsdos_mmc.asm):00080         fcbpos         equ     6                        ; current print position - always zero in random files                                                                 
     0007             (    rsdos_mmc.asm):00081         fcbrec         equ     7                        ; current record number                                  
     0009             (    rsdos_mmc.asm):00082         fcbrln         equ     9                        ; random file record length                                      
     000B             (    rsdos_mmc.asm):00083         fcbbuf         equ     11                       ; pointer to start of this file's random access buffer                                                                  
     000D             (    rsdos_mmc.asm):00084         fcbsof         equ     13                       ; sector offset to current position in record                                                         
     000F             (    rsdos_mmc.asm):00085         fcbflg         equ     15                       ; get/put flag: 0=put, 1=put                                        
                      (    rsdos_mmc.asm):00086         ;                16,17                               not used
     0012             (    rsdos_mmc.asm):00087         fcbdir         equ     18                       ; directory entry number (0-71)                                           
     0013             (    rsdos_mmc.asm):00088         fcblst         equ     19                       ; number of bytes in last sector of file                                                    
                      (    rsdos_mmc.asm):00089         
     0015             (    rsdos_mmc.asm):00090         fcbget         equ     21                       ; 'get' record counter: how many characters have been                                                                 
                      (    rsdos_mmc.asm):00091         ;                                                    pulled out of the current record
     0017             (    rsdos_mmc.asm):00092         fcbput         equ     23                       ; 'put' record counter: pointer to where in the record the next                                                                           
                      (    rsdos_mmc.asm):00093         ;                                                    byte will be 'put'
                      (    rsdos_mmc.asm):00094         ;fcbcon         equ     25                          ; offset to start of fcb data buffer (256 bytes)                                                            
                      (    rsdos_mmc.asm):00095         
                      (    rsdos_mmc.asm):00096         ;;;;; sequential file (some of these are commented out as they are defined above)
                      (    rsdos_mmc.asm):00097         ;                byte                                description
                      (    rsdos_mmc.asm):00098         ;fcbtyp         equ     0                           ; file type: $10=input, $20=output, 0=closed                                                       
                      (    rsdos_mmc.asm):00099         ;fcbdrv         equ     1                           ; drive number                         
                      (    rsdos_mmc.asm):00100         ;fcbfgr         equ     2                           ; first granule in file                                  
                      (    rsdos_mmc.asm):00101         ;fcbcgr         equ     3                           ; current granule being used                                       
                      (    rsdos_mmc.asm):00102         ;fcbsec         equ     4                           ; current sector being used (1-9)                                            
     0005             (    rsdos_mmc.asm):00103         fcbcpt         equ     5                        ; input file: character pointer - points to next character in                                                                        
                      (    rsdos_mmc.asm):00104         ;                                                    file to be processed.
                      (    rsdos_mmc.asm):00105         ;                                                    output file: full sector flag - if it is 1 when the file is
                      (    rsdos_mmc.asm):00106         ;                                                    closed it means 256 bytes of the last sector have been used.
                      (    rsdos_mmc.asm):00107         ;fcbpos         equ     6                           ; current print position                                   
                      (    rsdos_mmc.asm):00108         ;fcbrec         equ     7                           ; current record number: how many whole sectors have been                                                                    
                      (    rsdos_mmc.asm):00109         ;                                                    input or output to a file.
                      (    rsdos_mmc.asm):00110         ;                9 to 15                             unused
     0010             (    rsdos_mmc.asm):00111         fcbcfl         equ     16                       ; cache flag: 00=cache empty, $ff=cache full                                                        
     0011             (    rsdos_mmc.asm):00112         fcbcdt         equ     17                       ; cache data byte                             
                      (    rsdos_mmc.asm):00113         ;fcbdir         equ     18                          ; directory entry number (0-71)                                           
                      (    rsdos_mmc.asm):00114         ;fcblst         equ     19                          ; number of bytes in last sector of file                                                    
                      (    rsdos_mmc.asm):00115         ;                 21,22                            unused
     0017             (    rsdos_mmc.asm):00116         fcbdfl         equ     23                       ; input file only: data left flag: 0=data left, $ff=no data (empty)                                                                               
     0018             (    rsdos_mmc.asm):00117         fcblft         equ     24                       ; number of characters left in buffer (input file)                                                              
                      (    rsdos_mmc.asm):00118         ;                                                  number of chars stored in buffer (output file)
                      (    rsdos_mmc.asm):00119         ;fcbcon         equ     25                          ; offset to fcb data buffer (256 bytes)                                                   
                      (    rsdos_mmc.asm):00120         
                      (    rsdos_mmc.asm):00121         ;               org     $c000                                
                      (    rsdos_mmc.asm):00122         
                      (    rsdos_mmc.asm):00123         ;dosbas         fcc     'DK'                                      
                      (    rsdos_mmc.asm):00124         ;lc002          bra     lc00c                                     
                      (    rsdos_mmc.asm):00125         
C004 D522             (    rsdos_mmc.asm):00126         dcnvec         fdb     dskcon                   ; dskcon pointer                                
C006 00EA             (    rsdos_mmc.asm):00127         dskvar         fdb     dcopc                    ; address of dskcon variables                                            
C008 D669             (    rsdos_mmc.asm):00128         dsinit         fdb     dosini                   ; disk initialization vector                                            
C00A D61D             (    rsdos_mmc.asm):00129         dosvec         fdb     doscom                   ; dos command vector                                    
                      (    rsdos_mmc.asm):00130         
                      (    rsdos_mmc.asm):00131         ;
                      (    rsdos_mmc.asm):00132         ; Init for MMC
                      (    rsdos_mmc.asm):00133         ;
C00C 161FFD           (    rsdos_mmc.asm):00134         MMCInit LBRA    RealMMCInit
                      (    rsdos_mmc.asm):00135         ;
                      (    rsdos_mmc.asm):00136         ; Init Dos
                      (    rsdos_mmc.asm):00137         ; 
C00F                  (    rsdos_mmc.asm):00138         DosInit
C00F 8E0600           (    rsdos_mmc.asm):00139                         ldx     #dbuf0                   ; point x to start of disk ram                                             
                      (    rsdos_mmc.asm):00140         
C012 6F80             (    rsdos_mmc.asm):00141         lc00f          clr     ,x+                      ; clear a byte                          
C014 8C0989           (    rsdos_mmc.asm):00142                        cmpx    #dflbuf                  ; end of disk's ram?                                
C017 26F9             (    rsdos_mmc.asm):00143                        bne     lc00f                    ; no - keep clearing                             
                      (    rsdos_mmc.asm):00144         
                      (    rsdos_mmc.asm):00145         ;               ldx     #BeginStub               ; point x to rom image of command interpretation table                                                                
                      (    rsdos_mmc.asm):00146         ;               ldu     #BasStub2                ; point u to ram address of same                                              
                      (    rsdos_mmc.asm):00147         ;               ldb     #10                      ; 10 bytes per table                           
                      (    rsdos_mmc.asm):00148         ;               jsr     UtilCopyBXtoU            ; move (b) bytes from (x) to (u)                                         
                      (    rsdos_mmc.asm):00149         
                      (    rsdos_mmc.asm):00150         ;               ldd     #BasSNError              ; syntax error address                                
                      (    rsdos_mmc.asm):00151         ;               std     $03,u                    ; set jump table addresses of the user command                                                       
                      (    rsdos_mmc.asm):00152         ;               std     $08,u                    ; interpretation table to point to syntax error                                                        
                      (    rsdos_mmc.asm):00153         ;               clr     ,u                       ; clear byte 0 of user table (doesn't exist flag)                                                       
                      (    rsdos_mmc.asm):00154         ;               clr     $05,u                    ; set number of secondary user tokens to zero                                                      
                      (    rsdos_mmc.asm):00155         
                      (    rsdos_mmc.asm):00156         ; Modify Extended basic stub
C019 CCCDE7           (    rsdos_mmc.asm):00157                        ldd     #dxcvec                  ; save new                     
C01C FD012D           (    rsdos_mmc.asm):00158                        std     BasAddrDskCmdDisp        ; pointers to exbas                                
C01F CCCE0F           (    rsdos_mmc.asm):00159                        ldd     #dxivec                  ; command and secondary                                  
C022 FD0132           (    rsdos_mmc.asm):00160                        std     BasAddrDskFuncDisp       ; command interpretation routines                                              
                      (    rsdos_mmc.asm):00161         
                      (    rsdos_mmc.asm):00162         ;;;; move the new ram vectors from rom to ram
C025 8EC0D0           (    rsdos_mmc.asm):00163                        ldx     #RamHookTable            ; Point at ram hooks
C028 CE015E           (    rsdos_mmc.asm):00164                        ldu     #VectBase                ; point u to 1st ram vector                                     
C02B 867E             (    rsdos_mmc.asm):00165         lc03b          lda     #$7e                     ; op code of jmp instruction                                         
C02D B701A0           (    rsdos_mmc.asm):00166                        sta     VectAccessScreen         ; set 1st byte of 'get'/'put' ram vector to 'jmp'                                                           
C030 A7C0             (    rsdos_mmc.asm):00167                        sta     ,u+                      ; set 1st byte of ram vector to 'jmp'                                            
C032 EC81             (    rsdos_mmc.asm):00168                        ldd     ,x++                     ; get ram vector from rom                                 
C034 EDC1             (    rsdos_mmc.asm):00169                        std     ,u++                     ; store it in ram                         
C036 8CC0F6           (    rsdos_mmc.asm):00170                        cmpx    #DosSignonMess           ; compare to end of rom values                                         
C039 26F0             (    rsdos_mmc.asm):00171                        bne     lc03b                    ; branch if not all vectors moved                                          
                      (    rsdos_mmc.asm):00172         
C03B 8EC18F           (    rsdos_mmc.asm):00173                        ldx     #DosHookGetPutCLS        ; get rom value of 'get'/'put' ram vector                                                    
C03E BF01A1           (    rsdos_mmc.asm):00174                        stx     VectAccessScreen+1       ; save it in ram                            
C041 8EC78D           (    rsdos_mmc.asm):00175                        ldx     #DosHookInterpret        ; get disk command interpretation loop ram vector                                                            
C044 BF019B           (    rsdos_mmc.asm):00176                        stx     VectGetNextCmd+1         ; save in ram vector table                                      
                      (    rsdos_mmc.asm):00177             
                      (    rsdos_mmc.asm):00178         ;;;; initialize disk basic's usr vectors
C047 8E095F           (    rsdos_mmc.asm):00179                        ldx     #dusrvc                  ; point x to start of disk basic usr vectors                                                       
C04A 9FB0             (    rsdos_mmc.asm):00180                        stx     BasUSRTableAddr          ; save start address in BasUSRTableAddr                                        
C04C CEB44A           (    rsdos_mmc.asm):00181                        ldu     #BasFCError              ; point u to address of 'function call' error                                                       
C04F C60A             (    rsdos_mmc.asm):00182                        ldb     #$0a                     ; 10 user vectors to initialize                                       
C051 EF81             (    rsdos_mmc.asm):00183         lc061          stu     ,x++                     ; set usr vector to 'fc' error                                           
C053 5A               (    rsdos_mmc.asm):00184                        decb                             ; decrement usr vector counter                                   
C054 26FB             (    rsdos_mmc.asm):00185                        bne     lc061                    ; branch in not done with all 10 vectors                                                 
                      (    rsdos_mmc.asm):00186         
                      (    rsdos_mmc.asm):00187         ;               ldx     #dnmisv                  ; get address of nmi servicing routine                                                 
                      (    rsdos_mmc.asm):00188         ;               stx     SecVecNMI+1              ; save it in nmi vector                                   
                      (    rsdos_mmc.asm):00189         ;               lda     #$7e                     ; op code of jmp                        
                      (    rsdos_mmc.asm):00190         ;               sta     SecVecNMI                ; make the nmi vector a jmp                                     
                      (    rsdos_mmc.asm):00191                        
                      (    rsdos_mmc.asm):00192         ;               ldx     #dirqsv                  ; get address of disk basic irq servicing routine                                                            
                      (    rsdos_mmc.asm):00193         ;               stx     SecVecIRQ+1              ; save it in SecVecIRQ                               
                      (    rsdos_mmc.asm):00194                        
C056 8613             (    rsdos_mmc.asm):00195                        lda     #$13                     ; = initialize write fat                                
C058 B7097A           (    rsdos_mmc.asm):00196                        sta     wfatvl                   ; = to disk trigger value                                   
C05B 7F0800           (    rsdos_mmc.asm):00197                        clr     fatbl0                   ;           
C05E 7F084A           (    rsdos_mmc.asm):00198                        clr     fatbl1                   ; initialize the active file counter of                                                 
C061 7F0894           (    rsdos_mmc.asm):00199                        clr     fatbl2                   ; each fat to zero. this will cause the fats                                                      
C064 7F08DE           (    rsdos_mmc.asm):00200                        clr     fatbl3                   ; to think there are no active files                                              
C067 8E0989           (    rsdos_mmc.asm):00201                        ldx     #dflbuf                  ; = get the starting address of the                                              
C06A BF0948           (    rsdos_mmc.asm):00202                        stx     rnbfad                   ; = random file buffer free area and dave it as the                                                             
                      (    rsdos_mmc.asm):00203                                                         ; = start address of free ram for random file buffers
C06D 30890100         (    rsdos_mmc.asm):00204                        leax    $0100,x                  ; save 256 bytes for random file buffers initially                                                              
C071 BF094A           (    rsdos_mmc.asm):00205                        stx     fcbadr                   ; save start address of fcbs                                      
C074 3001             (    rsdos_mmc.asm):00206                        leax    $01,x                    ; add one and save the starting                                         
C076 BF0928           (    rsdos_mmc.asm):00207                        stx     fcbv1                    ; address of fcb1                          
C079 6F84             (    rsdos_mmc.asm):00208                        clr     fcbtyp,x                 ; clear the first byte of fcb 1 (close fcb)                                                       
C07B 30890119         (    rsdos_mmc.asm):00209                        leax    fcblen,x                 ; point x to fcb 2                               
C07F BF092A           (    rsdos_mmc.asm):00210                        stx     fcbv1+2                  ; save its starting address in fcb vector table                                                          
C082 6F84             (    rsdos_mmc.asm):00211                        clr     fcbtyp,x                 ; clear the first byte of fcb 2 (close fcb)                                                       
C084 30890119         (    rsdos_mmc.asm):00212                        leax    fcblen,x                 ; point x to system fcb - this fcb will only                                                         
                      (    rsdos_mmc.asm):00213                                                         ; be used to copy, load, save, merge, etc
C088 BF092C           (    rsdos_mmc.asm):00214                        stx     fcbv1+4                  ; save its address in the fcb vector table                                                     
C08B 6F84             (    rsdos_mmc.asm):00215                        clr     fcbtyp,x                 ; clear the first byte of system fcb (close fcb)                                                            
C08D 8602             (    rsdos_mmc.asm):00216                        lda     #$02                     ; set the number of active reserved                                           
C08F B7095B           (    rsdos_mmc.asm):00217                        sta     fcbact                   ; file buffers to 2 (1,2)                                   
C092 30890119         (    rsdos_mmc.asm):00218                        leax    fcblen,x                 ; point x to one past the end of system fcb                                                        
C096 1F10             (    rsdos_mmc.asm):00219                        tfr     x,d                      ; save the address in accd                                 
C098 5D               (    rsdos_mmc.asm):00220                        tstb                             ; on an even 256 byte boundary?                                    
C099 2701             (    rsdos_mmc.asm):00221                        beq     lc0bd                    ; yes              
                      (    rsdos_mmc.asm):00222         
C09B 4C               (    rsdos_mmc.asm):00223                        inca                             ; no - add 256 to address                              
C09C 8501             (    rsdos_mmc.asm):00224         lc0bd          bita    #$01                     ; check to see if accd is on an even                                                  
C09E 2701             (    rsdos_mmc.asm):00225                        beq     lc0c2                    ; 512 byte (one graphic page) boundary - add                                                     
                      (    rsdos_mmc.asm):00226         
C0A0 4C               (    rsdos_mmc.asm):00227                        inca                             ; 256 (inca) to it if not                              
C0A1 1F89             (    rsdos_mmc.asm):00228         lc0c2          tfr     a,b                      ; copy acca to accb                               
C0A3 CB18             (    rsdos_mmc.asm):00229                        addb    #$18                     ; save enough room for 4 graphics pages (pclear 4)                                                           
C0A5 D719             (    rsdos_mmc.asm):00230                        stb     BasStartProg             ; save new start of basic address                                           
C0A7 BD96EC           (    rsdos_mmc.asm):00231                        jsr     BasLocateScreen          ; initialize exbas variables & do a new                                                
                      (    rsdos_mmc.asm):00232         
C0AA 96BA             (    rsdos_mmc.asm):00233                        lda     GrDisplayStartAddr       ; get the start of current graphics page                                                  
C0AC 8B06             (    rsdos_mmc.asm):00234                        adda    #$06                     ; add 1.5k (6 x 256 = one graphics page)                                                 
C0AE 97B7             (    rsdos_mmc.asm):00235                        sta     GrLastDisplayAddr        ; save new end of graphics page                                         
C0B0 AD9FC008         (    rsdos_mmc.asm):00236                        jsr     [dsinit]                 ; initialize swi2,3 jump addresses                                              
                      (    rsdos_mmc.asm):00237         
                      (    rsdos_mmc.asm):00238         ;               bsr     InitFDC                  ; go initialize the floppy disk controller                                                   
                      (    rsdos_mmc.asm):00239         
C0B4 1CAF             (    rsdos_mmc.asm):00240                        andcc   #$af                     ; turn on irq and firq                                
C0B6 8EC0F5           (    rsdos_mmc.asm):00241                        ldx     #DosSignonMess-1         ; point x to disk basic copyright message                                                     
C0B9 BDB99C           (    rsdos_mmc.asm):00242                        jsr     TextOutString            ; print copyright message to screen                                               
                      (    rsdos_mmc.asm):00243         
                      (    rsdos_mmc.asm):00244         ;               ldx     #dkwmst                  ; get disk basic warm start address                                              
                      (    rsdos_mmc.asm):00245         ;               stx     IndVecReset              ; save it in reset vector                                   
                      (    rsdos_mmc.asm):00246         ;               jmp     la0e2                    ; jump back to basic                             
                      (    rsdos_mmc.asm):00247         
C0BC 7EE0A9           (    rsdos_mmc.asm):00248                         jmp     >MMC_InitDone           ; do post init stuff
                      (    rsdos_mmc.asm):00249         
                      (    rsdos_mmc.asm):00250         
C0BF                  (    rsdos_mmc.asm):00251         DOSResetVector
C0BF 12               (    rsdos_mmc.asm):00252                        nop                              ; warm start indicator                                
C0C0 8D04             (    rsdos_mmc.asm):00253                        bsr     InitFDC                  ; initialize the floppy disk controller                                                
                      (    rsdos_mmc.asm):00254         
C0C2 BDD1AF           (    rsdos_mmc.asm):00255                        jsr     >CloseFilesInit2         ; close files and do more initialization                                                 
C0C5 39               (    rsdos_mmc.asm):00256                        rts
                      (    rsdos_mmc.asm):00257                        
                      (    rsdos_mmc.asm):00258         ;               jmp     WarmStart                ; jump to exbas' warm start                                     
                      (    rsdos_mmc.asm):00259         
C0C6 7F0982           (    rsdos_mmc.asm):00260         InitFDC        clr     nmiflg                   ; reset nmi flag                               
C0C9 7F0985           (    rsdos_mmc.asm):00261                        clr     rdytmr                   ; reset drive not ready timer                                       
C0CC 7F0986           (    rsdos_mmc.asm):00262                        clr     drgram                   ; reset ram image of dskreg (motors off)                                                  
                      (    rsdos_mmc.asm):00263         
                      (    rsdos_mmc.asm):00264         ;               clr     >dskreg                  ; reset disk control register                                       
                      (    rsdos_mmc.asm):00265         ;               lda     #WDCmdForceInt           ; force interrupt command of 1793                                         
                      (    rsdos_mmc.asm):00266         ;               sta     >fdcreg                  ; send it to 1793                           
                      (    rsdos_mmc.asm):00267         ;               exg     a,a                      ; delay              
                      (    rsdos_mmc.asm):00268         ;               exg     a,a                      ; delay some more                        
                      (    rsdos_mmc.asm):00269         ;               lda     >fdcreg                  ; get 1793 status (clear register)                                            
C0CF 39               (    rsdos_mmc.asm):00270                        rts                                     
                      (    rsdos_mmc.asm):00271         
                      (    rsdos_mmc.asm):00272         ; disk basic command interp tables
                      (    rsdos_mmc.asm):00273         ;BeginStub          
                      (    rsdos_mmc.asm):00274         ;               fcb     NoDOSCommands            ; 20 disk basic 1.1 commands                                       
                      (    rsdos_mmc.asm):00275         ;               fdb     DosCmdNames              ; disk basic's command dictionary                                          
                      (    rsdos_mmc.asm):00276         ;               fdb     DosCmdDispatch           ; command jump table                             
                      (    rsdos_mmc.asm):00277         ;               fcb     NoDOSFunctions           ; 6 disk basic secondary functions                                        
                      (    rsdos_mmc.asm):00278         ;               fdb     DosFuncNames             ; secondary function table                                   
                      (    rsdos_mmc.asm):00279         ;               fdb     DosFuncDispatch          ; secondary function jump table                                        
                      (    rsdos_mmc.asm):00280         
                      (    rsdos_mmc.asm):00281         ; ram hooks for disk basic
C0D0                  (    rsdos_mmc.asm):00282         RamHookTable
C0D0 C328             (    rsdos_mmc.asm):00283                        fdb     DosHookOpenDev
C0D2 C765             (    rsdos_mmc.asm):00284                        fdb     DosHookCheckIONum
C0D4 C770             (    rsdos_mmc.asm):00285                        fdb     DosHookRetDevParam                                     
C0D6 CAF9             (    rsdos_mmc.asm):00286                        fdb     DosHookCharOut
C0D8 C499             (    rsdos_mmc.asm):00287                        fdb     DosHookCharIn
C0DA C725             (    rsdos_mmc.asm):00288                        fdb     DosHookCheckOpenIn                                
C0DC C728             (    rsdos_mmc.asm):00289                        fdb     DosHookCheckOpenOut
C0DE C9C6             (    rsdos_mmc.asm):00290                        fdb     DosCloseAllFiles
C0E0 C9D6             (    rsdos_mmc.asm):00291                        fdb     DosHookCloseFile                                
C0E2 8E90             (    rsdos_mmc.asm):00292                        fdb     CoCoVect179
C0E4 CC12             (    rsdos_mmc.asm):00293                        fdb     DosHookInput
C0E6 C786             (    rsdos_mmc.asm):00294                        fdb     DosHookBreak                                
C0E8 C5C1             (    rsdos_mmc.asm):00295                        fdb     DosHookReadInputLine
C0EA C9C1             (    rsdos_mmc.asm):00296                        fdb     DosHookTermInputLine
C0EC C7E9             (    rsdos_mmc.asm):00297                        fdb     DosHookEOF                                
C0EE CDAF             (    rsdos_mmc.asm):00298                        fdb     DosHookEvaluate
C0F0 C5C1             (    rsdos_mmc.asm):00299                        fdb     DosHookReadInputLine                                
C0F2 C142             (    rsdos_mmc.asm):00300                        fdb     DosHookSysError
C0F4 C91B             (    rsdos_mmc.asm):00301                        fdb     DosHookRun                                
                      (    rsdos_mmc.asm):00302         
                      (    rsdos_mmc.asm):00303         ; disk basic copyright message
C0F6                  (    rsdos_mmc.asm):00304         DosSignonMess  
C0F6 4449534B20455854 (    rsdos_mmc.asm):00305                        fcc     'DISK EXTENDED COLOR BASIC 1.1'                                         
     454E44454420434F
     4C4F522042415349
     4320312E31
C113 0D               (    rsdos_mmc.asm):00306                        fcb     cr                                
C114 00               (    rsdos_mmc.asm):00307                        fcb      0
                      (    rsdos_mmc.asm):00308                        
                      (    rsdos_mmc.asm):00309                        ifeq 1
                      (    rsdos_mmc.asm):00310                        fcc     'COPYRIGHT (C) 198'                        
                      (    rsdos_mmc.asm):00311                        fcb     cyear                                
                      (    rsdos_mmc.asm):00312                        fcc     ' BY TANDY'                
                      (    rsdos_mmc.asm):00313                        fcb     cr                                
                      (    rsdos_mmc.asm):00314                        fcc     'UNDER LICENSE FROM MICROSOFT'                                   
                      (    rsdos_mmc.asm):00315                        fcb     cr,cr,0                                
                      (    rsdos_mmc.asm):00316                        endc 
                      (    rsdos_mmc.asm):00317                        
                      (    rsdos_mmc.asm):00318         ;disk basic command interpretation handler
C115 81E1             (    rsdos_mmc.asm):00319         DosCmdDispatch cmpa    #dhitok                  ;compare to highest disk basic token                                                     
C117 2208             (    rsdos_mmc.asm):00320                        bhi     lc244                    ;and branch if higher                              
                      (    rsdos_mmc.asm):00321         
C119 8EE11D           (    rsdos_mmc.asm):00322                        ldx     #CommandDispatchTable    ; point x to disk basic command jump table                                                    
C11C 80CE             (    rsdos_mmc.asm):00323                        suba    #$ce                     ; subtract out lowest disk basic command token                                                       
C11E 7EADD4           (    rsdos_mmc.asm):00324                        jmp     BasDoDispatch            ; jump to basic's command handler                                          
                      (    rsdos_mmc.asm):00325         
                      (    rsdos_mmc.asm):00326         
C121 81E1             (    rsdos_mmc.asm):00327         lc244          cmpa    #dhitok                  ; compare to highest disk basic token                                                      
C123 1023F150         (    rsdos_mmc.asm):00328                        lbls    BasSNError               ; 'syntax' error if < disk basic command token                                                        
                      (    rsdos_mmc.asm):00329         
C127 6E9F0141         (    rsdos_mmc.asm):00330                        jmp     [BasStub3+3]             ; process a user command token                                             
                      (    rsdos_mmc.asm):00331         
                      (    rsdos_mmc.asm):00332         
                      (    rsdos_mmc.asm):00333         ;disk basic secondary command interpretation handler
C12B                  (    rsdos_mmc.asm):00334         DosFuncDispatch
C12B C14E             (    rsdos_mmc.asm):00335                        cmpb    #($a7-$80)*2             ;compare modified secondary token to                                                                                    
C12D 2304             (    rsdos_mmc.asm):00336                        bls     lc256                    ;highest disk basic token & branch if higher                                                     
                      (    rsdos_mmc.asm):00337         
C12F 6E9F0146         (    rsdos_mmc.asm):00338                        jmp     [BasStub3+8]             ; jump to user secondary command handler                                                        
                      (    rsdos_mmc.asm):00339         
                      (    rsdos_mmc.asm):00340         
C133 C044             (    rsdos_mmc.asm):00341         lc256          subb    #($a2-$80)*2             ;subtract out the smallest secondary                                                                                    
C135 3404             (    rsdos_mmc.asm):00342                        pshs    b                        ;disk token & save modified token on the stack                                                    
C137 BDB262           (    rsdos_mmc.asm):00343                        jsr     lb262                    ; syntax check for '(' and evaluate expression                                                       
                      (    rsdos_mmc.asm):00344         
                      (    rsdos_mmc.asm):00345         
C13A 3504             (    rsdos_mmc.asm):00346                        puls    b                        ; restore modified token                              
C13C 8EE16B           (    rsdos_mmc.asm):00347                        ldx     #FunctionDipatchTable                   ; point x to secondary command jump table                                                   
C13F 7EB2CE           (    rsdos_mmc.asm):00348                        jmp     lb2ce                    ; jump to basic's secondary command handler                                                    
                      (    rsdos_mmc.asm):00349         
                      (    rsdos_mmc.asm):00350         
                      (    rsdos_mmc.asm):00351         ; error driver ram vector
C142                  (    rsdos_mmc.asm):00352         DosHookSysError
C142 3520             (    rsdos_mmc.asm):00353                        puls    y                        ; put the return address into y                                           
C144 BDAD33           (    rsdos_mmc.asm):00354                        jsr     BasResetStack            ; reset the cont flag, etc                                   
                      (    rsdos_mmc.asm):00355         
C147 BDD1AF           (    rsdos_mmc.asm):00356                        jsr     >CloseFilesInit2                   ; initialize some disk variables and close files                                                         
                      (    rsdos_mmc.asm):00357         
                      (    rsdos_mmc.asm):00358         
C14A 3424             (    rsdos_mmc.asm):00359                        pshs    y,b                      ; put return address and error number on the stack                                                          
C14C BDC9C6           (    rsdos_mmc.asm):00360                        jsr     >DosCloseAllFiles                   ; close all files                          
                      (    rsdos_mmc.asm):00361         
C14F 3504             (    rsdos_mmc.asm):00362                        puls    b                        ; get the error number back                                 
                      (    rsdos_mmc.asm):00363         
C151 C136             (    rsdos_mmc.asm):00364                        cmpb    #2*27                    ; compare to the lowest disk error number                                                                                  
C153 1025C799         (    rsdos_mmc.asm):00365                        lbcs    CoCoVect191              ; branch to exbas error handler if not disk error number                                                                   
                      (    rsdos_mmc.asm):00366         
C157 3262             (    rsdos_mmc.asm):00367                        leas    $02,s                    ; purge return address off the stack                                              
C159 BDA7E9           (    rsdos_mmc.asm):00368                        jsr     la7e9                    ; turn off the cassette motor                                      
                      (    rsdos_mmc.asm):00369         
C15C BDA974           (    rsdos_mmc.asm):00370                        jsr     SndDisable               ; disable the analog multiplexer                                         
                      (    rsdos_mmc.asm):00371         
                      (    rsdos_mmc.asm):00372         
C15F 0F6F             (    rsdos_mmc.asm):00373                        clr     TextDevN                 ; set device number to the screen                                           
C161 BDB95C           (    rsdos_mmc.asm):00374                        jsr     lb95c                    ; send a cr to the screen                                  
                      (    rsdos_mmc.asm):00375         
C164 BDB9AF           (    rsdos_mmc.asm):00376                        jsr     TextOutQuestion          ; send a '?' to the screen                                   
                      (    rsdos_mmc.asm):00377         
C167 8EC137           (    rsdos_mmc.asm):00378                        ldx     #DosErrorCodeTable-(2*27)            ; point x to disk basic's error table                                                                           
C16A 7EAC60           (    rsdos_mmc.asm):00379                        jmp     SysErr2                  ; jump to basic's error handler                                        
                      (    rsdos_mmc.asm):00380         
                      (    rsdos_mmc.asm):00381         
                      (    rsdos_mmc.asm):00382         ; disk basic error messages
C16D                  (    rsdos_mmc.asm):00383         DosErrorCodeTable          
C16D 4252             (    rsdos_mmc.asm):00384                         fcc     'BR'                    ; 27 bad record                            
C16F 4446             (    rsdos_mmc.asm):00385                         fcc     'DF'                    ; 28 disk full                      
C171 4F42             (    rsdos_mmc.asm):00386                         fcc     'OB'                    ; 29 out of buffer space                                
C173 5750             (    rsdos_mmc.asm):00387                         fcc     'WP'                    ; 30 write protected                            
C175 464E             (    rsdos_mmc.asm):00388                         fcc     'FN'                    ; 31 bad file name                          
C177 4653             (    rsdos_mmc.asm):00389                         fcc     'FS'                    ; 32 bad file structure                               
C179 4145             (    rsdos_mmc.asm):00390                         fcc     'AE'                    ; 33 file already exists                                
C17B 464F             (    rsdos_mmc.asm):00391                         fcc     'FO'                    ; 34 field overflow                           
C17D 5345             (    rsdos_mmc.asm):00392                         fcc     'SE'                    ; 35 set to non-fielded string                                      
C17F 5646             (    rsdos_mmc.asm):00393                         fcc     'VF'                    ; 36 verification error                               
C181 4552             (    rsdos_mmc.asm):00394                         fcc     'ER'                    ; 37 write or input past end of record                                              
                      (    rsdos_mmc.asm):00395                                 
                      (    rsdos_mmc.asm):00396         ; disk file extensions
C183 424153           (    rsdos_mmc.asm):00397         basext          fcc     'BAS'                   ; basic file extension                                     
C186 202020           (    rsdos_mmc.asm):00398         defext          fcc     '   '                   ; ' blank (default) file extension                                             
C189 444154           (    rsdos_mmc.asm):00399         datext          fcc     'DAT'                   ; data file extension                                    
C18C 42494E           (    rsdos_mmc.asm):00400         binext          fcc     'BIN'                   ; binary file extension                                      
                      (    rsdos_mmc.asm):00401                                 
                      (    rsdos_mmc.asm):00402         ; cls ram vector
C18F 3411             (    rsdos_mmc.asm):00403         DosHookGetPutCLS         pshs    x,cc                     ; save x reg and status                                      
C191 AE63             (    rsdos_mmc.asm):00404                        ldx     $03,s                    ; load x with calling address                                      
C193 8C975F           (    rsdos_mmc.asm):00405                        cmpx    #l975f                   ; coming from exbas' get/put?                                        
C196 2604             (    rsdos_mmc.asm):00406                        bne     lc2bf                    ; no             
                      (    rsdos_mmc.asm):00407         
C198 8123             (    rsdos_mmc.asm):00408                        cmpa    #'#                      ; number sign (get#, put#)?                                    
C19A 2702             (    rsdos_mmc.asm):00409                        beq     lc2c1                    ; branch if get or put to random file                                              
                      (    rsdos_mmc.asm):00410         
C19C 3591             (    rsdos_mmc.asm):00411         lc2bf          puls    cc,x,pc                  ; restore x reg, status and return                                                   
                      (    rsdos_mmc.asm):00412         
                      (    rsdos_mmc.asm):00413         ; get/put to a direct/random file
C19E 3265             (    rsdos_mmc.asm):00414         lc2c1          leas    $05,s                    ; purge return address and registers off of the stack                                                                    
C1A0 BDC70B           (    rsdos_mmc.asm):00415                        jsr     >lc82e                   ; evaluate device number & set fcb pointer                                                   
                      (    rsdos_mmc.asm):00416         
C1A3 9FF1             (    rsdos_mmc.asm):00417                        stx     fcbtmp                   ; save fcb pointer                            
C1A5 6F8815           (    rsdos_mmc.asm):00418                        clr     fcbget,x                 ; reset the get                           
C1A8 6F8816           (    rsdos_mmc.asm):00419                        clr     fcbget+1,x               ; data pointer                            
C1AB 6F8817           (    rsdos_mmc.asm):00420                        clr     fcbput,x                 ; = reset the put                             
C1AE 6F8818           (    rsdos_mmc.asm):00421                        clr     fcbput+1,x               ; = data pointer                              
C1B1 6F06             (    rsdos_mmc.asm):00422                        clr     fcbpos,x                 ; reset print position counter                                          
C1B3 A601             (    rsdos_mmc.asm):00423                        lda     fcbdrv,x                 ;get the fcb drive number and                                         
C1B5 97EB             (    rsdos_mmc.asm):00424                        sta     dcdrv                    ;save it in dskcon variable                                    
C1B7 9DA5             (    rsdos_mmc.asm):00425                        jsr     BasChrGetCurr            ; get current input character from basic                                                  
                      (    rsdos_mmc.asm):00426         
C1B9 270C             (    rsdos_mmc.asm):00427                        beq     lc2ea                    ; branch if end of line                                
                      (    rsdos_mmc.asm):00428         
C1BB BDB26D           (    rsdos_mmc.asm):00429                        jsr     VarCKComma               ; syntax check for comma                                    
                      (    rsdos_mmc.asm):00430         
C1BE BDB73D           (    rsdos_mmc.asm):00431                        jsr     VarGet16Bit              ; evaluate expression - return in (x)                                              
                      (    rsdos_mmc.asm):00432         
C1C1 1F10             (    rsdos_mmc.asm):00433                        tfr     x,d                      ; save record number in accd                                   
C1C3 9EF1             (    rsdos_mmc.asm):00434         lc2e6          ldx     fcbtmp                   ; point x to fcb                               
C1C5 ED07             (    rsdos_mmc.asm):00435                        std     fcbrec,x                 ; save record number in fcb                                       
C1C7 EC07             (    rsdos_mmc.asm):00436         lc2ea          ldd     fcbrec,x                 ; get record number                                    
C1C9 271D             (    rsdos_mmc.asm):00437                        beq     lc30b                    ; 'bad record' error if record number = 0                                                  
                      (    rsdos_mmc.asm):00438         
C1CB BDC562           (    rsdos_mmc.asm):00439                        jsr     >lc685                   ; increment record number                                  
                      (    rsdos_mmc.asm):00440         
C1CE EC09             (    rsdos_mmc.asm):00441                        ldd     fcbrln,x                 ; get random file record length and random file                                                           
C1D0 AE0B             (    rsdos_mmc.asm):00442                        ldx     fcbbuf,x                 ; buffer pointer and save them on the stack -                                                         
C1D2 3416             (    rsdos_mmc.asm):00443                        pshs    x,b,a                    ; these are the initial values of a temporary                                                       
                      (    rsdos_mmc.asm):00444                                                         ; record length counter and random buffer
                      (    rsdos_mmc.asm):00445                                                         ; pointer which are maintained on the stack
C1D4 305E             (    rsdos_mmc.asm):00446                        leax    $-2,u                    ; point x to (record number -1)                                         
C1D6 BD9FB5           (    rsdos_mmc.asm):00447                        jsr     l9fb5                    ; mult (unsigned) record length x (record number -1)                                                             
                      (    rsdos_mmc.asm):00448         
C1D9 3460             (    rsdos_mmc.asm):00449                        pshs    u,y                      ; save product on the stack                                   
C1DB A6E0             (    rsdos_mmc.asm):00450                        lda     ,s+                      ; check ms byte of product                                 
C1DD 2609             (    rsdos_mmc.asm):00451                        bne     lc30b                    ; 'br' error if not zero (record number too big)                                                         
                      (    rsdos_mmc.asm):00452         
C1DF 3510             (    rsdos_mmc.asm):00453                        puls    x                        ; pull the bottom 3 product bytes off the stack;                                                      
C1E1 3504             (    rsdos_mmc.asm):00454                        puls    b                        ; top two in x, bottom in accb; accb points to                                                    
                      (    rsdos_mmc.asm):00455                                                         ; the first byte of the sector used by this record,
                      (    rsdos_mmc.asm):00456                                                         ; (x) contains the sector offset (in which sector
                      (    rsdos_mmc.asm):00457                                                         ; from the start the byte is located)
C1E3 8C0264           (    rsdos_mmc.asm):00458         lc306          cmpx    #(trkmax-1)*secmax       ; 612 sectors max in a random file                                                       
C1E6 2505             (    rsdos_mmc.asm):00459                        blo     lc310                    ; branch if record length o.k.                                       
                      (    rsdos_mmc.asm):00460         
C1E8 C636             (    rsdos_mmc.asm):00461         lc30b          ldb     #2*27                    ; 'bad record' error                                                            
C1EA 7EAC46           (    rsdos_mmc.asm):00462                        jmp     SysErr                   ; jump to error handler                                
                      (    rsdos_mmc.asm):00463         
C1ED DEF1             (    rsdos_mmc.asm):00464         lc310          ldu     fcbtmp                   ; point u to fcb                               
C1EF AC4D             (    rsdos_mmc.asm):00465                        cmpx    fcbsof,u                 ; compare saved sector offset to the current sector offset                                                                       
C1F1 102700B7         (    rsdos_mmc.asm):00466                        lbeq    lc3cf                    ; being processed - do not process a new sector if they are equal                                                                           
                      (    rsdos_mmc.asm):00467         
C1F5 3414             (    rsdos_mmc.asm):00468                        pshs    x,b                      ; save byte and sector offset to record start on stack                                                              
C1F7 A64F             (    rsdos_mmc.asm):00469                        lda     fcbflg,u                 ; check fcb get/put flag and                                        
C1F9 2706             (    rsdos_mmc.asm):00470                        beq     lc324                    ; branch if it was a get                                 
                      (    rsdos_mmc.asm):00471         
C1FB 6F4F             (    rsdos_mmc.asm):00472                        clr     fcbflg,u                 ; force get/put to 'put'                                    
C1FD C603             (    rsdos_mmc.asm):00473                        ldb     #$03                     ; dskcon write op code                              
C1FF 8D33             (    rsdos_mmc.asm):00474                        bsr     lc357                    ; go write a sector - save 'put' data on disk                                                      
                      (    rsdos_mmc.asm):00475         
                      (    rsdos_mmc.asm):00476         
                      (    rsdos_mmc.asm):00477         ;; convert the sector offset to a granule and sector number
C201 EC61             (    rsdos_mmc.asm):00478         lc324          ldd     $01,s                    ; get the number of sectors to the start of                                                         
C203 BDC661           (    rsdos_mmc.asm):00479                        jsr     >lc784                   ; this record number and convert them to a granule offset                                                                  
                      (    rsdos_mmc.asm):00480         
C206 3404             (    rsdos_mmc.asm):00481                        pshs    b                        ; save granule offset on the stack                                        
C208 BDC656           (    rsdos_mmc.asm):00482                        jsr     >lc779                   ; multiply granule number x 9 - convert to number of sectors                                                                     
                      (    rsdos_mmc.asm):00483         
C20B 50               (    rsdos_mmc.asm):00484                        negb                             ; negate ls byte of granule offset and add the                                                   
C20C EB63             (    rsdos_mmc.asm):00485                        addb    $03,s                    ; ls byte of sector offset - accb = sector                                                    
                      (    rsdos_mmc.asm):00486                                                         ; number (0-8) corresponding to the sector number within a
                      (    rsdos_mmc.asm):00487                                                         ; granule of the last sector of the sector offset
C20E 5C               (    rsdos_mmc.asm):00488                        incb                             ; = add one - sectors saved in the fcb; start                                                  
C20F E744             (    rsdos_mmc.asm):00489                        stb     fcbsec,u                 ; = at 1 not 0 - save it in the fcb                                               
C211 E642             (    rsdos_mmc.asm):00490                        ldb     fcbfgr,u                 ; get first granule in file                                       
C213 BDC632           (    rsdos_mmc.asm):00491                        jsr     >lc755                   ; point x to fat                         
                      (    rsdos_mmc.asm):00492         
C216 3306             (    rsdos_mmc.asm):00493                        leau    fatcon,x                 ; point u to fat data                                  
C218 A6E4             (    rsdos_mmc.asm):00494                        lda     ,s                       ; get number of granules offset to record                                               
C21A 4C               (    rsdos_mmc.asm):00495                        inca                             ; add one (compensate for deca below)                                          
C21B 30C4             (    rsdos_mmc.asm):00496         lc33e          leax    ,u                       ; point x to fat data                                 
C21D 3A               (    rsdos_mmc.asm):00497                        abx                              ; point x to correct granule                                
C21E 4A               (    rsdos_mmc.asm):00498                        deca                             ; decrement granule counter                                
C21F 2737             (    rsdos_mmc.asm):00499                        beq     lc37b                    ; branch if correct granule found                                          
                      (    rsdos_mmc.asm):00500         
C221 E7E4             (    rsdos_mmc.asm):00501                        stb     ,s                       ; save granule address on stack                                     
C223 E684             (    rsdos_mmc.asm):00502                        ldb     ,x                       ; get next granule in file                                
C225 C1C0             (    rsdos_mmc.asm):00503                        cmpb    #$c0                     ; last granule in file?                                
C227 25F2             (    rsdos_mmc.asm):00504                        blo     lc33e                    ; no - keep looking                            
                      (    rsdos_mmc.asm):00505         
                      (    rsdos_mmc.asm):00506         
                      (    rsdos_mmc.asm):00507         ; the granule being searched for is not presently defined in this random file
C229 E6E4             (    rsdos_mmc.asm):00508                        ldb     ,s                       ; get offset to last granule                                  
C22B 0DD8             (    rsdos_mmc.asm):00509                        tst     vd8                      ; check get/put flag                           
C22D 2614             (    rsdos_mmc.asm):00510                        bne     lc366                    ; and branch if put                            
                      (    rsdos_mmc.asm):00511         
C22F C62E             (    rsdos_mmc.asm):00512         lc352          ldb     #2*23                    ;'input past end of file' error                                                                        
C231 7EAC46           (    rsdos_mmc.asm):00513                        jmp     SysErr                   ; jump to error handler                                
                      (    rsdos_mmc.asm):00514         
C234 30C819           (    rsdos_mmc.asm):00515         lc357          leax    fcbcon,u                 ; point x to fcb data buffer                                              
                      (    rsdos_mmc.asm):00516         
                      (    rsdos_mmc.asm):00517         ; read/write a sector. enter with op code in accb, buffer ptr in x
C237 D7EA             (    rsdos_mmc.asm):00518         lc35a          stb     dcopc                    ; save dskcon operation code variable                                                   
C239 9FEE             (    rsdos_mmc.asm):00519                        stx     dcbpt                    ; save dskcon load buffer variable                                           
C23B 30C4             (    rsdos_mmc.asm):00520                        leax    ,u                       ; point x to fcb                       
C23D BDC640           (    rsdos_mmc.asm):00521                        jsr     >lc763                   ; convert fcb track and sector to dskcon variables                                                           
                      (    rsdos_mmc.asm):00522         
C240 7ED4B5           (    rsdos_mmc.asm):00523                        jmp     >DoDiskReadWrite                   ; read/write a track or sector                                       
                      (    rsdos_mmc.asm):00524         
                      (    rsdos_mmc.asm):00525         
                      (    rsdos_mmc.asm):00526         ; 'put' data into a granule not presently included in this file
C243 3412             (    rsdos_mmc.asm):00527         lc366          pshs    x,a                      ; save granule counter and pointer to last used granule                                                                    
C245 BDC69C           (    rsdos_mmc.asm):00528                        jsr     >lc7bf                   ; find first free granule in fat                                         
                      (    rsdos_mmc.asm):00529         
C248 1F89             (    rsdos_mmc.asm):00530                        tfr     a,b                      ; save free granule number in accb                                         
C24A 3542             (    rsdos_mmc.asm):00531                        puls    a,u                      ; pull last granule pointer and counter off of stack                                                            
C24C E7C4             (    rsdos_mmc.asm):00532                        stb     ,u                       ; save newly found granule number in address of last granule                                                                  
C24E 4A               (    rsdos_mmc.asm):00533                        deca                             ; decrement granule counter                                
C24F 26F2             (    rsdos_mmc.asm):00534                        bne     lc366                    ; get another granule if not done                                          
                      (    rsdos_mmc.asm):00535         
C251 3414             (    rsdos_mmc.asm):00536                        pshs    x,b                      ; save pointer to last granule and offset                                                 
C253 BDC5FB           (    rsdos_mmc.asm):00537                        jsr     >lc71e                   ; write fat to disk                            
                      (    rsdos_mmc.asm):00538         
C256 3514             (    rsdos_mmc.asm):00539                        puls    b,x                      ; restore pointer and offset                                    
                      (    rsdos_mmc.asm):00540         
                      (    rsdos_mmc.asm):00541         ; when correct granule is found, find the right sector
C258 3261             (    rsdos_mmc.asm):00542         lc37b          leas    $01,s                    ; remove gran number from stack                                              
C25A DEF1             (    rsdos_mmc.asm):00543                        ldu     fcbtmp                   ; point u to fcb                          
C25C E743             (    rsdos_mmc.asm):00544                        stb     fcbcgr,u                 ; save current granule in fcb                                         
C25E 86FF             (    rsdos_mmc.asm):00545                        lda     #$ff                     ;set fcbsof,u to illegal sector offset which will                                                         
C260 A74D             (    rsdos_mmc.asm):00546                        sta     fcbsof,u                 ;force new sector data to be read in                                                
C262 A684             (    rsdos_mmc.asm):00547                        lda     ,x                       ; get current granule                           
C264 81C0             (    rsdos_mmc.asm):00548                        cmpa    #$c0                     ; is it the last granule?                                  
C266 2527             (    rsdos_mmc.asm):00549                        blo     lc3b2                    ; no             
                      (    rsdos_mmc.asm):00550         
C268 843F             (    rsdos_mmc.asm):00551                        anda    #$3f                     ; mask off last granule flag bits                                          
C26A A144             (    rsdos_mmc.asm):00552                        cmpa    fcbsec,u                 ; compare calculated sector to current sector in fcb                                                                 
C26C 2421             (    rsdos_mmc.asm):00553                        bhs     lc3b2                    ; and branch if calculated sector is > last sector in file                                                                   
                      (    rsdos_mmc.asm):00554         
C26E 96D8             (    rsdos_mmc.asm):00555                        lda     vd8                      ; = check get/put flag: if 'get' then 'input                                                   
C270 27BD             (    rsdos_mmc.asm):00556                        beq     lc352                    ; = past end of file' error                                    
                      (    rsdos_mmc.asm):00557         
C272 A644             (    rsdos_mmc.asm):00558                        lda     fcbsec,u                 ; get current sector number from fcb,                                                 
C274 8AC0             (    rsdos_mmc.asm):00559                        ora     #$c0                     ; or in the last granule flag bits                                          
C276 A784             (    rsdos_mmc.asm):00560                        sta     ,x                       ; and save in fat                       
C278 BDC486           (    rsdos_mmc.asm):00561                        jsr     >lc5a9                   ; write fat to disk if necessary                                         
                      (    rsdos_mmc.asm):00562         
C27B AE49             (    rsdos_mmc.asm):00563                        ldx     fcbrln,u                 ; get record length and check to                                            
C27D 8C0100           (    rsdos_mmc.asm):00564                        cmpx    #seclen                  ; see if it is seclen (exactly one sector)                                                      
C280 2608             (    rsdos_mmc.asm):00565                        bne     lc3ad                    ; branch if it is not exactly one sector                                                 
                      (    rsdos_mmc.asm):00566         
C282 ACC813           (    rsdos_mmc.asm):00567                        cmpx    fcblst,u                 ; =branch if the number of bytes in the last sector                                                                
                      (    rsdos_mmc.asm):00568         
C285 2708             (    rsdos_mmc.asm):00569                        beq     lc3b2                    ; =is set to one sector (seclen)                                         
                      (    rsdos_mmc.asm):00570         
C287 8681             (    rsdos_mmc.asm):00571                        lda     #$81                     ;set the presaved flag (bit15) and force                                                
C289 21               (    rsdos_mmc.asm):00572         lc3ac          fcb      Skip1                    ;brn
C28A 4F               (    rsdos_mmc.asm):00573         lc3ad          clra                             ; set the number of bytes in last sector to zero                                                          
C28B 5F               (    rsdos_mmc.asm):00574                        clrb                             ; clear ls byte of accd                            
C28C EDC813           (    rsdos_mmc.asm):00575                        std     fcblst,u                 ; save the number of bytes in last sector                                                     
                      (    rsdos_mmc.asm):00576         
C28F C602             (    rsdos_mmc.asm):00577         lc3b2          ldb     #$02                     ; dskcon read op code                                  
C291 AE49             (    rsdos_mmc.asm):00578                        ldx     fcbrln,u                 ; get record length and compare                                           
C293 8C0100           (    rsdos_mmc.asm):00579                        cmpx    #seclen                  ; it to seclen - exactly one sector                                               
C296 260D             (    rsdos_mmc.asm):00580                        bne     lc3c8                    ; branch if not exactly one sector long                                                
                      (    rsdos_mmc.asm):00581         
C298 3267             (    rsdos_mmc.asm):00582                        leas    $07,s                    ; clean up stack                          
C29A AE4B             (    rsdos_mmc.asm):00583                        ldx     fcbbuf,u                 ; point x to start of random file buffer                                                    
C29C 96D8             (    rsdos_mmc.asm):00584                        lda     vd8                      ; check get/put flag and                               
C29E 2702             (    rsdos_mmc.asm):00585                        beq     lc3c5                    ; branch if get                        
                      (    rsdos_mmc.asm):00586         
C2A0 C603             (    rsdos_mmc.asm):00587                        ldb     #$03                     ; dskcon write op code                              
C2A2 7EC237           (    rsdos_mmc.asm):00588         lc3c5          jmp     >lc35a                   ; read/write a sector                                   
                      (    rsdos_mmc.asm):00589         
C2A5 BDC234           (    rsdos_mmc.asm):00590         lc3c8          jsr     >lc357                   ; read a sector into fcb data buffer                                                  
                      (    rsdos_mmc.asm):00591         
C2A8 3514             (    rsdos_mmc.asm):00592                        puls    b,x                      ; get back the byte offset to record: x = number of                                                           
                      (    rsdos_mmc.asm):00593                                                         ; sectors; accb = byte pointer in sector
C2AA AF4D             (    rsdos_mmc.asm):00594                        stx     fcbsof,u                 ; save sector offset in fcb                                       
C2AC 3404             (    rsdos_mmc.asm):00595         lc3cf          pshs    b                        ; save byte offset on stack                                      
C2AE BDC632           (    rsdos_mmc.asm):00596                        jsr     >lc755                   ; point x to file allocation table                                           
                      (    rsdos_mmc.asm):00597         
C2B1 3006             (    rsdos_mmc.asm):00598                        leax    fatcon,x                 ; move x to fat data                                 
C2B3 E643             (    rsdos_mmc.asm):00599                        ldb     fcbcgr,u                 ; get current granule number                                        
C2B5 3A               (    rsdos_mmc.asm):00600                        abx                              ; point x to proper granule in fat                                      
C2B6 A684             (    rsdos_mmc.asm):00601                        lda     ,x                       ; get current granule and check to                                        
C2B8 81C0             (    rsdos_mmc.asm):00602                        cmpa    #$c0                     ; see if it is last granule                                    
C2BA 252B             (    rsdos_mmc.asm):00603                        blo     lc40a                    ; branch if this granule is < last granule                                                   
                      (    rsdos_mmc.asm):00604         
C2BC 843F             (    rsdos_mmc.asm):00605                        anda    #$3f                     ; mask off last granule flag bits                                          
C2BE A144             (    rsdos_mmc.asm):00606                        cmpa    fcbsec,u                 ; compare last sector used in granule to                                                     
C2C0 2625             (    rsdos_mmc.asm):00607                        bne     lc40a                    ; calculated sector; branch if not equal                                                 
                      (    rsdos_mmc.asm):00608         
C2C2 ECC813           (    rsdos_mmc.asm):00609                        ldd     fcblst,u                 ; get number of bytes in last sector                                                
                      (    rsdos_mmc.asm):00610         
C2C5 847F             (    rsdos_mmc.asm):00611                        anda    #$7f                     ; mask off presaved flag (bit 15)                                          
C2C7 3406             (    rsdos_mmc.asm):00612                        pshs    b,a                      ; save number of bytes in last sector on stack                                                      
C2C9 4F               (    rsdos_mmc.asm):00613                        clra                             ; load accb with the byte offset to current                                                
C2CA E662             (    rsdos_mmc.asm):00614                        ldb     $02,s                    ; record and add the remaining record length                                                     
C2CC E363             (    rsdos_mmc.asm):00615                        addd    $03,s                    ; to it - accd = end of record offset                                               
C2CE 10A3E1           (    rsdos_mmc.asm):00616                        cmpd    ,s++                     ; =compare the end of record offset to the number of                                                             
C2D1 2314             (    rsdos_mmc.asm):00617                        bls     lc40a                    ; =bytes used in the last sector                                         
                      (    rsdos_mmc.asm):00618         
C2D3 0DD8             (    rsdos_mmc.asm):00619                        tst     vd8                      ; check get/put flag and branch if 'get'                                               
C2D5 1027FF56         (    rsdos_mmc.asm):00620                        lbeq    lc352                    ; to 'input past end of file' error                                             
                      (    rsdos_mmc.asm):00621         
                      (    rsdos_mmc.asm):00622         
                      (    rsdos_mmc.asm):00623         ; if last used sector, calculate how many bytes are used
                      (    rsdos_mmc.asm):00624         ; if data is being 'put' pasth the current end of file
C2D9 10830100         (    rsdos_mmc.asm):00625                        cmpd    #seclen                  ; compare to one sector's length                                            
C2DD 2303             (    rsdos_mmc.asm):00626                        bls     lc405                    ; branch if remainder of record length will fit in this sector                                                                       
                      (    rsdos_mmc.asm):00627         
C2DF CC0100           (    rsdos_mmc.asm):00628                        ldd     #seclen                  ; force number of bytes = one sector length                                                      
C2E2 8A80             (    rsdos_mmc.asm):00629         lc405          ora     #$80                     ; set pre-saved flag bit - all put records are                                                           
                      (    rsdos_mmc.asm):00630                                                         ; written to disk before leaving 'put'
C2E4 EDC813           (    rsdos_mmc.asm):00631                        std     fcblst,u                 ; save number of bytes used in last sector                                                      
                      (    rsdos_mmc.asm):00632         
C2E7 3504             (    rsdos_mmc.asm):00633         lc40a          puls    b                        ; pull byte offset off of the stack                                              
C2E9 30C819           (    rsdos_mmc.asm):00634                        leax    fcbcon,u                 ; point x to fcb data buffer                                         
C2EC 3A               (    rsdos_mmc.asm):00635                        abx                              ; move x to start of record                               
C2ED EE62             (    rsdos_mmc.asm):00636                        ldu     $02,s                    ; point u to current position in random file buffer                                                            
C2EF 3404             (    rsdos_mmc.asm):00637                        pshs    b                        ; save byte offset on stack                                 
C2F1 86FF             (    rsdos_mmc.asm):00638                        lda     #-1                      ; convert accd into a negative 2 byte number                                                   
                      (    rsdos_mmc.asm):00639                                                         ; representing the remaining unused bytes in the sector
C2F3 E361             (    rsdos_mmc.asm):00640                        addd    $01,s                    ; add temporary record length counter (subtract                                                         
                      (    rsdos_mmc.asm):00641                                                         ; remaining bytes from temporary record length)
C2F5 2407             (    rsdos_mmc.asm):00642                        bhs     lc421                    ; branch if there are enough unused bytes to finish the record                                                                       
                      (    rsdos_mmc.asm):00643         
C2F7 ED61             (    rsdos_mmc.asm):00644                        std     $01,s                    ; save new temporary record length counter                                                   
C2F9 3504             (    rsdos_mmc.asm):00645                        puls    b                        ; restore byte counter                            
C2FB 50               (    rsdos_mmc.asm):00646                        negb                             ; negate it - accb = the number of bytes                                             
                      (    rsdos_mmc.asm):00647                                                         ; available to a record in this sector
C2FC 2008             (    rsdos_mmc.asm):00648                        bra     lc429                    ; move the data                        
                      (    rsdos_mmc.asm):00649         
                      (    rsdos_mmc.asm):00650         ; branch here if remaining record length will fit in
                      (    rsdos_mmc.asm):00651         ; what's left of the currently selected sector
C2FE E662             (    rsdos_mmc.asm):00652         lc421          ldb     $02,s                    ; get remaining record length                                           
C300 6F61             (    rsdos_mmc.asm):00653                        clr     $01,s                    ; clear the temporary record length                                            
C302 6F62             (    rsdos_mmc.asm):00654                        clr     $02,s                    ; counter on the stack                               
C304 3261             (    rsdos_mmc.asm):00655                        leas    $01,s                    ; purge byte offset from stack                                        
C306 96D8             (    rsdos_mmc.asm):00656         lc429          lda     vd8                      ; check get/put flag and                                    
C308 2702             (    rsdos_mmc.asm):00657                        beq     lc42f                    ; branch if get                        
                      (    rsdos_mmc.asm):00658         
C30A 1E13             (    rsdos_mmc.asm):00659                        exg     x,u                      ; swap source and destination pointers                                             
C30C BDA59A           (    rsdos_mmc.asm):00660         lc42f          jsr     UtilCopyBXtoU            ; transfer data from source to destination buffers                                                                
                      (    rsdos_mmc.asm):00661         
C30F EF62             (    rsdos_mmc.asm):00662                        stu     $02,s                    ; save new temp record pointer on the stack (get)                                                          
                      (    rsdos_mmc.asm):00663         
                      (    rsdos_mmc.asm):00664         ; move data from fcb data buffer to the random file buffer if 'get'
                      (    rsdos_mmc.asm):00665         ; or from random file buffer to fcb data buffer if 'put'
C311 DEF1             (    rsdos_mmc.asm):00666                        ldu     fcbtmp                   ; point u to fcb                          
C313 96D8             (    rsdos_mmc.asm):00667                        lda     vd8                      ; check get/put flag and                               
C315 2704             (    rsdos_mmc.asm):00668                        beq     lc43e                    ; branch if get                        
                      (    rsdos_mmc.asm):00669         
C317 A74F             (    rsdos_mmc.asm):00670                        sta     fcbflg,u                 ; save 'put' flag in the fcb                                        
C319 AF62             (    rsdos_mmc.asm):00671                        stx     $02,s                    ; save new temporary record pointer on stack (put)                                                           
C31B AE4D             (    rsdos_mmc.asm):00672         lc43e          ldx     fcbsof,u                 ; get sector offset counter and                                                
C31D 3001             (    rsdos_mmc.asm):00673                        leax    $01,x                    ; add one to it                         
C31F 5F               (    rsdos_mmc.asm):00674                        clrb                             ; set byte offset = 0                          
C320 EEE4             (    rsdos_mmc.asm):00675                        ldu     ,s                       ; check the length of the temporary record length                                                       
C322 1026FEBD         (    rsdos_mmc.asm):00676                        lbne    lc306                    ; counter and keep moving data if <> 0                                                
                      (    rsdos_mmc.asm):00677         
C326 3596             (    rsdos_mmc.asm):00678                        puls    a,b,x,pc                 ; pull temporary record length and                                               
                      (    rsdos_mmc.asm):00679                                                         ; buffer address off stack and return
                      (    rsdos_mmc.asm):00680         
                      (    rsdos_mmc.asm):00681         ; open ram hook
C328                  (    rsdos_mmc.asm):00682         DosHookOpenDev 
C328 3262             (    rsdos_mmc.asm):00683                        leas    $02,s                    ; pull return address off of the stack                                                     
C32A BDB156           (    rsdos_mmc.asm):00684                        jsr     VarGetStr                ; evaluate an expression                                 
                      (    rsdos_mmc.asm):00685         
C32D BDB6A4           (    rsdos_mmc.asm):00686                        jsr     BasGetStrFirst           ;get mode(i,o,r) - first byte of string expression                                                           
                      (    rsdos_mmc.asm):00687         
C330 3404             (    rsdos_mmc.asm):00688                        pshs    b                        ;and save it on stack                           
C332 BDA5A2           (    rsdos_mmc.asm):00689                        jsr     BasGetDevNo              ; get device number                            
                      (    rsdos_mmc.asm):00690         
C335 5D               (    rsdos_mmc.asm):00691                        tstb                             ; set flags                
C336 102FE2C9         (    rsdos_mmc.asm):00692                        lble    CmdOpenEntry             ; branch if not a disk file                                     
C33A 3502             (    rsdos_mmc.asm):00693                        puls    a                        ; get mode                
C33C 3406             (    rsdos_mmc.asm):00694                        pshs    b,a                      ; save mode and device number (file number)                                                   
C33E 0F6F             (    rsdos_mmc.asm):00695                        clr     TextDevN                 ; set device number to screen                                       
C340 BDB26D           (    rsdos_mmc.asm):00696                        jsr     VarCKComma               ; syntax check for comma                                    
                      (    rsdos_mmc.asm):00697         
C343 8EC189           (    rsdos_mmc.asm):00698                        ldx     #datext                  ; point to 'dat' for extension                                         
C346 BDC815           (    rsdos_mmc.asm):00699                        jsr     >lc938                   ; get filename from basic                                  
                      (    rsdos_mmc.asm):00700         
C349 CC01FF           (    rsdos_mmc.asm):00701                        ldd     #$01ff                   ; default disk file type and ascii flag                                                 
C34C FD0957           (    rsdos_mmc.asm):00702                        std     dfltyp                   ; save default values: data, ascii                                            
C34F 8E0100           (    rsdos_mmc.asm):00703                        ldx     #seclen                  ; default record length - 1 page                                           
C352 9DA5             (    rsdos_mmc.asm):00704                        jsr     BasChrGetCurr            ; get char from basic                               
                      (    rsdos_mmc.asm):00705         
C354 2708             (    rsdos_mmc.asm):00706                        beq     lc481                    ; branch if end of line                                
                      (    rsdos_mmc.asm):00707         
C356 BDB26D           (    rsdos_mmc.asm):00708                        jsr     VarCKComma               ; syntax check for comma                                    
                      (    rsdos_mmc.asm):00709         
C359 BDB3E6           (    rsdos_mmc.asm):00710                        jsr     lb3e6                    ; evaluate expression                              
                      (    rsdos_mmc.asm):00711         
C35C 9E52             (    rsdos_mmc.asm):00712                        ldx     BasVarFPAcc1+3           ; get evaluated expression                                    
C35E BF097C           (    rsdos_mmc.asm):00713         lc481          stx     dfflen                   ; record length                              
C361 1027F0E5         (    rsdos_mmc.asm):00714                        lbeq    BasFCError               ; if = 0, then 'illegal function call'                                                
                      (    rsdos_mmc.asm):00715         
C365 BDA5C7           (    rsdos_mmc.asm):00716                        jsr     la5c7                    ; error if any further characters on line                                                  
                      (    rsdos_mmc.asm):00717         
C368 3506             (    rsdos_mmc.asm):00718                        puls    a,b                      ; get mode and file number                                  
                      (    rsdos_mmc.asm):00719         
                      (    rsdos_mmc.asm):00720         ; open disk file for read or write
C36A 3402             (    rsdos_mmc.asm):00721         lc48d          pshs    a                        ; save mode on stack                               
C36C BDC626           (    rsdos_mmc.asm):00722                        jsr     >lc749                   ; point x to fcb for this file                                       
                      (    rsdos_mmc.asm):00723         
C36F 1026E2A9         (    rsdos_mmc.asm):00724                        lbne    la61c                    ; 'file already open' error if file open                                                  
                      (    rsdos_mmc.asm):00725         
C373 9FF1             (    rsdos_mmc.asm):00726                        stx     fcbtmp                   ; save file buffer pointer                                    
C375 BDC67A           (    rsdos_mmc.asm):00727                        jsr     >GetFAT                   ; make sure file alloc table is valid                                              
                      (    rsdos_mmc.asm):00728         
C378 BDC569           (    rsdos_mmc.asm):00729                        jsr     >lc68c                   ; scan directory for 'filename.ext'                                            
                      (    rsdos_mmc.asm):00730         
C37B 3504             (    rsdos_mmc.asm):00731                        puls    b                        ; get mode                
C37D 8610             (    rsdos_mmc.asm):00732                        lda     #inpfil                  ; input type file                            
C37F 3402             (    rsdos_mmc.asm):00733                        pshs    a                        ; save file type on stack                               
C381 C149             (    rsdos_mmc.asm):00734                        cmpb    #'I                      ; input mode?                      
C383 261F             (    rsdos_mmc.asm):00735                        bne     lc4c7                    ; branch if not                        
                      (    rsdos_mmc.asm):00736         
                      (    rsdos_mmc.asm):00737         
                      (    rsdos_mmc.asm):00738         ; open a sequential file for input
C385 BDC5C2           (    rsdos_mmc.asm):00739                        jsr     >lc6e5                   ; check to see if directory match is found                                                   
                      (    rsdos_mmc.asm):00740         
C388 BDC6E4           (    rsdos_mmc.asm):00741                        jsr     >lc807                   ; check to see if file already open                                            
                      (    rsdos_mmc.asm):00742         
C38B BE0974           (    rsdos_mmc.asm):00743                        ldx     v974                     ; get ram directory buffer                                  
C38E EC0B             (    rsdos_mmc.asm):00744                        ldd     dirtyp,x                 ; get file type and ascii flag                                          
C390 FD0957           (    rsdos_mmc.asm):00745                        std     dfltyp                   ; save in ram image                             
C393 8D75             (    rsdos_mmc.asm):00746                        bsr      lc52d
                      (    rsdos_mmc.asm):00747         
C395 BDC504           (    rsdos_mmc.asm):00748                        jsr     >lc627                   ; go fill data buffer                              
                      (    rsdos_mmc.asm):00749         
C398 BDC632           (    rsdos_mmc.asm):00750         lc4bb          jsr     >lc755                   ; point x to proper file allocation table                                                       
                      (    rsdos_mmc.asm):00751         
C39B 6C84             (    rsdos_mmc.asm):00752                        inc     fat0,x                   ; add one to fat active file counter                                              
C39D 9EF1             (    rsdos_mmc.asm):00753                        ldx     fcbtmp                   ; get file buffer pointer                                   
C39F 3502             (    rsdos_mmc.asm):00754                        puls    a                        ; get file type                     
C3A1 A784             (    rsdos_mmc.asm):00755                        sta     fcbtyp,x                 ; save it in fcb                            
C3A3 39               (    rsdos_mmc.asm):00756                        rts                                     
                      (    rsdos_mmc.asm):00757         
C3A4 68E4             (    rsdos_mmc.asm):00758         lc4c7          asl     ,s                       ; set file type to output                                    
C3A6 C14F             (    rsdos_mmc.asm):00759                        cmpb    #'O                      ; file mode = output?                              
C3A8 261B             (    rsdos_mmc.asm):00760                        bne     lc4e8                    ; branch if not                        
                      (    rsdos_mmc.asm):00761         
                      (    rsdos_mmc.asm):00762         
                      (    rsdos_mmc.asm):00763         ; open a sequential file for output
C3AA 7D0973           (    rsdos_mmc.asm):00764                        tst     v973                     ; does file exist on directory?                                       
C3AD 270F             (    rsdos_mmc.asm):00765                        beq     lc4e1                    ; branch if not                        
                      (    rsdos_mmc.asm):00766         
C3AF BDC5D9           (    rsdos_mmc.asm):00767                        jsr     >lc6cf                   ; kill the old file                            
                      (    rsdos_mmc.asm):00768         
C3B2 B60973           (    rsdos_mmc.asm):00769                        lda     v973                     ; get directory sector number of old file and                                                     
C3B5 B70977           (    rsdos_mmc.asm):00770                        sta     v977                     ; save it as first free directory entry                                               
C3B8 BE0974           (    rsdos_mmc.asm):00771                        ldx     v974                     ; =get ram directory image of old file and                                                  
C3BB BF0978           (    rsdos_mmc.asm):00772                        stx     v978                     ; =save it as first free directory entry                                                
                      (    rsdos_mmc.asm):00773         
C3BE BDC444           (    rsdos_mmc.asm):00774         lc4e1          jsr     >lc567                   ; set up new directory entry on disk                                                  
                      (    rsdos_mmc.asm):00775         
C3C1 8D52             (    rsdos_mmc.asm):00776                        bsr     lc538                    ; initialize file buffer                                 
                      (    rsdos_mmc.asm):00777         
C3C3 20D3             (    rsdos_mmc.asm):00778                        bra     lc4bb                    ; flag and map fcb as being used                                         
C3C5 C152             (    rsdos_mmc.asm):00779         lc4e8          cmpb    #'R                      ; file mode = r (random)?                                       
C3C7 2706             (    rsdos_mmc.asm):00780                        beq     lc4f2                    ; branch if so                       
                      (    rsdos_mmc.asm):00781         
C3C9 C144             (    rsdos_mmc.asm):00782                        cmpb    #'D                      ; file mode = d (direct)?                                  
C3CB 1026E247         (    rsdos_mmc.asm):00783                        lbne    BasFMError               ; 'bad file mode' error if not                                        
                      (    rsdos_mmc.asm):00784         
                      (    rsdos_mmc.asm):00785         
                      (    rsdos_mmc.asm):00786         ; open a random/direct file
C3CF 68E4             (    rsdos_mmc.asm):00787         lc4f2          asl     ,s                       ; set file type to direct                                    
C3D1 FC0948           (    rsdos_mmc.asm):00788                        ldd     rnbfad                   ; get address of random file buffer area                                                  
C3D4 3406             (    rsdos_mmc.asm):00789                        pshs    b,a                      ; and save it on the stack                                  
C3D6 F3097C           (    rsdos_mmc.asm):00790                        addd    dfflen                   ; add the record length                                  
C3D9 2506             (    rsdos_mmc.asm):00791                        blo     lc504                    ; 'ob' error if sum > $ffff                                    
                      (    rsdos_mmc.asm):00792         
C3DB 10B3094A         (    rsdos_mmc.asm):00793                        cmpd    fcbadr                   ; is it > than fcb data area?                                        
C3DF 2305             (    rsdos_mmc.asm):00794                        bls     lc509                    ; branch if not                        
                      (    rsdos_mmc.asm):00795         
C3E1 C63A             (    rsdos_mmc.asm):00796         lc504          ldb     #2*29                    ;'out of buffer space' error                                                                         
C3E3 7EAC46           (    rsdos_mmc.asm):00797                        jmp     SysErr                   ; jump to error handler                                
                      (    rsdos_mmc.asm):00798         
C3E6 3406             (    rsdos_mmc.asm):00799         lc509          pshs    b,a                      ; save end of random buffer on stack                                                 
C3E8 7D0973           (    rsdos_mmc.asm):00800                        tst     v973                     ; did this file exist                             
C3EB 2604             (    rsdos_mmc.asm):00801                        bne     lc514                    ; branch if so                       
                      (    rsdos_mmc.asm):00802         
C3ED 8D55             (    rsdos_mmc.asm):00803                        bsr     lc567                    ; set up new file in directory                                       
                      (    rsdos_mmc.asm):00804         
C3EF 2005             (    rsdos_mmc.asm):00805                        bra     lc519                    ; initialize fcb                         
C3F1 86FF             (    rsdos_mmc.asm):00806         lc514          lda     #$ff                     ; set file type match = $ff (illegal value) -                                                          
C3F3 BDC6E4           (    rsdos_mmc.asm):00807                        jsr     >lc807                   ; this will force any open matched file to cause                                                         
                      (    rsdos_mmc.asm):00808         
                      (    rsdos_mmc.asm):00809                                                         ; a 'file already open' error
C3F6 8D12             (    rsdos_mmc.asm):00810         lc519          bsr     lc52d                    ; initialize fcb                              
                      (    rsdos_mmc.asm):00811         
C3F8 630D             (    rsdos_mmc.asm):00812                        com     fcbsof,x                 ; set fcbsof,x to $ff (illegal sector offset) which will                                                                    
                      (    rsdos_mmc.asm):00813                                                         ; force new sector data to be read in during get/put
C3FA 6C08             (    rsdos_mmc.asm):00814                        inc     fcbrec+1,x               ; initialize record number = 1                                            
C3FC 3546             (    rsdos_mmc.asm):00815                        puls    a,b,u                    ; u = start of random file buffer area, accd = end                                                            
C3FE FD0948           (    rsdos_mmc.asm):00816                        std     rnbfad                   ; save new start of random file buffer area                                                     
C401 EF0B             (    rsdos_mmc.asm):00817                        stu     fcbbuf,x                 ; save buffer start in fcb                                      
C403 FE097C           (    rsdos_mmc.asm):00818                        ldu     dfflen                   ; get random file record length                                         
C406 EF09             (    rsdos_mmc.asm):00819                        stu     fcbrln,x                 ; and save it in fcb                                
C408 208E             (    rsdos_mmc.asm):00820                        bra     lc4bb                    ; set fat flag, save file type in fcb                                              
                      (    rsdos_mmc.asm):00821         
                      (    rsdos_mmc.asm):00822         ; initialize fcb data for input
C40A 8D09             (    rsdos_mmc.asm):00823         lc52d          bsr     lc538                    ; initialize fcb                              
                      (    rsdos_mmc.asm):00824         
C40C FE0974           (    rsdos_mmc.asm):00825                        ldu     v974                     ; get ram directory image                                 
C40F EE4E             (    rsdos_mmc.asm):00826                        ldu     dirlst,u                 ;get number of bytes in last sector of file                                                        
C411 EF8813           (    rsdos_mmc.asm):00827                        stu     fcblst,x                 ;save it in fcb                           
                      (    rsdos_mmc.asm):00828         
C414 39               (    rsdos_mmc.asm):00829                        rts                                     
                      (    rsdos_mmc.asm):00830         
                      (    rsdos_mmc.asm):00831         ; initialize file control block
C415 9EF1             (    rsdos_mmc.asm):00832         lc538          ldx     fcbtmp                   ; get current file buffer                                        
C417 C619             (    rsdos_mmc.asm):00833                        ldb     #fcbcon                  ; clear fcb control bytes                                    
C419 6F80             (    rsdos_mmc.asm):00834         lc53c          clr     ,x+                      ; clear a byte                          
C41B 5A               (    rsdos_mmc.asm):00835                        decb                             ; decrement counter                        
C41C 26FB             (    rsdos_mmc.asm):00836                        bne     lc53c                    ; branch if not done                             
                      (    rsdos_mmc.asm):00837         
C41E 9EF1             (    rsdos_mmc.asm):00838                        ldx     fcbtmp                   ; get current file buffer address back                                                
C420 96EB             (    rsdos_mmc.asm):00839                        lda     dcdrv                    ;get current drive number and                                      
C422 A701             (    rsdos_mmc.asm):00840                        sta     fcbdrv,x                 ;save it in fcb                           
C424 B60976           (    rsdos_mmc.asm):00841                        lda     v976                     ; =get first granule -                              
C427 A702             (    rsdos_mmc.asm):00842                        sta     fcbfgr,x                 ; =save it as the starting granule number and                                                         
C429 A703             (    rsdos_mmc.asm):00843                        sta     fcbcgr,x                 ; =save it as current granule number                                                
C42B F60973           (    rsdos_mmc.asm):00844                        ldb     v973                     ; get directory sector number                                     
C42E C003             (    rsdos_mmc.asm):00845                        subb    #$03                     ; subtract 3 - directory sectors start at 3                                                    
C430 58               (    rsdos_mmc.asm):00846                        aslb                             ; multiply sectors                       
C431 58               (    rsdos_mmc.asm):00847                        aslb                             ; by 8 (8 directory                        
C432 58               (    rsdos_mmc.asm):00848                        aslb                             ; entries per sector)                          
C433 3404             (    rsdos_mmc.asm):00849                        pshs    b                        ; save sector offset                          
C435 FC0974           (    rsdos_mmc.asm):00850                        ldd     v974                     ; get ram directory image                                 
C438 830600           (    rsdos_mmc.asm):00851                        subd    #dbuf0                   ; subtract ram offset                                
C43B 8608             (    rsdos_mmc.asm):00852                        lda     #$08                     ; 8 directory entries/sector                                    
C43D 3D               (    rsdos_mmc.asm):00853                        mul                              ; now acca contains 0-7                           
C43E ABE0             (    rsdos_mmc.asm):00854                        adda    ,s+                      ; acca contains directory entry (0-71)                                              
C440 A78812           (    rsdos_mmc.asm):00855                        sta     fcbdir,x                 ; save directory entry number                                         
C443 39               (    rsdos_mmc.asm):00856                        rts                                     
                      (    rsdos_mmc.asm):00857         
                      (    rsdos_mmc.asm):00858         
                      (    rsdos_mmc.asm):00859         ; set up directory and update file allocation table entry in first unused sector
C444 C638             (    rsdos_mmc.asm):00860         lc567          ldb     #28*2                    ;'disk full' error                                                               
C446 B60977           (    rsdos_mmc.asm):00861                        lda     v977                     ; get sector number of first empty directory entry                                                          
C449 1027E7F9         (    rsdos_mmc.asm):00862                        lbeq    SysErr                   ; 'disk full' error if no empty directory entries                                                           
                      (    rsdos_mmc.asm):00863         
C44D B70973           (    rsdos_mmc.asm):00864                        sta     v973                     ; save sector number of first empty directory entry                                                           
C450 97ED             (    rsdos_mmc.asm):00865                        sta     dsec                     ; save sector number in dskcon register                                               
C452 C602             (    rsdos_mmc.asm):00866                        ldb     #$02                     ; read op code                      
C454 D7EA             (    rsdos_mmc.asm):00867                        stb     dcopc                    ; save in dskcon register                                  
C456 BDD4B5           (    rsdos_mmc.asm):00868                        jsr     >DoDiskReadWrite                   ; read sector                      
                      (    rsdos_mmc.asm):00869         
C459 BE0978           (    rsdos_mmc.asm):00870                        ldx     v978                     ; get address of ram image of unused directory                                                      
C45C BF0974           (    rsdos_mmc.asm):00871                        stx     v974                     ; entry and save as current used ram image                                                  
C45F 3384             (    rsdos_mmc.asm):00872                        leau    ,x                       ; (tfr x,u) point u to directory ram image                                                 
C461 C620             (    rsdos_mmc.asm):00873                        ldb     #dirlen                  ; set counter to clear 32 bytes (directory entry)                                                            
C463 6F80             (    rsdos_mmc.asm):00874         lc586          clr     ,x+                      ; clear byte                        
C465 5A               (    rsdos_mmc.asm):00875                        decb                             ; decrement counter                        
C466 26FB             (    rsdos_mmc.asm):00876                        bne     lc586                    ; continue if not done                               
                      (    rsdos_mmc.asm):00877         
C468 8E094C           (    rsdos_mmc.asm):00878                        ldx     #dnambf                  ; point to filename and extension ram image                                                      
C46B C60B             (    rsdos_mmc.asm):00879                        ldb     #11                      ; 11 bytes in filename and extension                                           
C46D BDA59A           (    rsdos_mmc.asm):00880                        jsr     UtilCopyBXtoU            ; move b bytes from x to u                                   
                      (    rsdos_mmc.asm):00881         
C470 FC0957           (    rsdos_mmc.asm):00882                        ldd     dfltyp                   ; get file type and ascii flag                                        
C473 EDC4             (    rsdos_mmc.asm):00883                        std     $00,u                    ; save in ram image                            
C475 C621             (    rsdos_mmc.asm):00884                        ldb     #33                      ; first granule to check                               
C477 BDC69C           (    rsdos_mmc.asm):00885                        jsr     >lc7bf                   ; find the first free granule                                      
                      (    rsdos_mmc.asm):00886         
C47A B70976           (    rsdos_mmc.asm):00887                        sta     v976                     ; save in ram                     
C47D A742             (    rsdos_mmc.asm):00888                        sta     $02,u                    ; save in ram image of directory track                                               
C47F C603             (    rsdos_mmc.asm):00889                        ldb     #$03                     ; get write operation code and save                                           
C481 D7EA             (    rsdos_mmc.asm):00890                        stb     dcopc                    ; it in dskcon register                                
C483 BDD4B5           (    rsdos_mmc.asm):00891                        jsr     >DoDiskReadWrite                   ; go write a sector in directory                                         
                      (    rsdos_mmc.asm):00892         
C486 3456             (    rsdos_mmc.asm):00893         lc5a9          pshs    u,x,b,a                  ; save registers                                 
C488 BDC632           (    rsdos_mmc.asm):00894                        jsr     >lc755                   ; point x to file allocation table                                           
                      (    rsdos_mmc.asm):00895         
C48B 6C01             (    rsdos_mmc.asm):00896                        inc     fat1,x                   ; indicate new data in file alloc table                                                 
C48D A601             (    rsdos_mmc.asm):00897                        lda     fat1,x                   ; get new data flag                             
C48F B1097A           (    rsdos_mmc.asm):00898                        cmpa    wfatvl                   ; have enough granules been removed from the fat to                                                              
                      (    rsdos_mmc.asm):00899                                                         ; cause the fat to be written to the disk
C492 2503             (    rsdos_mmc.asm):00900                        blo     lc5ba                    ; return if no need to write out allocation table                                                          
                      (    rsdos_mmc.asm):00901         
C494 BDC5FB           (    rsdos_mmc.asm):00902                        jsr     >lc71e                   ; write file allocation sector to disk                                               
                      (    rsdos_mmc.asm):00903         
C497 35D6             (    rsdos_mmc.asm):00904         lc5ba          puls    a,b,x,u,pc               ; restore registers                                       
                      (    rsdos_mmc.asm):00905         
                      (    rsdos_mmc.asm):00906         ; console in ram vector
C499 966F             (    rsdos_mmc.asm):00907         DosHookCharIn          lda     TextDevN                 ; get device number                                  
C49B 102FC852         (    rsdos_mmc.asm):00908                        lble    CoCoVect16A              ; branch if not disk file                                   
C49F 3262             (    rsdos_mmc.asm):00909                        leas    $02,s                    ; get rid of return address                                     
C4A1 3414             (    rsdos_mmc.asm):00910         lc5c4          pshs    x,b                      ; save registers                             
C4A3 0F70             (    rsdos_mmc.asm):00911                        clr     cinbfl                   ; clear buffer not empty flag                                       
C4A5 8E0926           (    rsdos_mmc.asm):00912                        ldx     #fcbv1-2                 ; point to file buffer vector table                                               
C4A8 D66F             (    rsdos_mmc.asm):00913                        ldb     TextDevN                 ; get active disk file number                                       
C4AA 58               (    rsdos_mmc.asm):00914                        aslb                             ; times 2 - two bytes per fcb address                                          
C4AB AE85             (    rsdos_mmc.asm):00915                        ldx     b,x                      ; now x points to file buffer                                    
C4AD E684             (    rsdos_mmc.asm):00916                        ldb     fcbtyp,x                 ; get file type                            
C4AF C140             (    rsdos_mmc.asm):00917                        cmpb    #ranfil                  ; is this a random (direct) file?                                             
C4B1 2616             (    rsdos_mmc.asm):00918                        bne     lc5ec                    ; branch if not                        
                      (    rsdos_mmc.asm):00919         
                      (    rsdos_mmc.asm):00920         
                      (    rsdos_mmc.asm):00921         ; get a byte from a random file - return char in acca
C4B3 EC8815           (    rsdos_mmc.asm):00922                        ldd     fcbget,x                 ; get the record counter                                    
C4B6 10A309           (    rsdos_mmc.asm):00923                        cmpd    fcbrln,x                 ;compare to record length and                                          
C4B9 2420             (    rsdos_mmc.asm):00924                        bhs     lc5fe                    ;branch to buffer empty if >= record length                                                    
                      (    rsdos_mmc.asm):00925         
C4BB C30001           (    rsdos_mmc.asm):00926                        addd    #$0001                   ; = add one to record pointer and                                            
C4BE ED8815           (    rsdos_mmc.asm):00927                        std     fcbget,x                 ; = save it in fcb                              
C4C1 AE0B             (    rsdos_mmc.asm):00928                        ldx     fcbbuf,x                 ; point x to start of random file buffer and                                                        
C4C3 308B             (    rsdos_mmc.asm):00929                        leax    d,x                      ; add the record counter to it                                      
C4C5 A61F             (    rsdos_mmc.asm):00930                        lda     $-1,x                    ; get a character from the buffer                                          
C4C7 3594             (    rsdos_mmc.asm):00931                        puls    b,x,pc                   ; restore registers and return                                         
                      (    rsdos_mmc.asm):00932         ; get a byte from a sequential file
C4C9 E68810           (    rsdos_mmc.asm):00933         lc5ec          ldb     fcbcfl,x                 ; test the cache flag and branch if an                                                       
C4CC 2708             (    rsdos_mmc.asm):00934                        beq     lc5f9                    ; extra character has not been read from file                                                      
                      (    rsdos_mmc.asm):00935         
C4CE A68811           (    rsdos_mmc.asm):00936                        lda     fcbcdt,x                 ; get the cache character                                     
C4D1 6F8810           (    rsdos_mmc.asm):00937                        clr     fcbcfl,x                 ; clear the cache flag                                  
C4D4 3594             (    rsdos_mmc.asm):00938                        puls    b,x,pc                   ; restore registers and return                                         
                      (    rsdos_mmc.asm):00939         
C4D6 E68817           (    rsdos_mmc.asm):00940         lc5f9          ldb     fcbdfl,x                 ; is any data left?                                    
C4D9 2704             (    rsdos_mmc.asm):00941                        beq     lc602                    ; branch if so                       
                      (    rsdos_mmc.asm):00942         
C4DB 0370             (    rsdos_mmc.asm):00943         lc5fe          com     cinbfl                   ; set flag to buffer empty                                    
C4DD 3594             (    rsdos_mmc.asm):00944                        puls    b,x,pc                   ; restore registers and return                                         
                      (    rsdos_mmc.asm):00945         
C4DF E605             (    rsdos_mmc.asm):00946         lc602          ldb     fcbcpt,x                 ; get character pointer                                        
C4E1 6C05             (    rsdos_mmc.asm):00947                        inc     fcbcpt,x                 ; add one to character pointer                                          
C4E3 6A8818           (    rsdos_mmc.asm):00948                        dec     fcblft,x                 ; decrement number of characters left in file buffer                                                                
C4E6 2706             (    rsdos_mmc.asm):00949                        beq     lc611                    ; if last character, go get some more                                              
                      (    rsdos_mmc.asm):00950         
C4E8 3A               (    rsdos_mmc.asm):00951                        abx                              ; add character counter to x                                
C4E9 A68819           (    rsdos_mmc.asm):00952                        lda     fcbcon,x                 ; get data character (skip past 25 fcb control bytes                                                                
C4EC 3594             (    rsdos_mmc.asm):00953                        puls    b,x,pc                                 
                      (    rsdos_mmc.asm):00954         ; get a character from fcb data buffer - return char in acca
C4EE 3460             (    rsdos_mmc.asm):00955         lc611          pshs    u,y                      ; save registers                             
C4F0 4F               (    rsdos_mmc.asm):00956                        clra                             ;      
C4F1 338B             (    rsdos_mmc.asm):00957                        leau    d,x                      ; point u to correct character                                      
C4F3 A6C819           (    rsdos_mmc.asm):00958                        lda     fcbcon,u                 ; =get data char (skip past 25 control bytes)                                                         
C4F6 3402             (    rsdos_mmc.asm):00959                        pshs    a                        ; =and save data character on stack                                         
C4F8 6F05             (    rsdos_mmc.asm):00960                        clr     fcbcpt,x                 ; reset char pointer to start of buffer                                                   
C4FA A601             (    rsdos_mmc.asm):00961                        lda     fcbdrv,x                 ; get drive number and save it in                                             
C4FC 97EB             (    rsdos_mmc.asm):00962                        sta     dcdrv                    ; dskcon variable                          
C4FE 8D04             (    rsdos_mmc.asm):00963                        bsr     lc627                    ; go read a sector - fill the buffer                                             
                      (    rsdos_mmc.asm):00964         
C500 3562             (    rsdos_mmc.asm):00965                        puls    a,y,u                    ; restore registers and data character                                                
C502 3594             (    rsdos_mmc.asm):00966                        puls    b,x,pc                   ; restore registers and return                                         
                      (    rsdos_mmc.asm):00967         ; refill the fcb input data buffer for sequential files
C504 A604             (    rsdos_mmc.asm):00968         lc627          lda     fcbsec,x                 ; get current sector number                                            
C506 4C               (    rsdos_mmc.asm):00969         lc629          inca                             ; add one                   
C507 3402             (    rsdos_mmc.asm):00970                        pshs    a                        ; save new sector number on the stack                                           
C509 8109             (    rsdos_mmc.asm):00971                        cmpa    #$09                     ; nine sectors per granule                                   
C50B 2301             (    rsdos_mmc.asm):00972                        bls     lc631                    ; branch if <= 9                         
                      (    rsdos_mmc.asm):00973         
C50D 4F               (    rsdos_mmc.asm):00974                        clra                             ; set to sector zero                         
C50E A704             (    rsdos_mmc.asm):00975         lc631          sta     fcbsec,x                 ; save sector number                                     
C510 E603             (    rsdos_mmc.asm):00976                        ldb     fcbcgr,x                 ; get granule numbet to fat pointer                                               
C512 3384             (    rsdos_mmc.asm):00977                        leau    ,x                       ; point u to fcb (tfr x,u)                                 
C514 BDC632           (    rsdos_mmc.asm):00978                        jsr     >lc755                   ; point x to proper file allocation table                                                  
                      (    rsdos_mmc.asm):00979         
C517 3A               (    rsdos_mmc.asm):00980                        abx                              ; add old granule number to fat pointer                                           
C518 E606             (    rsdos_mmc.asm):00981                        ldb     fatcon,x                 ; get granule number (6 control bytes at front of fat)                                                                  
C51A 30C4             (    rsdos_mmc.asm):00982                        leax    ,u                       ; point x to fcb                       
C51C C1C0             (    rsdos_mmc.asm):00983                        cmpb    #$c0                     ; is current granule last one in file?                                               
C51E 240A             (    rsdos_mmc.asm):00984                        bhs     lc64d                    ; yes              
                      (    rsdos_mmc.asm):00985         
C520 3502             (    rsdos_mmc.asm):00986                        puls    a                        ; get sector number                         
C522 800A             (    rsdos_mmc.asm):00987                        suba    #10                      ; was it 10? - overflow to next granule if so                                                     
C524 2615             (    rsdos_mmc.asm):00988                        bne     lc65e                    ; branch if not                        
                      (    rsdos_mmc.asm):00989         
C526 E703             (    rsdos_mmc.asm):00990                        stb     fcbcgr,x                 ; save new granule number                                     
C528 20DC             (    rsdos_mmc.asm):00991                        bra     lc629                    ; set variables for new granule                                        
C52A C43F             (    rsdos_mmc.asm):00992         lc64d          andb    #$3f                     ; get number of sectors used in this granule                                                          
C52C C109             (    rsdos_mmc.asm):00993                        cmpb    #$09                     ; 9 sectors / granule                              
C52E 2305             (    rsdos_mmc.asm):00994                        bls     lc658                    ; branch if ok                       
                      (    rsdos_mmc.asm):00995         
C530 C640             (    rsdos_mmc.asm):00996         lc653          ldb     #2*32                    ;'bad file structure' error                                                                    
C532 7EAC46           (    rsdos_mmc.asm):00997                        jmp     SysErr                   ; error driver                       
                      (    rsdos_mmc.asm):00998         
C535 E0E0             (    rsdos_mmc.asm):00999         lc658          subb    ,s+                      ; subtract current sector number and puls a                                                        
C537 2521             (    rsdos_mmc.asm):01000                        blo     lc67d                    ; branch if past last sector                                     
                      (    rsdos_mmc.asm):01001         
C539 1F98             (    rsdos_mmc.asm):01002                        tfr     b,a                      ; sector number to acca                              
C53B 3402             (    rsdos_mmc.asm):01003         lc65e          pshs    a                        ; save sector number difference                                          
C53D 8D23             (    rsdos_mmc.asm):01004                        bsr     lc685                    ; increment record number                                  
                      (    rsdos_mmc.asm):01005         
C53F 8602             (    rsdos_mmc.asm):01006                        lda     #$02                     ;get read operation code                                
C541 97EA             (    rsdos_mmc.asm):01007                        sta     dcopc                    ;and save it in dskcon variable                                        
C543 BDC640           (    rsdos_mmc.asm):01008                        jsr     >lc763                   ; get proper track and sector to dskcon variables                                                          
                      (    rsdos_mmc.asm):01009         
C546 338819           (    rsdos_mmc.asm):01010                        leau    fcbcon,x                 ; point u to start of fcb data buffer                                                  
C549 DFEE             (    rsdos_mmc.asm):01011                        stu     dcbpt                    ; and save it in dskcon variable                                         
C54B BDD4B5           (    rsdos_mmc.asm):01012                        jsr     >DoDiskReadWrite                   ; go read a sector into fcb buffer                                           
                      (    rsdos_mmc.asm):01013         
C54E 6F8818           (    rsdos_mmc.asm):01014                        clr     fcblft,x                 ; number of chars left in buffer = 256                                                  
C551 E6E0             (    rsdos_mmc.asm):01015                        ldb     ,s+                      ; get sector number off stack                                    
C553 260C             (    rsdos_mmc.asm):01016                        bne     lc684                    ; return if data left; fall thru if last sector                                                        
                      (    rsdos_mmc.asm):01017         
C555 EC8813           (    rsdos_mmc.asm):01018                        ldd     fcblst,x                 ; get number of bytes in the last sector                                                    
                      (    rsdos_mmc.asm):01019         
C558 2604             (    rsdos_mmc.asm):01020                        bne     lc681                    ; branch if some bytes in last sector                                              
                      (    rsdos_mmc.asm):01021         
C55A 5F               (    rsdos_mmc.asm):01022         lc67d          clrb                             ; set number of remaining bytes = 256                                               
C55B 638817           (    rsdos_mmc.asm):01023                        com     fcbdfl,x                 ; set data left flag to $ff                                       
C55E E78818           (    rsdos_mmc.asm):01024         lc681          stb     fcblft,x                 ; save the number of chars left in buffer                                                          
C561 39               (    rsdos_mmc.asm):01025         lc684          rts                                          
                      (    rsdos_mmc.asm):01026         
                      (    rsdos_mmc.asm):01027         
C562 EE07             (    rsdos_mmc.asm):01028         lc685          ldu     fcbrec,x                 ; get current record number                                            
C564 3341             (    rsdos_mmc.asm):01029                        leau    $01,u                    ; bump it                   
C566 EF07             (    rsdos_mmc.asm):01030                        stu     fcbrec,x                 ; put it back                         
C568 39               (    rsdos_mmc.asm):01031                        rts                                     
                      (    rsdos_mmc.asm):01032         
                      (    rsdos_mmc.asm):01033         
                      (    rsdos_mmc.asm):01034         ; scan directory for filename.ext found in dnambf. if filename found,
                      (    rsdos_mmc.asm):01035         ; return with sector number in v973, granule in v976 and ram buffer
                      (    rsdos_mmc.asm):01036         ; containing directory data in v974. if disk is full then v973,
                      (    rsdos_mmc.asm):01037         ; v977 = 0. the first unused sector returned in v977, ram image in v978
C569 7F0973           (    rsdos_mmc.asm):01038         lc68c          clr     v973                     ; clear sector number                                  
C56C 7F0977           (    rsdos_mmc.asm):01039                        clr     v977                     ; clear temp sector counter                                   
C56F CC1102           (    rsdos_mmc.asm):01040                        ldd     #$1102                   ; track 17 (directory), read operation code                                                     
C572 97EC             (    rsdos_mmc.asm):01041                        sta     dctrk                    ; save track number                            
C574 D7EA             (    rsdos_mmc.asm):01042                        stb     dcopc                    ; save operation code (read)                                     
C576 C603             (    rsdos_mmc.asm):01043                        ldb     #$03                     ; read sector 3 (first directory sector)                                                
C578 D7ED             (    rsdos_mmc.asm):01044         lc69b          stb     dsec                     ; save sector number in dskcon variable                                                    
C57A CE0600           (    rsdos_mmc.asm):01045                        ldu     #dbuf0                   ;buffer area number 0 as data buffer - save                                                     
C57D DFEE             (    rsdos_mmc.asm):01046                        stu     dcbpt                    ;in dskcon variable                            
C57F BDD4B5           (    rsdos_mmc.asm):01047                        jsr     >DoDiskReadWrite                   ; go read a sector                           
                      (    rsdos_mmc.asm):01048         
C582 FF0974           (    rsdos_mmc.asm):01049         lc6a5          stu     v974                     ; save ram directory buffer address                                                
C585 31C4             (    rsdos_mmc.asm):01050                        leay    ,u                       ; point y to directory buffer                                    
C587 A6C4             (    rsdos_mmc.asm):01051                        lda     ,u                       ; get a byte from buffer                              
C589 2628             (    rsdos_mmc.asm):01052                        bne     lc6d6                    ; branch if not zero - file is active                                              
                      (    rsdos_mmc.asm):01053         
C58B 8D29             (    rsdos_mmc.asm):01054                        bsr     lc6d9                    ; set unused file pointers if entry has been killed                                                            
                      (    rsdos_mmc.asm):01055         
C58D 8E094C           (    rsdos_mmc.asm):01056         lc6b0          ldx     #dnambf                  ; point to disk file name buffer                                                
C590 A680             (    rsdos_mmc.asm):01057         lc6b3          lda     ,x+                      ;compare the filename and extension                                               
C592 A1C0             (    rsdos_mmc.asm):01058                        cmpa    ,u+                      ;stored in ram at dnambf to the directory                                                 
C594 260E             (    rsdos_mmc.asm):01059                        bne     lc6c7                    ;entry stored at ,u (branch if mismatch)                                                 
                      (    rsdos_mmc.asm):01060         
C596 8C0957           (    rsdos_mmc.asm):01061                        cmpx    #dnambf+11               ; at end of file name buffer?                                            
C599 26F5             (    rsdos_mmc.asm):01062                        bne     lc6b3                    ; branch if not done checking filename                                               
                      (    rsdos_mmc.asm):01063         
C59B F70973           (    rsdos_mmc.asm):01064                        stb     v973                     ; save sector number in dskcon variable                                               
C59E A642             (    rsdos_mmc.asm):01065                        lda     fcbfgr,u                 ;get number of first granule in file                                                
C5A0 B70976           (    rsdos_mmc.asm):01066                        sta     v976                     ;and save it in v976                            
C5A3 39               (    rsdos_mmc.asm):01067                        rts                                     
                      (    rsdos_mmc.asm):01068         
                      (    rsdos_mmc.asm):01069         
C5A4 33A820           (    rsdos_mmc.asm):01070         lc6c7          leau    dirlen,y                 ; get next directory entry (dirlen bytes per entry)                                                                     
C5A7 11830700         (    rsdos_mmc.asm):01071                        cmpu    #dbuf0+seclen            ; at end of buffer?                                     
C5AB 26D5             (    rsdos_mmc.asm):01072                        bne     lc6a5                    ; check next entry if not at end                                         
                      (    rsdos_mmc.asm):01073         
C5AD 5C               (    rsdos_mmc.asm):01074                        incb                             ; next sector                  
C5AE C10B             (    rsdos_mmc.asm):01075                        cmpb    #11                      ; 11 sectors max in directory                                     
C5B0 23C6             (    rsdos_mmc.asm):01076                        bls     lc69b                    ; branch if more sectors                                 
                      (    rsdos_mmc.asm):01077         
C5B2 39               (    rsdos_mmc.asm):01078                        rts                                     
                      (    rsdos_mmc.asm):01079         
                      (    rsdos_mmc.asm):01080         
C5B3 43               (    rsdos_mmc.asm):01081         lc6d6          coma                             ; complement first byte in directory emtry                                                    
C5B4 26D7             (    rsdos_mmc.asm):01082                        bne     lc6b0                    ; branch if file is active - fall thru if not used                                                           
                      (    rsdos_mmc.asm):01083         
                      (    rsdos_mmc.asm):01084         
                      (    rsdos_mmc.asm):01085         ; set pointers for first unused directory entry
C5B6 B60977           (    rsdos_mmc.asm):01086         lc6d9          lda     v977                     ; unused entry already found?                                          
C5B9 2606             (    rsdos_mmc.asm):01087                        bne     DosHookReadInputLine                   ; return if unused entry already found                                                
                      (    rsdos_mmc.asm):01088         
C5BB F70977           (    rsdos_mmc.asm):01089                        stb     v977                     ; sector containing this directory entry                                                
C5BE FF0978           (    rsdos_mmc.asm):01090                        stu     v978                     ; points to ram area where directory data is stored                                                           
C5C1 39               (    rsdos_mmc.asm):01091         DosHookReadInputLine         rts                                           
                      (    rsdos_mmc.asm):01092         
                      (    rsdos_mmc.asm):01093         
C5C2 C634             (    rsdos_mmc.asm):01094         lc6e5          ldb     #2*26                    ; 'ne' error                                                     
C5C4 7D0973           (    rsdos_mmc.asm):01095                        tst     v973                     ; was a directory match found?                                      
C5C7 26F8             (    rsdos_mmc.asm):01096                        bne     DosHookReadInputLine                   ; return if found                           
                      (    rsdos_mmc.asm):01097         
C5C9 7EAC46           (    rsdos_mmc.asm):01098                        jmp     SysErr                   ; jump to error handler if not found                                             
                      (    rsdos_mmc.asm):01099         
                      (    rsdos_mmc.asm):01100         
                      (    rsdos_mmc.asm):01101         ; kill command
C5CC BDC812           (    rsdos_mmc.asm):01102         CmdKill        jsr     >lc935                   ; get filename.ext from basic                                          
C5CF BDA5C7           (    rsdos_mmc.asm):01103                        jsr     la5c7                    ; 'syntax' error if more characters on line                                                    
C5D2 BDC67A           (    rsdos_mmc.asm):01104                        jsr     >GetFAT                  ; get valid fat data                             
                      (    rsdos_mmc.asm):01105         
C5D5 8D92             (    rsdos_mmc.asm):01106                        bsr     lc68c                    ; test for file name match in directory                                                
                      (    rsdos_mmc.asm):01107         
C5D7 8DE9             (    rsdos_mmc.asm):01108                        bsr     lc6e5                    ; make sure the file existed                                     
                      (    rsdos_mmc.asm):01109         
C5D9 86FF             (    rsdos_mmc.asm):01110         lc6cf          lda     #$ff                     ; match file type = $ff; this will cause an 'ao'                                                             
                      (    rsdos_mmc.asm):01111                                                         ; error to be generated if any file type is open
C5DB BDC6E4           (    rsdos_mmc.asm):01112                        jsr     >lc807                   ; check to make sure file is not open                                              
                      (    rsdos_mmc.asm):01113         
C5DE BE0974           (    rsdos_mmc.asm):01114                        ldx     v974                     ;get ram image of directory                                   
C5E1 6F84             (    rsdos_mmc.asm):01115                        clr     dirnam,x                 ;and zero first byte - kill file                                            
C5E3 C603             (    rsdos_mmc.asm):01116                        ldb     #$03                     ; =write operation code - save                                      
C5E5 D7EA             (    rsdos_mmc.asm):01117                        stb     dcopc                    ; =it in dskcon variable                                 
C5E7 BDD4B5           (    rsdos_mmc.asm):01118                        jsr     >DoDiskReadWrite                   ; write a sector                         
                      (    rsdos_mmc.asm):01119         
C5EA E60D             (    rsdos_mmc.asm):01120                        ldb     dirgrn,x                 ; get number of first granule in file                                                 
C5EC 8D44             (    rsdos_mmc.asm):01121         lc70f          bsr     lc755                    ; point x to proper file allocation table                                                       
                      (    rsdos_mmc.asm):01122         
C5EE 3006             (    rsdos_mmc.asm):01123                        leax    fatcon,x                 ; skip 6 control bytes                                   
C5F0 3A               (    rsdos_mmc.asm):01124                        abx                              ; point to correct entry                            
C5F1 E684             (    rsdos_mmc.asm):01125                        ldb     ,x                       ; get next granule                        
C5F3 86FF             (    rsdos_mmc.asm):01126                        lda     #$ff                     ;get free granule flag and                                  
C5F5 A784             (    rsdos_mmc.asm):01127                        sta     ,x                       ;mark granule as free                           
C5F7 C1C0             (    rsdos_mmc.asm):01128                        cmpb    #$c0                     ; was this the last granule?                                     
C5F9 25F1             (    rsdos_mmc.asm):01129                        blo     lc70f                    ; keep freeing granules if not last one                                                
                      (    rsdos_mmc.asm):01130         
                      (    rsdos_mmc.asm):01131                                                         ; write file allocation sector to directory - do not write
                      (    rsdos_mmc.asm):01132                                                         ; the six control bytes at the start of the fat to the disk
C5FB CE0600           (    rsdos_mmc.asm):01133         lc71e          ldu     #dbuf0                   ; =point u to disk buffer 0 and                                              
C5FE DFEE             (    rsdos_mmc.asm):01134                        stu     dcbpt                    ; =save it as dskcon variable                                      
C600 CC1103           (    rsdos_mmc.asm):01135                        ldd     #$1103                   ; write directory track - save                                        
C603 97EC             (    rsdos_mmc.asm):01136                        sta     dctrk                    ; track and write operation code in                                            
C605 D7EA             (    rsdos_mmc.asm):01137                        stb     dcopc                    ; dskcon variables                           
C607 C602             (    rsdos_mmc.asm):01138                        ldb     #$02                     ; = get file allocation sector and                                          
C609 D7ED             (    rsdos_mmc.asm):01139                        stb     dsec                     ; = save in dskcon variable                                   
C60B 8D25             (    rsdos_mmc.asm):01140                        bsr     lc755                    ; point x to proper file allocation table                                                  
                      (    rsdos_mmc.asm):01141         
C60D 6F01             (    rsdos_mmc.asm):01142                        clr     fat1,x                   ; reset flag indicating valid fat data has been stored on disk                                                                        
C60F 3006             (    rsdos_mmc.asm):01143                        leax    fatcon,x                 ; move (x) to start of granule data                                                
C611 C644             (    rsdos_mmc.asm):01144                        ldb     #granmx                  ; 68 bytes in fat                            
C613 BDA59A           (    rsdos_mmc.asm):01145                        jsr     UtilCopyBXtoU            ; move accb bytes from fat ram image to dbuf0                                                      
                      (    rsdos_mmc.asm):01146         
                      (    rsdos_mmc.asm):01147         
                      (    rsdos_mmc.asm):01148         ; zero out all of the bytes in the fat sector which do not contain the granule data
C616 6FC0             (    rsdos_mmc.asm):01149         lc739          clr     ,u+                      ; clear a byte                          
C618 11830700         (    rsdos_mmc.asm):01150                        cmpu    #dbuf0+seclen            ; finished the whole sector?                                              
C61C 26F8             (    rsdos_mmc.asm):01151                        bne     lc739                    ; no             
                      (    rsdos_mmc.asm):01152         
C61E 7ED4B5           (    rsdos_mmc.asm):01153                        jmp     >DoDiskReadWrite                   ; write a sector                         
                      (    rsdos_mmc.asm):01154         
                      (    rsdos_mmc.asm):01155         
                      (    rsdos_mmc.asm):01156         ; enter with accb containing file number (1-15); exit with x pointing
                      (    rsdos_mmc.asm):01157         ; to correct file buffer; flags set according to file type.
                      (    rsdos_mmc.asm):01158         
C621 3404             (    rsdos_mmc.asm):01159         lc744          pshs    b                        ; save file number on stack                                      
C623 D66F             (    rsdos_mmc.asm):01160                        ldb     TextDevN                 ; get device number (file number)                                           
C625 8C               (    rsdos_mmc.asm):01161                        fcb      Skip2                   ; cmpx 
C626 3404             (    rsdos_mmc.asm):01162         lc749          pshs    b                        ; save file number on stack                                      
C628 58               (    rsdos_mmc.asm):01163                        aslb                             ; x2: 2 bytes per pointer                              
C629 8E0926           (    rsdos_mmc.asm):01164                        ldx     #fcbv1-2                 ; point x to start of fcb pointers                                              
C62C AE85             (    rsdos_mmc.asm):01165                        ldx     b,x                      ; point x to proper fcb                              
C62E E684             (    rsdos_mmc.asm):01166                        ldb     fcbtyp,x                 ; set flags according to file type                                              
C630 3584             (    rsdos_mmc.asm):01167                        puls    b,pc                     ; restore file number                              
                      (    rsdos_mmc.asm):01168         
                      (    rsdos_mmc.asm):01169         ; point x to drive allocation table
                      (    rsdos_mmc.asm):01170         
C632 3406             (    rsdos_mmc.asm):01171         lc755          pshs    b,a                      ; save accd on stack                                 
C634 96EB             (    rsdos_mmc.asm):01172                        lda     dcdrv                    ; get drive number                           
C636 C64A             (    rsdos_mmc.asm):01173                        ldb     #fatlen                  ; get length of file allocation table                                                
C638 3D               (    rsdos_mmc.asm):01174                        mul                              ; multiply by drive number to get offset                                            
C639 8E0800           (    rsdos_mmc.asm):01175                        ldx     #fatbl0                  ; start of file allocation table                                           
C63C 308B             (    rsdos_mmc.asm):01176                        leax    d,x                      ; point to right table                              
C63E 3586             (    rsdos_mmc.asm):01177                        puls    a,b,pc                   ; restore accd                         
                      (    rsdos_mmc.asm):01178         
                      (    rsdos_mmc.asm):01179         ; convert granule number to track & sector number - x must be pointing to correct
                      (    rsdos_mmc.asm):01180         ; fcb; the track and sector number will be stored in dskcon registers
C640 E603             (    rsdos_mmc.asm):01181         lc763          ldb     fcbcgr,x                 ; get granule number                                     
C642 54               (    rsdos_mmc.asm):01182                        lsrb                             ; divide by 2 - 2 granules / track                                       
C643 D7EC             (    rsdos_mmc.asm):01183                        stb     dctrk                    ; track number                       
C645 C111             (    rsdos_mmc.asm):01184                        cmpb    #17                      ; track 17 = directory track                                    
C647 2502             (    rsdos_mmc.asm):01185                        blo     lc76e                    ; branch if < directory track                                      
                      (    rsdos_mmc.asm):01186         
C649 0CEC             (    rsdos_mmc.asm):01187                        inc     dctrk                    ; incr track number if > directory track                                                 
C64B 58               (    rsdos_mmc.asm):01188         lc76e          aslb                             ; multiply track number by 2                                      
C64C 50               (    rsdos_mmc.asm):01189                        negb                             ; negate granule number                            
C64D EB03             (    rsdos_mmc.asm):01190                        addb    fcbcgr,x                 ; b=0 if even granule; 1 if odd                                            
C64F 8D05             (    rsdos_mmc.asm):01191                        bsr     lc779                    ; return b=0 for even granule number, b=9 for odd granule number                                                                         
                      (    rsdos_mmc.asm):01192         
C651 EB04             (    rsdos_mmc.asm):01193                        addb    fcbsec,x                 ; add sector number                                
C653 D7ED             (    rsdos_mmc.asm):01194                        stb     dsec                     ; save sector number                            
C655 39               (    rsdos_mmc.asm):01195                        rts                                     
                      (    rsdos_mmc.asm):01196         
                      (    rsdos_mmc.asm):01197         ; multiply accd by 9
C656 3406             (    rsdos_mmc.asm):01198         lc779          pshs    b,a                      ; temp store accd on stack                                       
C658 58               (    rsdos_mmc.asm):01199                        aslb                             ;      
C659 49               (    rsdos_mmc.asm):01200                        rola                             ; multiply by 2                    
C65A 58               (    rsdos_mmc.asm):01201                        aslb                             ; =        
C65B 49               (    rsdos_mmc.asm):01202                        rola                             ; = multiply by four                         
C65C 58               (    rsdos_mmc.asm):01203                        aslb                             ;      
C65D 49               (    rsdos_mmc.asm):01204                        rola                             ; multiply by eight                        
C65E E3E1             (    rsdos_mmc.asm):01205                        addd    ,s++                     ; add one = multiply by nine                                     
C660 39               (    rsdos_mmc.asm):01206                        rts                                     
                      (    rsdos_mmc.asm):01207         
                      (    rsdos_mmc.asm):01208         
                      (    rsdos_mmc.asm):01209         ; convert accd into a granule number - return result in accb;
                      (    rsdos_mmc.asm):01210         ; enter with accd containing a number of sectors. return in accb
                      (    rsdos_mmc.asm):01211         ; the number (0-67) corresponding to the number of complete
                      (    rsdos_mmc.asm):01212         ; granules contained in that many sectors.
                      (    rsdos_mmc.asm):01213         ; divide by 90, multiply by 10 is faster than divide by 9
C661 6FE2             (    rsdos_mmc.asm):01214         lc784          clr     ,-s                      ; clear a temporary slot on the stack                                                 
C663 6CE4             (    rsdos_mmc.asm):01215         lc786          inc     ,s                       ; divide accd by 90 - save the                                         
C665 83005A           (    rsdos_mmc.asm):01216                        subd    #9*10                    ; quotient+1 on the stack - remainder                                                                                 
C668 2AF9             (    rsdos_mmc.asm):01217                        bpl     lc786                    ; in accb                  
C66A A6E4             (    rsdos_mmc.asm):01218                        lda     ,s                       ; = put the quotient+1 in acca and                                        
C66C E7E4             (    rsdos_mmc.asm):01219                        stb     ,s                       ; = save remainder on stack                                 
C66E C60A             (    rsdos_mmc.asm):01220                        ldb     #10                      ; multiply (quotient+1)                              
C670 3D               (    rsdos_mmc.asm):01221                        mul                              ; by 10           
C671 3502             (    rsdos_mmc.asm):01222                        puls    a                        ; put the remainder in acca                                 
C673 5A               (    rsdos_mmc.asm):01223         lc796          decb                             ; decrement the granule count by one for                                                  
C674 8B09             (    rsdos_mmc.asm):01224                        adda    #$09                     ; every nine sectors (1 granule) in the                                                
C676 2BFB             (    rsdos_mmc.asm):01225                        bmi     lc796                    ; remainder - compensate for the + 1 in quotient+1                                                           
C678 4F               (    rsdos_mmc.asm):01226                        clra                             ; clear ms byte of accd                            
C679 39               (    rsdos_mmc.asm):01227         lc79c          rts                                          
                      (    rsdos_mmc.asm):01228         
                      (    rsdos_mmc.asm):01229         
                      (    rsdos_mmc.asm):01230         ; make sure ram file allocation table data is valid
C67A 8DB6             (    rsdos_mmc.asm):01231         GetFAT          bsr     lc755                    ; point x to fat for the correct drive number                                                           
                      (    rsdos_mmc.asm):01232         
C67C 6D84             (    rsdos_mmc.asm):01233                        tst     fat0,x                   ; check to see if any files are active                                                
C67E 26F9             (    rsdos_mmc.asm):01234                        bne     lc79c                    ; return if any files active in this fat                                                 
                      (    rsdos_mmc.asm):01235         
C680 6F01             (    rsdos_mmc.asm):01236                        clr     fat1,x                   ; reset fat data valid flag                                     
C682 3306             (    rsdos_mmc.asm):01237                        leau    fatcon,x                 ; load u with start of granule data buffer                                                       
C684 8E0600           (    rsdos_mmc.asm):01238                        ldx     #dbuf0                   ; buffer for disk transfer                                    
C687 9FEE             (    rsdos_mmc.asm):01239                        stx     dcbpt                    ; put in dskcon parameter                                  
C689 CC1102           (    rsdos_mmc.asm):01240                        ldd     #$1102                   ; directory track, read sector                                        
C68C 97EC             (    rsdos_mmc.asm):01241                        sta     dctrk                    ; store in dskcon track number                                       
C68E D7EA             (    rsdos_mmc.asm):01242                        stb     dcopc                    ; store in dskcon op code                                  
C690 C602             (    rsdos_mmc.asm):01243                        ldb     #$02                     ; get sector number 2 (file allocation table)                                                     
C692 D7ED             (    rsdos_mmc.asm):01244                        stb     dsec                     ; store in dskcon parameter                                   
C694 BDD4B5           (    rsdos_mmc.asm):01245                        jsr     >DoDiskReadWrite                   ; go read sector                         
                      (    rsdos_mmc.asm):01246         
C697 C644             (    rsdos_mmc.asm):01247                        ldb     #granmx                  ; transfer file allocation table to file alloc table buffer                                                                      
C699 7EA59A           (    rsdos_mmc.asm):01248                        jmp     UtilCopyBXtoU            ; move b bytes from (x) to (u)                                       
                      (    rsdos_mmc.asm):01249         
                      (    rsdos_mmc.asm):01250         
                      (    rsdos_mmc.asm):01251         ; find first free granule - enter with accb containing
                      (    rsdos_mmc.asm):01252         ; granule from which to start searching. the found granule
                      (    rsdos_mmc.asm):01253         ; is marked by storing a $c0 in the granule's data byte
                      (    rsdos_mmc.asm):01254         ; to indicate that it is the last granule in the file.
                      (    rsdos_mmc.asm):01255         ; return with first free granule found in acca
C69C 8D94             (    rsdos_mmc.asm):01256         lc7bf          bsr     lc755                    ; point x to file alloc table                                           
                      (    rsdos_mmc.asm):01257         
C69E 3006             (    rsdos_mmc.asm):01258                        leax    fatcon,x                 ; skip control bytes                                 
C6A0 4F               (    rsdos_mmc.asm):01259                        clra                             ; use acca as granule counter                                  
C6A1 C4FE             (    rsdos_mmc.asm):01260                        andb    #$fe                     ; mask off bit zero of search granule                                              
C6A3 6FE2             (    rsdos_mmc.asm):01261                        clr     ,-s                      ; initialize and save a byte on stack (direction flag)                                                             
C6A5 6385             (    rsdos_mmc.asm):01262         lc7c8          com     b,x                      ; is this granule free? ($ff=free)                                              
C6A7 2731             (    rsdos_mmc.asm):01263                        beq     lc7fd                    ; branch if it is                          
                      (    rsdos_mmc.asm):01264         
C6A9 6385             (    rsdos_mmc.asm):01265                        com     b,x                      ; restore granule data                             
C6AB 4C               (    rsdos_mmc.asm):01266                        inca                             ; add one to granule counter                                 
C6AC 8144             (    rsdos_mmc.asm):01267                        cmpa    #granmx                  ; granmx geanules per disk                                      
C6AE 2425             (    rsdos_mmc.asm):01268                        bhs     lc7f8                    ; branch if all granules checked (disk full)                                                     
                      (    rsdos_mmc.asm):01269         
C6B0 5C               (    rsdos_mmc.asm):01270                        incb                             ; incr to next granule                           
C6B1 C501             (    rsdos_mmc.asm):01271                        bitb    #$01                     ; is bit 0 set?                        
C6B3 26F0             (    rsdos_mmc.asm):01272                        bne     lc7c8                    ; branch if odd granule number (same track)                                                    
                      (    rsdos_mmc.asm):01273         
C6B5 3406             (    rsdos_mmc.asm):01274                        pshs    b,a                      ; save granule counter and current granule number                                                         
C6B7 C002             (    rsdos_mmc.asm):01275                        subb    #$02                     ; subtract one track (2 granules)                                          
C6B9 6362             (    rsdos_mmc.asm):01276                        com     $02,s                    ; complement direction flag                                    
C6BB 260C             (    rsdos_mmc.asm):01277                        bne     lc7ec                    ; branch every other time                                  
                      (    rsdos_mmc.asm):01278         
C6BD E0E0             (    rsdos_mmc.asm):01279                        subb    ,s+                      ; subtract the granule counter from the current granule number                                                                      
C6BF 2A04             (    rsdos_mmc.asm):01280                        bpl     lc7e8                    ; branch if lower bound not exceeded                                             
C6C1 E6E4             (    rsdos_mmc.asm):01281                        ldb     ,s                       ; restore current granule number if lower bound exceeded                                                              
C6C3 6361             (    rsdos_mmc.asm):01282         lc7e6          com     $01,s                    ; complement flag - if granule number has exceeded                                                                
                      (    rsdos_mmc.asm):01283                                                         ; bounds on either the hi or lo side, force it to go in
                      (    rsdos_mmc.asm):01284                                                         ; the direction opposite the exceeded bound
C6C5 3261             (    rsdos_mmc.asm):01285         lc7e8          leas    $01,s                    ; clean up stack                               
C6C7 20DC             (    rsdos_mmc.asm):01286                        bra     lc7c8                    ; check for another free granule                                         
                      (    rsdos_mmc.asm):01287         
C6C9 EBE0             (    rsdos_mmc.asm):01288         lc7ec          addb    ,s+                      ; add the granule counter to the current granule number                                                                    
C6CB C144             (    rsdos_mmc.asm):01289                        cmpb    #granmx                  ; granmx granules per disk                                      
C6CD 25F6             (    rsdos_mmc.asm):01290                        blo     lc7e8                    ; branch if upper bound not exceeded                                             
                      (    rsdos_mmc.asm):01291         
C6CF E6E4             (    rsdos_mmc.asm):01292                        ldb     ,s                       ; restore current granule count and go twice                                                  
C6D1 C004             (    rsdos_mmc.asm):01293                        subb    #$04                     ; as far as usual in opposite direction if upper bound exceeded                                                                        
C6D3 20EE             (    rsdos_mmc.asm):01294                        bra     lc7e6                    ; keep searching                         
C6D5 C638             (    rsdos_mmc.asm):01295         lc7f8          ldb     #2*28                    ; 'disk full' error                                                            
C6D7 7EAC46           (    rsdos_mmc.asm):01296                        jmp     SysErr                   ; jump to error handler                                
                      (    rsdos_mmc.asm):01297         
                      (    rsdos_mmc.asm):01298         
                      (    rsdos_mmc.asm):01299         ; point x to first free granule position in the file allocation
                      (    rsdos_mmc.asm):01300         ; table and mark the position with a last granule in file marker
C6DA 3261             (    rsdos_mmc.asm):01301         lc7fd          leas    $01,s                    ; clear up stack - remove direction flag                                                       
C6DC 1F98             (    rsdos_mmc.asm):01302                        tfr     b,a                      ; granule number to acca                               
C6DE 3A               (    rsdos_mmc.asm):01303                        abx                              ; point x to first found granule                                    
C6DF C6C0             (    rsdos_mmc.asm):01304                        ldb     #$c0                     ; last granule flag                           
C6E1 E784             (    rsdos_mmc.asm):01305                        stb     ,x                       ; mark the first found granule as the last granule                                                        
C6E3 39               (    rsdos_mmc.asm):01306         lc806          rts                                          
                      (    rsdos_mmc.asm):01307         
                      (    rsdos_mmc.asm):01308         
                      (    rsdos_mmc.asm):01309         ; check all active files to make sure a file is not already open - to be open
                      (    rsdos_mmc.asm):01310         ; a file buffer must match the drive number and first granule number
                      (    rsdos_mmc.asm):01311         ; in ram directory entry and the fcb type must not match the file type in acca
                      (    rsdos_mmc.asm):01312         ; an 'ao' error will not be generated if a file is being opened for
                      (    rsdos_mmc.asm):01313         ; the same mode that it has already been opened under.
                      (    rsdos_mmc.asm):01314         
C6E4 3402             (    rsdos_mmc.asm):01315         lc807          pshs    a                        ; save file type on stack                                    
C6E6 F6095B           (    rsdos_mmc.asm):01316                        ldb     fcbact                   ; number of currently open files                                          
C6E9 5C               (    rsdos_mmc.asm):01317                        incb                             ; add one more to file counter                                   
C6EA BDC626           (    rsdos_mmc.asm):01318         lc80d          jsr     >lc749                   ; point x to fcb of this file                                           
                      (    rsdos_mmc.asm):01319         
C6ED 2717             (    rsdos_mmc.asm):01320                        beq     lc829                    ; branch if buffer not being used                                          
                      (    rsdos_mmc.asm):01321         
C6EF 96EB             (    rsdos_mmc.asm):01322                        lda     dcdrv                    ; get drive number and check to see if it                                                  
C6F1 A101             (    rsdos_mmc.asm):01323                        cmpa    fcbdrv,x                 ; matches the drive number for this buffer                                                       
C6F3 2611             (    rsdos_mmc.asm):01324                        bne     lc829                    ; file exists on another drive                                       
                      (    rsdos_mmc.asm):01325         
C6F5 FE0974           (    rsdos_mmc.asm):01326                        ldu     v974                     ; get ram directory area                                
C6F8 A64D             (    rsdos_mmc.asm):01327                        lda     dirgrn,u                 ; get first granule in file                                        
C6FA A102             (    rsdos_mmc.asm):01328                        cmpa    fcbfgr,x                 ; does it match this file buffer?                                              
C6FC 2608             (    rsdos_mmc.asm):01329                        bne     lc829                    ; no             
                      (    rsdos_mmc.asm):01330         
C6FE A684             (    rsdos_mmc.asm):01331                        lda     fcbtyp,x                 ; get file type of this buffer                                          
C700 A1E4             (    rsdos_mmc.asm):01332                        cmpa    ,s                       ; does it match the one we are looking for?                                                  
C702 1026DF16         (    rsdos_mmc.asm):01333                        lbne    la61c                    ; 'file already open' error if not                                            
                      (    rsdos_mmc.asm):01334         
C706 5A               (    rsdos_mmc.asm):01335         lc829          decb                             ; decr file counter                             
C707 26E1             (    rsdos_mmc.asm):01336                        bne     lc80d                    ; branch if haven't checked all active files                                                     
                      (    rsdos_mmc.asm):01337         
C709 3582             (    rsdos_mmc.asm):01338                        puls    a,pc                     ; restore file type and return                                       
                      (    rsdos_mmc.asm):01339         
C70B BDA5A5           (    rsdos_mmc.asm):01340         lc82e          jsr     la5a5                    ; evaluate an expression (device number)                                                      
                      (    rsdos_mmc.asm):01341         
C70E 0F6F             (    rsdos_mmc.asm):01342                        clr     TextDevN                 ; set device number to screen                                       
C710 5D               (    rsdos_mmc.asm):01343                        tstb                             ; test new device number                             
C711 102FED35         (    rsdos_mmc.asm):01344                        lble    BasFCError               ; 'fc' error if device number not a disk file                                                       
C715 BDC626           (    rsdos_mmc.asm):01345                        jsr     >lc749                   ; point x to fcb                         
                      (    rsdos_mmc.asm):01346         
C718 A684             (    rsdos_mmc.asm):01347                        lda     fcbtyp,x                 ; test if buffer is in use                                      
C71A 1027DCDD         (    rsdos_mmc.asm):01348                        lbeq    la3fb                    ; 'file not open' error                                 
                      (    rsdos_mmc.asm):01349         
C71E 8140             (    rsdos_mmc.asm):01350                        cmpa    #ranfil                  ; direct/random file?                                 
C720 27C1             (    rsdos_mmc.asm):01351                        beq     lc806                    ; return if random                           
                      (    rsdos_mmc.asm):01352         
C722 7EA616           (    rsdos_mmc.asm):01353         lc845          jmp     BasFMError               ; bad file mode error if not random                                                 
                      (    rsdos_mmc.asm):01354         
                      (    rsdos_mmc.asm):01355         
                      (    rsdos_mmc.asm):01356         ; input device number check ram hook
C725 8610             (    rsdos_mmc.asm):01357         DosHookCheckOpenIn          lda     #inpfil                  ; input file type                                 
C727 8C               (    rsdos_mmc.asm):01358         lc84a           fcb     Skip2                   ; cmpx               
                      (    rsdos_mmc.asm):01359         
                      (    rsdos_mmc.asm):01360         ; print device number check ram hook
C728 8620             (    rsdos_mmc.asm):01361         DosHookCheckOpenOut          lda     #outfil                  ; output file type                                  
C72A 0D6F             (    rsdos_mmc.asm):01362                        tst     TextDevN                 ; check device number and return if                                             
C72C 2FB5             (    rsdos_mmc.asm):01363                        ble     lc806                    ; not a disk file                          
C72E AFE4             (    rsdos_mmc.asm):01364                        stx     ,s                       ; = replace subroutine return address with x register -                                                             
                      (    rsdos_mmc.asm):01365                                                         ; = this is the same as leas 2,s and pshs x
C730 BDC621           (    rsdos_mmc.asm):01366                        jsr     >lc744                   ; point x to fcb                         
                      (    rsdos_mmc.asm):01367         
C733 3406             (    rsdos_mmc.asm):01368                        pshs    b,a                      ; save accb and file type on stack                                          
C735 A684             (    rsdos_mmc.asm):01369                        lda     fcbtyp,x                 ; get file type                           
C737 1027DCC0         (    rsdos_mmc.asm):01370                        lbeq    la3fb                    ; 'file not open' error                                 
                      (    rsdos_mmc.asm):01371         
C73B 8140             (    rsdos_mmc.asm):01372                        cmpa    #ranfil                  ; random file?                          
C73D 2706             (    rsdos_mmc.asm):01373                        beq     lc868                    ; branch if random file                                
                      (    rsdos_mmc.asm):01374         
C73F A1E4             (    rsdos_mmc.asm):01375                        cmpa    ,s                       ; is this fcb of the proper type?                                        
C741 26DF             (    rsdos_mmc.asm):01376                        bne     lc845                    ; 'file mode' error if not                                   
                      (    rsdos_mmc.asm):01377         
C743 3596             (    rsdos_mmc.asm):01378         lc866          puls    a,b,x,pc                 ; restore accb,x,acca (file type) and return                                                              
                      (    rsdos_mmc.asm):01379         
C745 AE64             (    rsdos_mmc.asm):01380         lc868          ldx     $04,s                    ; get calling address from the stack and                                                      
C747 8CB00C           (    rsdos_mmc.asm):01381                        cmpx    #lb00c                   ; return unless coming from                                      
C74A 26F7             (    rsdos_mmc.asm):01382                        bne     lc866                    ; basic's 'input' statement                                    
                      (    rsdos_mmc.asm):01383         
C74C BDB26D           (    rsdos_mmc.asm):01384                        jsr     VarCKComma               ; syntax check for a comma                                      
                      (    rsdos_mmc.asm):01385         
C74F 8122             (    rsdos_mmc.asm):01386                        cmpa    #'"                      ; check for a double quote                                   
C751 260B             (    rsdos_mmc.asm):01387                        bne     lc881                    ; return to basic's 'input' command                                            
                      (    rsdos_mmc.asm):01388         
C753 BDB244           (    rsdos_mmc.asm):01389                        jsr     lb244                    ; strip prompt string from basic and put it on the string stack                                                                        
                      (    rsdos_mmc.asm):01390         
C756 BDB657           (    rsdos_mmc.asm):01391                        jsr     lb657                    ; purge the string put on the string stack                                                   
                      (    rsdos_mmc.asm):01392         
C759 C620             (    rsdos_mmc.asm):01393                        ldb     #'                       ;                         ; semicolon                   
C75B BDB26F           (    rsdos_mmc.asm):01394                        jsr     VarCKChar                ; do a syntax check for semicolon                                          
                      (    rsdos_mmc.asm):01395         
C75E 8EB01E           (    rsdos_mmc.asm):01396         lc881          ldx     #lb01e                   ; get modified reentry point into basic                                                      
C761 AF64             (    rsdos_mmc.asm):01397                        stx     $04,s                    ; and put it into the return address on the stack                                                          
C763 3596             (    rsdos_mmc.asm):01398                        puls    a,b,x,pc                 ; return to basic                              
                      (    rsdos_mmc.asm):01399         
                      (    rsdos_mmc.asm):01400         ; device number validity check ram hook
C765 2F25             (    rsdos_mmc.asm):01401         DosHookCheckIONum          ble     lc8af                    ; return if not a disk file                                         
C767 F1095B           (    rsdos_mmc.asm):01402                        cmpb    fcbact                   ; compare device number to highest possible                                                      
C76A 1022DEB1         (    rsdos_mmc.asm):01403                        lbhi    la61f                    ; 'device number' error if too big                                            
C76E 3590             (    rsdos_mmc.asm):01404                        puls    x,pc                     ; return                 
                      (    rsdos_mmc.asm):01405         
                      (    rsdos_mmc.asm):01406         ; set print parameters ram hook
C770 0D6F             (    rsdos_mmc.asm):01407         DosHookRetDevParam          tst     TextDevN                 ;check device number and                                       
C772 2F18             (    rsdos_mmc.asm):01408                        ble     lc8af                    ;return if not disk file                                 
C774 3262             (    rsdos_mmc.asm):01409                        leas    $02,s                    ; purge return address off of the stack                                                 
C776 3416             (    rsdos_mmc.asm):01410                        pshs    x,b,a                    ; save registers                          
C778 0F6E             (    rsdos_mmc.asm):01411                        clr     CasIOFlag                ; set print device number to non-cassette                                                   
C77A BDC621           (    rsdos_mmc.asm):01412                        jsr     >lc744                   ; point x to fcb                         
                      (    rsdos_mmc.asm):01413         
C77D E606             (    rsdos_mmc.asm):01414                        ldb     fcbpos,x                 ; get print position                                
C77F 4F               (    rsdos_mmc.asm):01415                        clra                             ; print width (256)                        
C780 8E1000           (    rsdos_mmc.asm):01416                        ldx     #$1000                   ; tab field width and tab zone                                        
C783 7EA37C           (    rsdos_mmc.asm):01417                        jmp     la37c                    ; save the print parameters                                    
                      (    rsdos_mmc.asm):01418         
                      (    rsdos_mmc.asm):01419         
                      (    rsdos_mmc.asm):01420         ; break check ram hook
C786 0D6F             (    rsdos_mmc.asm):01421         DosHookBreak         tst     TextDevN                 ; check device number and return                                                
C788 2F02             (    rsdos_mmc.asm):01422                        ble     lc8af                    ; if not a disk file                             
C78A 3262             (    rsdos_mmc.asm):01423                        leas    $02,s                    ; = purge return address off of the stack - don't                                                           
C78C 39               (    rsdos_mmc.asm):01424         lc8af          rts                              ; = do a break check if disk file                                          
                      (    rsdos_mmc.asm):01425         
                      (    rsdos_mmc.asm):01426         
                      (    rsdos_mmc.asm):01427         ; command interpretation ram hook
C78D                  (    rsdos_mmc.asm):01428         DosHookInterpret         
C78D 3262             (    rsdos_mmc.asm):01429                        leas    $02,s                    ; purge return address off of the stack                                                       
C78F 1CAF             (    rsdos_mmc.asm):01430         lc8b2          andcc   #$af                     ; enable irq & firq                                  
C791 7FFF02           (    rsdos_mmc.asm):01431                        clr     pia0+2                   ; strobe all keys (column strobe)                                           
C794 B6FF00           (    rsdos_mmc.asm):01432                        lda     pia0                     ; read keyboard rows                            
C797 43               (    rsdos_mmc.asm):01433                        coma                             ; invert keyboard row data                               
C798 847F             (    rsdos_mmc.asm):01434                        anda    #$7f                     ; mask off joystick input bit                                      
C79A 2703             (    rsdos_mmc.asm):01435                        beq     lc8c2                    ; branch if no key down                                
                      (    rsdos_mmc.asm):01436         
C79C BDADEB           (    rsdos_mmc.asm):01437                        jsr     BasPollKeyboard          ; go do a break check if a key is down                                               
                      (    rsdos_mmc.asm):01438         
C79F 9EA6             (    rsdos_mmc.asm):01439         lc8c2          ldx     BasAddrSigByte           ; get input pointer into x                                         
C7A1 9F2F             (    rsdos_mmc.asm):01440                        stx     BasDirectTextPtr         ; temp save it                        
C7A3 A680             (    rsdos_mmc.asm):01441                        lda     ,x+                      ; search for the end of current line                                           
C7A5 2707             (    rsdos_mmc.asm):01442                        beq     lc8d1                    ; branch if end of line                                
                      (    rsdos_mmc.asm):01443         
C7A7 813A             (    rsdos_mmc.asm):01444                        cmpa    #':                      ; check for end of sub line, too                                         
C7A9 2725             (    rsdos_mmc.asm):01445                        beq     lc8f3                    ; branch if end of sub line                                    
                      (    rsdos_mmc.asm):01446         
C7AB 7EB277           (    rsdos_mmc.asm):01447                        jmp     BasSNError               ; 'syntax' error if not end of line                                            
                      (    rsdos_mmc.asm):01448         
C7AE A681             (    rsdos_mmc.asm):01449         lc8d1          lda     ,x++                     ;get ms byte of address of next basic line                                                       
C7B0 9700             (    rsdos_mmc.asm):01450                        sta     BasBreakFlag             ;and save it in BasCurrentLine                                 
C7B2 2603             (    rsdos_mmc.asm):01451                        bne     lc8da                    ; branch if not end of program                                       
                      (    rsdos_mmc.asm):01452         
C7B4 7EAE15           (    rsdos_mmc.asm):01453                        jmp     lae15                    ; go 'stop' the system                               
                      (    rsdos_mmc.asm):01454         
C7B7 EC80             (    rsdos_mmc.asm):01455         lc8da          ldd     ,x+                      ;get line number of this line and                                             
C7B9 DD68             (    rsdos_mmc.asm):01456                        std     BasCurrentLine           ;save it in BasCurrentLine                            
C7BB 9FA6             (    rsdos_mmc.asm):01457                        stx     BasAddrSigByte           ; reset basic's input pointer                                       
C7BD 96AF             (    rsdos_mmc.asm):01458                        lda     BasTronFlag              ; check the trace flag and                                    
C7BF 270F             (    rsdos_mmc.asm):01459                        beq     lc8f3                    ; branch if trace off                              
                      (    rsdos_mmc.asm):01460         
C7C1 865B             (    rsdos_mmc.asm):01461                        lda     #'[                      ; < left delimiter of tron                                  
C7C3 BDA282           (    rsdos_mmc.asm):01462                        jsr     TextOutChar              ; send character to console out                                        
                      (    rsdos_mmc.asm):01463         
C7C6 9668             (    rsdos_mmc.asm):01464                        lda     BasCurrentLine           ; get number of current line number                                             
C7C8 BDBDCC           (    rsdos_mmc.asm):01465                        jsr     TextOutNum16             ; convert accd to decimal & print it on screen                                                       
                      (    rsdos_mmc.asm):01466         
C7CB 865D             (    rsdos_mmc.asm):01467                        lda     #']                      ; > right delimiter of tron                                   
C7CD BDA282           (    rsdos_mmc.asm):01468                        jsr     TextOutChar              ; send a character to console out                                          
                      (    rsdos_mmc.asm):01469         
C7D0 9D9F             (    rsdos_mmc.asm):01470         lc8f3          jsr     BasChrGet                ; get next character from basic                                              
                      (    rsdos_mmc.asm):01471         
C7D2 1FA9             (    rsdos_mmc.asm):01472                        tfr     cc,b                     ; save status register in accb                                      
C7D4 8198             (    rsdos_mmc.asm):01473                        cmpa    #$98                     ; csave token?                       
C7D6 2603             (    rsdos_mmc.asm):01474                        bne     lc8fe                    ; no             
                      (    rsdos_mmc.asm):01475         
C7D8 7E8316           (    rsdos_mmc.asm):01476                        jmp     l8316                    ; go check for csavem                              
                      (    rsdos_mmc.asm):01477         
C7DB 8197             (    rsdos_mmc.asm):01478         lc8fe          cmpa    #$97                     ; cload token?                            
C7DD 2603             (    rsdos_mmc.asm):01479                        bne     lc905                    ; no             
                      (    rsdos_mmc.asm):01480         
C7DF 7E8311           (    rsdos_mmc.asm):01481                        jmp     l8311                    ; jump to exbas' cload routine                                       
                      (    rsdos_mmc.asm):01482         
C7E2 1F9A             (    rsdos_mmc.asm):01483         lc905          tfr     b,cc                     ; restore status register                                      
C7E4 BDADC6           (    rsdos_mmc.asm):01484                        jsr     ladc6                    ; loop through basic's main interpretation loop                                                        
                      (    rsdos_mmc.asm):01485         
C7E7 20A6             (    rsdos_mmc.asm):01486                        bra     lc8b2                                
                      (    rsdos_mmc.asm):01487         
                      (    rsdos_mmc.asm):01488         ; eof ram hook
C7E9 3262             (    rsdos_mmc.asm):01489         DosHookEOF         leas    $02,s                    ; purge return address off of the stack                                                       
C7EB 966F             (    rsdos_mmc.asm):01490                        lda     TextDevN                 ; get device number and save                                      
C7ED 3402             (    rsdos_mmc.asm):01491                        pshs    a                        ; it on the stack                       
C7EF BDA5AE           (    rsdos_mmc.asm):01492                        jsr     la5ae                    ; strip device number off of input line                                                
                      (    rsdos_mmc.asm):01493         
C7F2 BDA3ED           (    rsdos_mmc.asm):01494                        jsr     la3ed                    ; verify that the file type was 'input'                                                
                      (    rsdos_mmc.asm):01495         
C7F5 0D6F             (    rsdos_mmc.asm):01496                        tst     TextDevN                 ; check device number and                                   
C7F7 102FDDDF         (    rsdos_mmc.asm):01497                        lble    la5da                    ; branch back to  basic's eof if not disk file                                                        
C7FB BDC621           (    rsdos_mmc.asm):01498                        jsr     >lc744                   ; point x to fcb                         
                      (    rsdos_mmc.asm):01499         
C7FE E684             (    rsdos_mmc.asm):01500                        ldb     fcbtyp,x                 ; get file type                           
C800 C140             (    rsdos_mmc.asm):01501                        cmpb    #ranfil                  ; random file?                          
C802 1027DE10         (    rsdos_mmc.asm):01502                        lbeq    BasFMError               ; 'fm' bad file mode error if random                                              
                      (    rsdos_mmc.asm):01503         
C806 5F               (    rsdos_mmc.asm):01504                        clrb                             ; file not empty flag - set to not empty                                             
C807 A68810           (    rsdos_mmc.asm):01505                        lda     fcbcfl,x                 ;check the cache flag - branch if                                             
C80A 2603             (    rsdos_mmc.asm):01506                        bne     lc932                    ;there is a character which has been cached                                                    
                      (    rsdos_mmc.asm):01507         
C80C E68817           (    rsdos_mmc.asm):01508                        ldb     fcbdfl,x                 ; get sequential input file status                                              
C80F 7EA5E4           (    rsdos_mmc.asm):01509         lc932          jmp     la5e4                    ; link back to basic's eof statement                                                  
                      (    rsdos_mmc.asm):01510         
                      (    rsdos_mmc.asm):01511         
                      (    rsdos_mmc.asm):01512         ; get filename/extension: drive number from basic
C812 8EC186           (    rsdos_mmc.asm):01513         lc935          ldx     #defext                  ; point to ' ' blank (default) extension                                                        
C815 6FE2             (    rsdos_mmc.asm):01514         lc938          clr     ,-s                      ; clear a byte on stack for use as a drives flag                                                       
C817 B6095A           (    rsdos_mmc.asm):01515                        lda     defdrv                   ; get default disk number                                   
C81A 97EB             (    rsdos_mmc.asm):01516                        sta     dcdrv                    ; store in dskcon parameter                                    
C81C CE094C           (    rsdos_mmc.asm):01517                        ldu     #dnambf                  ; disk filename buffer                                 
C81F CC2008           (    rsdos_mmc.asm):01518                        ldd     #$2008                   ; store 8 blanks in ram (default file name)                                                     
C822 A7C0             (    rsdos_mmc.asm):01519         lc945          sta     ,u+                      ; store a blank in file name                                        
C824 5A               (    rsdos_mmc.asm):01520                        decb                             ; decrement counter                        
C825 26FB             (    rsdos_mmc.asm):01521                        bne     lc945                    ; branch if not done                             
                      (    rsdos_mmc.asm):01522         
C827 C603             (    rsdos_mmc.asm):01523                        ldb     #$03                     ; 3 bytes in extension                              
C829 BDA59A           (    rsdos_mmc.asm):01524                        jsr     UtilCopyBXtoU            ; move b bytes from (x) to (u)                                       
                      (    rsdos_mmc.asm):01525         
C82C BD8748           (    rsdos_mmc.asm):01526                        jsr     l8748                    ; evaluate a string expression                                       
                      (    rsdos_mmc.asm):01527         
C82F 3384             (    rsdos_mmc.asm):01528                        leau    ,x                       ; point u to start of string                                   
C831 C102             (    rsdos_mmc.asm):01529                        cmpb    #$02                     ; check length of string and                                     
C833 2512             (    rsdos_mmc.asm):01530                        blo     lc96a                    ; branch if < 2                        
                      (    rsdos_mmc.asm):01531         
C835 A641             (    rsdos_mmc.asm):01532                        lda     $01,u                    ; = get 2nd character in string and                                            
C837 813A             (    rsdos_mmc.asm):01533                        cmpa    #':                      ; = check for colon                            
C839 260C             (    rsdos_mmc.asm):01534                        bne     lc96a                    ; branch if no drive number                                    
                      (    rsdos_mmc.asm):01535         
C83B A6C4             (    rsdos_mmc.asm):01536                        lda     ,u                       ; get 1st character                         
C83D 8130             (    rsdos_mmc.asm):01537                        cmpa    #'0                      ; in string and                        
C83F 2506             (    rsdos_mmc.asm):01538                        blo     lc96a                    ; check to see                       
                      (    rsdos_mmc.asm):01539         
C841 8133             (    rsdos_mmc.asm):01540                        cmpa    #'3                      ; if it is in                      
C843 2202             (    rsdos_mmc.asm):01541                        bhi     lc96a                    ; the range 0-3                        
C845 8D33             (    rsdos_mmc.asm):01542                        bsr     lc99d                    ; get drive number                           
                      (    rsdos_mmc.asm):01543         
C847 8E094C           (    rsdos_mmc.asm):01544         lc96a          ldx     #dnambf                  ; point x to file name buffer                                             
C84A 5C               (    rsdos_mmc.asm):01545                        incb                             ; compensate for decb below                                
C84B 5A               (    rsdos_mmc.asm):01546         lc96e          decb                             ; decrement string length                                   
C84C 260C             (    rsdos_mmc.asm):01547                        bne     lc97d                    ; branch if more characters in string                                              
                      (    rsdos_mmc.asm):01548         
C84E 3261             (    rsdos_mmc.asm):01549                        leas    $01,s                    ; clean up stack - remove drive flag                                              
C850 8C094C           (    rsdos_mmc.asm):01550         lc973          cmpx    #dnambf                  ; pointer still at start of buffer?                                                    
C853 2667             (    rsdos_mmc.asm):01551                        bne     lc9df                    ; return if not                        
                      (    rsdos_mmc.asm):01552         
C855 C63E             (    rsdos_mmc.asm):01553         lc978          ldb     #2*31                    ; 'bad filename' error if null filename                                                                               
C857 7EAC46           (    rsdos_mmc.asm):01554                        jmp     SysErr                   ; error handler                        
                      (    rsdos_mmc.asm):01555         
C85A A6C0             (    rsdos_mmc.asm):01556         lc97d          lda     ,u+                      ; get a character from string                                         
C85C 812E             (    rsdos_mmc.asm):01557                        cmpa    #'.                      ; look for period?                           
C85E 272D             (    rsdos_mmc.asm):01558                        beq     lc9b0                    ; yes              
                      (    rsdos_mmc.asm):01559         
C860 812F             (    rsdos_mmc.asm):01560                        cmpa    #'/                      ; slash?                 
C862 2729             (    rsdos_mmc.asm):01561                        beq     lc9b0                    ; yes              
                      (    rsdos_mmc.asm):01562         
C864 813A             (    rsdos_mmc.asm):01563                        cmpa    #':                      ; colon?                 
C866 2709             (    rsdos_mmc.asm):01564                        beq     lc994                    ; yes              
                      (    rsdos_mmc.asm):01565         
C868 8C0954           (    rsdos_mmc.asm):01566                        cmpx    #dextbf                  ; compare pointer to end of filename buffer                                                       
C86B 27E8             (    rsdos_mmc.asm):01567                        beq     lc978                    ; 'bad filename' error - filename too long                                                   
                      (    rsdos_mmc.asm):01568         
C86D 8D3E             (    rsdos_mmc.asm):01569                        bsr     lc9d0                    ; put a character in filename                                      
                      (    rsdos_mmc.asm):01570         
C86F 20DA             (    rsdos_mmc.asm):01571                        bra     lc96e                    ; get another character from string                                            
C871 8DDD             (    rsdos_mmc.asm):01572         lc994          bsr     lc973                    ; 'bad filename' error if no filename yet                                                       
                      (    rsdos_mmc.asm):01573         
C873 8D05             (    rsdos_mmc.asm):01574                        bsr     lc99d                    ; get drive number                           
                      (    rsdos_mmc.asm):01575         
C875 5D               (    rsdos_mmc.asm):01576                        tstb                             ; check length of string                             
C876 26DD             (    rsdos_mmc.asm):01577                        bne     lc978                    ; ''bad filename' error if more characters left                                                        
                      (    rsdos_mmc.asm):01578         
C878 3582             (    rsdos_mmc.asm):01579         lc99b          puls    a,pc                     ; remove drives flag from stack and return                                                        
                      (    rsdos_mmc.asm):01580         
                      (    rsdos_mmc.asm):01581         ; grab drive number
C87A 6362             (    rsdos_mmc.asm):01582         lc99d          com     $02,s                    ; toggle drive flag                                 
C87C 27D7             (    rsdos_mmc.asm):01583                        beq     lc978                    ; 'bad filename' error if drive number defined twice                                                             
                      (    rsdos_mmc.asm):01584         
C87E A6C1             (    rsdos_mmc.asm):01585                        lda     ,u++                     ; ascii value of drive number to acca                                             
C880 C002             (    rsdos_mmc.asm):01586                        subb    #$02                     ; decrement string length by 2 for drive (:x)                                                      
C882 8030             (    rsdos_mmc.asm):01587                        suba    #'0                      ; subtract ascii bias                              
C884 25CF             (    rsdos_mmc.asm):01588                        blo     lc978                    ; drive number too low - 'bad filename' error                                                      
                      (    rsdos_mmc.asm):01589         
C886 8103             (    rsdos_mmc.asm):01590                        cmpa    #$03                     ; max of 4 drives                          
C888 22CB             (    rsdos_mmc.asm):01591                        bhi     lc978                    ; drive number too high - 'bad filename' error                                                       
C88A 97EB             (    rsdos_mmc.asm):01592                        sta     dcdrv                    ; store in dskcon drive number                                       
C88C 39               (    rsdos_mmc.asm):01593                        rts                                     
                      (    rsdos_mmc.asm):01594         
                      (    rsdos_mmc.asm):01595         
                      (    rsdos_mmc.asm):01596         ; grab extension
C88D 8DC1             (    rsdos_mmc.asm):01597         lc9b0          bsr     lc973                    ; 'bad filename' error if no filename yet                                                       
                      (    rsdos_mmc.asm):01598         
C88F 8E0957           (    rsdos_mmc.asm):01599                        ldx     #dfltyp                  ; point x to end of extension buffer                                               
C892 8620             (    rsdos_mmc.asm):01600                        lda     #space                   ; blank                 
C894 A782             (    rsdos_mmc.asm):01601         lc9b7          sta     ,-x                      ;             
C896 8C0954           (    rsdos_mmc.asm):01602                        cmpx    #dextbf                  ; fill extension with                                 
C899 26F9             (    rsdos_mmc.asm):01603                        bne     lc9b7                    ; blanks (default)                           
                      (    rsdos_mmc.asm):01604         
C89B 5A               (    rsdos_mmc.asm):01605         lc9be          decb                             ; decrement string counter                                    
C89C 27DA             (    rsdos_mmc.asm):01606                        beq     lc99b                    ; return if zero                         
                      (    rsdos_mmc.asm):01607         
C89E A6C0             (    rsdos_mmc.asm):01608                        lda     ,u+                      ; get a character from string                                    
C8A0 813A             (    rsdos_mmc.asm):01609                        cmpa    #':                      ;check for drive separator                                   
C8A2 27CD             (    rsdos_mmc.asm):01610                        beq     lc994                    ;          
                      (    rsdos_mmc.asm):01611         
C8A4 8C0957           (    rsdos_mmc.asm):01612                        cmpx    #dfltyp                  ; =check for end of estension ram buffer &                                                      
C8A7 27AC             (    rsdos_mmc.asm):01613                        beq     lc978                    ; = 'bad filename' error if extension too long                                                       
                      (    rsdos_mmc.asm):01614         
C8A9 8D02             (    rsdos_mmc.asm):01615                        bsr     lc9d0                    ; put a character in extension buffer                                              
                      (    rsdos_mmc.asm):01616         
C8AB 20EE             (    rsdos_mmc.asm):01617                        bra     lc9be                    ; get another extension character                                          
                      (    rsdos_mmc.asm):01618         
                      (    rsdos_mmc.asm):01619         ; insert character into filename or extension
C8AD A780             (    rsdos_mmc.asm):01620         lc9d0          sta     ,x+                      ; store character in filename buffer                                                
C8AF 27A4             (    rsdos_mmc.asm):01621                        beq     lc978                    ; 'bad filename' error; zeroes are illegal                                                   
                      (    rsdos_mmc.asm):01622         
C8B1 812E             (    rsdos_mmc.asm):01623                        cmpa    #'.                      ; period?                  
C8B3 27A0             (    rsdos_mmc.asm):01624                        beq     lc978                    ; 'bad filename' error if period                                         
                      (    rsdos_mmc.asm):01625         
C8B5 812F             (    rsdos_mmc.asm):01626                        cmpa    #'/                      ; slash?                 
C8B7 279C             (    rsdos_mmc.asm):01627                        beq     lc978                    ; 'bad filename' error if slash                                        
                      (    rsdos_mmc.asm):01628         
C8B9 4C               (    rsdos_mmc.asm):01629                        inca                             ; check for $ff                    
C8BA 2799             (    rsdos_mmc.asm):01630                        beq     lc978                    ; 'bad filename' error if $ff                                      
                      (    rsdos_mmc.asm):01631         
C8BC 39               (    rsdos_mmc.asm):01632         lc9df          rts                                          
                      (    rsdos_mmc.asm):01633         
                      (    rsdos_mmc.asm):01634         
                      (    rsdos_mmc.asm):01635         ; save command
C8BD 814D             (    rsdos_mmc.asm):01636         CmdSave           cmpa    #'M                      ;              
C8BF 10270582         (    rsdos_mmc.asm):01637                        lbeq    lcf68                    ;branch if savem                          
                      (    rsdos_mmc.asm):01638         
C8C3 8D4B             (    rsdos_mmc.asm):01639                        bsr     lca33                    ; go get filename, etc. from basic                                           
                      (    rsdos_mmc.asm):01640         
C8C5 9E8A             (    rsdos_mmc.asm):01641                        ldx     Misc16BitScratch         ; zero out x reg                        
C8C7 BF0957           (    rsdos_mmc.asm):01642                        stx     dfltyp                   ; set file type and ascii flag to zero                                                
C8CA 9DA5             (    rsdos_mmc.asm):01643                        jsr     BasChrGetCurr            ; get current input character from basic                                                  
                      (    rsdos_mmc.asm):01644         
C8CC 2721             (    rsdos_mmc.asm):01645                        beq     lca12                    ; branch if end of line                                
                      (    rsdos_mmc.asm):01646         
C8CE BDB26D           (    rsdos_mmc.asm):01647                        jsr     VarCKComma               ; syntax check for comma                                    
                      (    rsdos_mmc.asm):01648         
C8D1 C641             (    rsdos_mmc.asm):01649                        ldb     #'A                      ;ascii file?                    
C8D3 BDB26F           (    rsdos_mmc.asm):01650                        jsr     VarCKChar                ;syntax check on contents of accb                                          
                      (    rsdos_mmc.asm):01651         
C8D6 26E4             (    rsdos_mmc.asm):01652                        bne     lc9df                    ; return if no more characters on line                                               
                      (    rsdos_mmc.asm):01653         
C8D8 730958           (    rsdos_mmc.asm):01654                        com     dascfl                   ; set crunched/ascii flag to ascii                                            
C8DB 8D04             (    rsdos_mmc.asm):01655                        bsr     lca04                    ; open a sequential file for output                                            
                      (    rsdos_mmc.asm):01656         
C8DD 4F               (    rsdos_mmc.asm):01657                        clra                             ; set zero flag - cause entire file to be listed                                                     
C8DE 7EB764           (    rsdos_mmc.asm):01658                        jmp     BasList                  ; 'list' the file to console out                                        
                      (    rsdos_mmc.asm):01659         
                      (    rsdos_mmc.asm):01660         
                      (    rsdos_mmc.asm):01661         ; open a sequential file for input/output - use the system
                      (    rsdos_mmc.asm):01662         ; fcb located at the top of fcbs
C8E1 864F             (    rsdos_mmc.asm):01663         lca04          lda     #'O                      ; output file type                               
C8E3 8C               (    rsdos_mmc.asm):01664         lca06          fcb      Skip2                   ; cmpx
C8E4 8649             (    rsdos_mmc.asm):01665         lca07          lda     #'I                      ; input file type                              
C8E6 F6095B           (    rsdos_mmc.asm):01666                        ldb     fcbact                   ; get number of reserved files currently reserved                                                           
C8E9 5C               (    rsdos_mmc.asm):01667                        incb                             ; add one - use one above highest reserved fcb                                                   
C8EA D76F             (    rsdos_mmc.asm):01668                        stb     TextDevN                 ; save it in device number                                    
C8EC 7EC36A           (    rsdos_mmc.asm):01669                        jmp     >lc48d                   ; open a file & initialize fcb                                       
                      (    rsdos_mmc.asm):01670         
                      (    rsdos_mmc.asm):01671         ; save a crunched file - a preamble of three bytes will preceed crunched
                      (    rsdos_mmc.asm):01672         ; files: byte 1 = $ff, 2,3 = length of basic program
C8EF 8DF0             (    rsdos_mmc.asm):01673         lca12          bsr     lca04                    ; open a sequential file for output                                                 
                      (    rsdos_mmc.asm):01674         
C8F1 86FF             (    rsdos_mmc.asm):01675                        lda     #$ff                     ; basic file flag                         
C8F3 BDCB01           (    rsdos_mmc.asm):01676                        jsr     >lcc24                   ; console out                      
                      (    rsdos_mmc.asm):01677         
C8F6 DC1B             (    rsdos_mmc.asm):01678                        ldd     BasVarSimpleAddr         ; load accd with start of variables                                             
C8F8 9319             (    rsdos_mmc.asm):01679                        subd    BasStartProg             ; subtract start of basic                                    
C8FA BDCB01           (    rsdos_mmc.asm):01680                        jsr     >lcc24                   ; console out file length ms byte                                          
                      (    rsdos_mmc.asm):01681         
C8FD 1F98             (    rsdos_mmc.asm):01682                        tfr     b,a                      ; pull ls byte into acca                               
C8FF BDCB01           (    rsdos_mmc.asm):01683                        jsr     >lcc24                   ; console out file length ls byte                                          
                      (    rsdos_mmc.asm):01684         
C902 9E19             (    rsdos_mmc.asm):01685                        ldx     BasStartProg             ; point x to start of basic                                     
C904 A680             (    rsdos_mmc.asm):01686         lca27          lda     ,x+                      ; get byte from basic                                 
C906 BDCB01           (    rsdos_mmc.asm):01687                        jsr     >lcc24                   ; send to console out                              
                      (    rsdos_mmc.asm):01688         
C909 9C1B             (    rsdos_mmc.asm):01689                        cmpx    BasVarSimpleAddr         ; compare to end of basic                                    
C90B 26F7             (    rsdos_mmc.asm):01690                        bne     lca27                    ; keep going if not at end                                   
                      (    rsdos_mmc.asm):01691         
C90D 7EA42D           (    rsdos_mmc.asm):01692                        jmp     la42d                    ; close file                     
                      (    rsdos_mmc.asm):01693         
C910 8EC183           (    rsdos_mmc.asm):01694         lca33          ldx     #basext                  ; point to 'bas' extension (default)                                               
C913 7EC815           (    rsdos_mmc.asm):01695                        jmp     >lc938                   ; get filename.ext from basic                                      
                      (    rsdos_mmc.asm):01696         
                      (    rsdos_mmc.asm):01697         
                      (    rsdos_mmc.asm):01698         ; merge command
C916 4F               (    rsdos_mmc.asm):01699         CmdMerge          clra                             ; run flag (0 = don't run)                                    
C917 C6FF             (    rsdos_mmc.asm):01700                        ldb     #$ff                     ; merge flag ($ff = merge)                                  
C919 2012             (    rsdos_mmc.asm):01701                        bra     lca50                    ; go load the file                           
                      (    rsdos_mmc.asm):01702         
                      (    rsdos_mmc.asm):01703         ; run ram vector
C91B 8122             (    rsdos_mmc.asm):01704         DosHookRun         cmpa    #'"                      ; check for filename delimiter (double quote)                                                            
C91D 1026B97B         (    rsdos_mmc.asm):01705                        lbne    CoCoVect194              ; none - jump to exbas run ram hook                                              
                      (    rsdos_mmc.asm):01706         
C921 8602             (    rsdos_mmc.asm):01707                        lda     #$02                     ; run flag - don't close all files before run                                                     
C923 2007             (    rsdos_mmc.asm):01708                        bra     lca4f                    ; load the file                        
                      (    rsdos_mmc.asm):01709         
                      (    rsdos_mmc.asm):01710         ; load command
C925 814D             (    rsdos_mmc.asm):01711         CmdLoad           cmpa    #'M                      ;              
C927 10270573         (    rsdos_mmc.asm):01712                        lbeq    lcfc1                    ;branch if loadm                          
                      (    rsdos_mmc.asm):01713         
C92B 4F               (    rsdos_mmc.asm):01714                        clra                             ; run flag = zero (don't run)                                  
C92C 5F               (    rsdos_mmc.asm):01715         lca4f          clrb                             ; clear merge flag                            
C92D B70959           (    rsdos_mmc.asm):01716         lca50          sta     drunfl                   ; run flag (0 = don't run, 2 = run)                                                  
C930 F7095E           (    rsdos_mmc.asm):01717                        stb     dmrgfl                   ; merge flag (0 = no merge, $ff = merge)                                                  
C933 8DDB             (    rsdos_mmc.asm):01718                        bsr     lca33                    ; go get filename, etc. from basic                                           
                      (    rsdos_mmc.asm):01719         
C935 9DA5             (    rsdos_mmc.asm):01720                        jsr     BasChrGetCurr            ; get current input char                                  
                      (    rsdos_mmc.asm):01721         
C937 2710             (    rsdos_mmc.asm):01722                        beq     lca6c                    ; branch if end of line                                
                      (    rsdos_mmc.asm):01723         
C939 BDB26D           (    rsdos_mmc.asm):01724                        jsr     VarCKComma               ; syntax check for comma                                    
                      (    rsdos_mmc.asm):01725         
C93C C652             (    rsdos_mmc.asm):01726                        ldb     #'R                      ;         
C93E BDB26F           (    rsdos_mmc.asm):01727                        jsr     VarCKChar                ;is next char 'r'? run after load                                          
                      (    rsdos_mmc.asm):01728         
C941 BDA5C7           (    rsdos_mmc.asm):01729                        jsr     la5c7                    ; syntax error if any more chars on line                                                 
                      (    rsdos_mmc.asm):01730         
C944 8603             (    rsdos_mmc.asm):01731                        lda     #$03                     ;set flags to run and close all files                                             
C946 B70959           (    rsdos_mmc.asm):01732                        sta     drunfl                   ;before the file is run                                 
C949 8D99             (    rsdos_mmc.asm):01733         lca6c          bsr     lca07                    ; grab fcb for input file                                       
                      (    rsdos_mmc.asm):01734         
C94B B60958           (    rsdos_mmc.asm):01735                        lda     dascfl                   ;check ascii flag and branch                                      
C94E 270B             (    rsdos_mmc.asm):01736                        beq     lca7e                    ;if crunched basic file                                
                      (    rsdos_mmc.asm):01737         
C950 7D095E           (    rsdos_mmc.asm):01738                        tst     dmrgfl                   ; is this a merge?                            
C953 2603             (    rsdos_mmc.asm):01739                        bne     lca7b                    ; branch if merge                          
                      (    rsdos_mmc.asm):01740         
C955 BDAD19           (    rsdos_mmc.asm):01741                        jsr     BasNew                   ; do a 'new' - erase variables, reset variables                                                        
                      (    rsdos_mmc.asm):01742         
C958 7EAC7C           (    rsdos_mmc.asm):01743         lca7b          jmp     lac7c                    ; go to basic's main loop, it will load program                                                             
                      (    rsdos_mmc.asm):01744         
                      (    rsdos_mmc.asm):01745         
                      (    rsdos_mmc.asm):01746         ; load in a crunched basic file
C95B B60957           (    rsdos_mmc.asm):01747         lca7e          lda     dfltyp                   ;check file type (must be basic:0) & check                                                         
C95E BA095E           (    rsdos_mmc.asm):01748                        ora     dmrgfl                   ;merge flag (must be no merge: 0)                                           
C961 1026DCB1         (    rsdos_mmc.asm):01749                        lbne    BasFMError               ; 'bad file mode' error if merge or non-basic                                                       
                      (    rsdos_mmc.asm):01750         
C965 BDAD19           (    rsdos_mmc.asm):01751                        jsr     BasNew                   ; do a 'new' - reset pointers, erase variables                                                       
                      (    rsdos_mmc.asm):01752         
C968 73095D           (    rsdos_mmc.asm):01753                        com     dloadfl                  ; set the load flag to $ff - this will cause a new to                                                               
                      (    rsdos_mmc.asm):01754                                                         ; occur if an error occurs while the program is being loaded
C96B BDCC99           (    rsdos_mmc.asm):01755                        jsr     >lcdbc                   ; get char from buffer - should be $ff                                               
                      (    rsdos_mmc.asm):01756         
C96E BDCC99           (    rsdos_mmc.asm):01757                        jsr     >lcdbc                   ; get another - ms byte of length                                          
                      (    rsdos_mmc.asm):01758         
C971 3402             (    rsdos_mmc.asm):01759                        pshs    a                        ; save ms byte on stack                             
C973 BDCC99           (    rsdos_mmc.asm):01760                        jsr     >lcdbc                   ; ls byte of length of program                                       
                      (    rsdos_mmc.asm):01761         
C976 1F89             (    rsdos_mmc.asm):01762                        tfr     a,b                      ; put ls byte into accb                              
C978 3502             (    rsdos_mmc.asm):01763                        puls    a                        ; now accd contains length of program                                           
C97A D319             (    rsdos_mmc.asm):01764                        addd    BasStartProg             ; add beginning of basic                                   
C97C BDAC37           (    rsdos_mmc.asm):01765                        jsr     lac37                    ; see of enough room in ram for this file                                                  
                      (    rsdos_mmc.asm):01766         
C97F 9E19             (    rsdos_mmc.asm):01767                        ldx     BasStartProg             ; get start of basic                              
C981 BDC4A1           (    rsdos_mmc.asm):01768         lcaa4          jsr     >lc5c4                   ; read a char from console in                                           
                      (    rsdos_mmc.asm):01769         
C984 D670             (    rsdos_mmc.asm):01770                        ldb     cinbfl                   ; buffer empty?                         
C986 2604             (    rsdos_mmc.asm):01771                        bne     lcaaf                    ; branch if so                       
                      (    rsdos_mmc.asm):01772         
C988 A780             (    rsdos_mmc.asm):01773                        sta     ,x+                      ; store char                   
C98A 20F5             (    rsdos_mmc.asm):01774                        bra     lcaa4                    ; get another character                                
                      (    rsdos_mmc.asm):01775         
C98C 7F095D           (    rsdos_mmc.asm):01776         lcaaf          clr     dloadfl                  ; clear load flag - load was error free                                                      
C98F 9F1B             (    rsdos_mmc.asm):01777                        stx     BasVarSimpleAddr         ; save new start of variables                                       
                      (    rsdos_mmc.asm):01778         ; make sure last three bytes loaded were zero
C991 C603             (    rsdos_mmc.asm):01779                        ldb     #$03                     ; check three bytes                           
C993 A682             (    rsdos_mmc.asm):01780         lcab6          lda     ,-x                      ; check a byte                          
C995 2603             (    rsdos_mmc.asm):01781                        bne     lcabd                    ; branch if non-zero                             
                      (    rsdos_mmc.asm):01782         
C997 5A               (    rsdos_mmc.asm):01783                        decb                             ; decrement counter                        
C998 26F9             (    rsdos_mmc.asm):01784                        bne     lcab6                    ; keep checking if not done                                    
                      (    rsdos_mmc.asm):01785         
C99A 9E1B             (    rsdos_mmc.asm):01786         lcabd          ldx     BasVarSimpleAddr         ; get start of variables                                       
C99C 9F1B             (    rsdos_mmc.asm):01787         lcabf          stx     BasVarSimpleAddr         ; save start of variables                                        
C99E 6F80             (    rsdos_mmc.asm):01788                        clr     ,x+                      ; clear a byte                     
C9A0 5A               (    rsdos_mmc.asm):01789                        decb                             ; decremrnt counter                        
C9A1 2AF9             (    rsdos_mmc.asm):01790                        bpl     lcabf                    ; keep clearing bytes if not done                                          
C9A3 BDA42D           (    rsdos_mmc.asm):01791         lcac6          jsr     la42d                    ; close selected file                                   
                      (    rsdos_mmc.asm):01792         
C9A6 BDAD21           (    rsdos_mmc.asm):01793                        jsr     BasVect1                 ; do part of new - erase variables, reset input ptr                                                            
                      (    rsdos_mmc.asm):01794         
C9A9 BD829C           (    rsdos_mmc.asm):01795                        jsr     CoCoVect194              ; initialize exbas graphics variables                                               
                      (    rsdos_mmc.asm):01796         
C9AC BDACEF           (    rsdos_mmc.asm):01797                        jsr     BasVect2                 ; relocate all the basic next line pointers                                                    
                      (    rsdos_mmc.asm):01798         
C9AF 770959           (    rsdos_mmc.asm):01799                        asr     drunfl                   ; check lsb of run flag                                 
C9B2 2503             (    rsdos_mmc.asm):01800                        blo     lcada                    ; branch if don't close all files                                          
                      (    rsdos_mmc.asm):01801         
C9B4 BDA426           (    rsdos_mmc.asm):01802                        jsr     la426                    ; close all files                          
                      (    rsdos_mmc.asm):01803         
C9B7 770959           (    rsdos_mmc.asm):01804         lcada          asr     drunfl                   ; test bit 1 of run flag                                       
C9BA 1025E3E0         (    rsdos_mmc.asm):01805                        lbcs    BasRun                   ; branch to comm interpretation loop if bit 1 set                                                           
                      (    rsdos_mmc.asm):01806         
C9BE 7EAC73           (    rsdos_mmc.asm):01807                        jmp     BasCmdMode               ; return to direct mode                                
                      (    rsdos_mmc.asm):01808         
                      (    rsdos_mmc.asm):01809         
C9C1 0D6F             (    rsdos_mmc.asm):01810         DosHookTermInputLine         tst     TextDevN                 ; check device number and                                         
C9C3 2EDE             (    rsdos_mmc.asm):01811                        bgt     lcac6                    ; try to run file if it is a disk file                                               
C9C5 39               (    rsdos_mmc.asm):01812                        rts                                     
                      (    rsdos_mmc.asm):01813         
                      (    rsdos_mmc.asm):01814         
                      (    rsdos_mmc.asm):01815         ; close all file buffers ram vector
C9C6 F6095B           (    rsdos_mmc.asm):01816         DosCloseAllFiles          ldb     fcbact                   ; get the number of reserved file buffers                                                        
C9C9 5C               (    rsdos_mmc.asm):01817                        incb                             ; add one              
C9CA 3404             (    rsdos_mmc.asm):01818         lcaed          pshs    b                        ; save it                    
C9CC D76F             (    rsdos_mmc.asm):01819                        stb     TextDevN                 ; store it in device number                                     
C9CE 8D0E             (    rsdos_mmc.asm):01820                        bsr     lcb01                    ; close file                     
                      (    rsdos_mmc.asm):01821         
C9D0 3504             (    rsdos_mmc.asm):01822                        puls    b                        ; get back number of file buffers                                       
C9D2 5A               (    rsdos_mmc.asm):01823                        decb                             ; decrement file buffer counter                                    
C9D3 26F5             (    rsdos_mmc.asm):01824                        bne     lcaed                    ; branch if all files not closed                                         
                      (    rsdos_mmc.asm):01825         
C9D5 39               (    rsdos_mmc.asm):01826         lcaf8          rts                                          
                      (    rsdos_mmc.asm):01827         
                      (    rsdos_mmc.asm):01828         
                      (    rsdos_mmc.asm):01829         ; close file ram hook
C9D6 0D6F             (    rsdos_mmc.asm):01830         DosHookCloseFile          tst     TextDevN                 ; check device number and return                                               
C9D8 102FB8AA         (    rsdos_mmc.asm):01831                        lble    CoCoVect176              ; if not a disk file                              
C9DC 3262             (    rsdos_mmc.asm):01832                        leas    $02,s                    ; purge return address off of the stack                                                 
C9DE BDC621           (    rsdos_mmc.asm):01833         lcb01          jsr     >lc744                   ; point x to correct fcb                                      
                      (    rsdos_mmc.asm):01834         
C9E1 0F6F             (    rsdos_mmc.asm):01835                        clr     TextDevN                 ; set device number to screen                                       
C9E3 9FF1             (    rsdos_mmc.asm):01836         lcb06          stx     fcbtmp                   ; save file buffer pointer                                         
C9E5 A684             (    rsdos_mmc.asm):01837                        lda     fcbtyp,x                 ; get the type of this file                                       
C9E7 27EC             (    rsdos_mmc.asm):01838                        beq     lcaf8                    ; return if file not open                                  
                      (    rsdos_mmc.asm):01839         
C9E9 3402             (    rsdos_mmc.asm):01840                        pshs    a                        ; save file type                      
C9EB 6F84             (    rsdos_mmc.asm):01841                        clr     fcbtyp,x                 ; close the file - zero out the file type                                                     
C9ED E601             (    rsdos_mmc.asm):01842                        ldb     fcbdrv,x                 ; get drive number and                                  
C9EF D7EB             (    rsdos_mmc.asm):01843                        stb     dcdrv                    ; save it in dskcon variable                                     
C9F1 8120             (    rsdos_mmc.asm):01844                        cmpa    #outfil                  ; = check for output type and                                         
C9F3 2619             (    rsdos_mmc.asm):01845                        bne     lcb31                    ; = branch if not output type file                                           
                      (    rsdos_mmc.asm):01846         
                      (    rsdos_mmc.asm):01847         
                      (    rsdos_mmc.asm):01848         ; close a sequential output file
C9F5 E68818           (    rsdos_mmc.asm):01849                        ldb     fcblft,x                 ; get the number of characters in buffer                                                    
C9F8 8680             (    rsdos_mmc.asm):01850                        lda     #$80                     ; set the pre-saved bit to indicate that the data                                                         
                      (    rsdos_mmc.asm):01851                                                         ; has already been saved on disk
C9FA AA05             (    rsdos_mmc.asm):01852                        ora     fcbcpt,x                 ; 'or' in the full sector flag                                          
C9FC ED8813           (    rsdos_mmc.asm):01853                        std     fcblst,x                 ; save the number of bytes used in the last sector                                                              
                      (    rsdos_mmc.asm):01854         
C9FF 6C04             (    rsdos_mmc.asm):01855                        inc     fcbsec,x                 ; increment the sector number                                         
CA01 E603             (    rsdos_mmc.asm):01856                        ldb     fcbcgr,x                 ; get the current granule number                                            
CA03 BDC632           (    rsdos_mmc.asm):01857                        jsr     >lc755                   ; point x to file allocation table                                           
                      (    rsdos_mmc.asm):01858         
CA06 A701             (    rsdos_mmc.asm):01859                        sta     fat1,x                   ; set fat data not valid flag (acca <> 0)                                                   
CA08 3A               (    rsdos_mmc.asm):01860                        abx                              ; add granule offset to fat pointer                                       
CA09 6C06             (    rsdos_mmc.asm):01861                        inc     fatcon,x                 ; increment granule data (add one sector to last                                                            
                      (    rsdos_mmc.asm):01862                                                         ; granule) skip past the six fat control bytes
CA0B 7ECAA0           (    rsdos_mmc.asm):01863         lcb2e          jmp     >lcbc3                   ; update fat and directory                                        
                      (    rsdos_mmc.asm):01864         
CA0E 8140             (    rsdos_mmc.asm):01865         lcb31          cmpa    #ranfil                  ; random file?                               
CA10 26F9             (    rsdos_mmc.asm):01866                        bne     lcb2e                    ; no - update fat and directory if sequential input file                                                                 
                      (    rsdos_mmc.asm):01867         
                      (    rsdos_mmc.asm):01868         
                      (    rsdos_mmc.asm):01869         ; close a random file
CA12 EC09             (    rsdos_mmc.asm):01870                        ldd     fcbrln,x                 ; get record length                               
CA14 AE0B             (    rsdos_mmc.asm):01871                        ldx     fcbbuf,x                 ; point x to random file buffer                                           
CA16 318B             (    rsdos_mmc.asm):01872                        leay    d,x                      ; point y to end of random file buffer                                              
CA18 3436             (    rsdos_mmc.asm):01873                        pshs    y,x,b,a                  ; save pointers on stack                                    
CA1A 31E4             (    rsdos_mmc.asm):01874                        leay    ,s                       ; point y current stack pointer                                      
CA1C DE1B             (    rsdos_mmc.asm):01875                        ldu     BasVarSimpleAddr         ; get start of variables                                  
CA1E 11931D           (    rsdos_mmc.asm):01876         lcb41          cmpu    BasVarArrayAddr          ; compare to start of arrays                                            
CA21 270E             (    rsdos_mmc.asm):01877                        beq     lcb54                    ; branch if all variables checked                                          
                      (    rsdos_mmc.asm):01878         
CA23 A641             (    rsdos_mmc.asm):01879                        lda     $01,u                    ; get 2nd byte of variable name                                        
CA25 3342             (    rsdos_mmc.asm):01880                        leau    $02,u                    ; move pointer to start of descriptor                                               
CA27 2A02             (    rsdos_mmc.asm):01881                        bpl     lcb4e                    ; branch if variable - numeric                                       
CA29 8D28             (    rsdos_mmc.asm):01882                        bsr     lcb76                    ; adjust string variable if in random file buffer                                                          
                      (    rsdos_mmc.asm):01883         
CA2B 3345             (    rsdos_mmc.asm):01884         lcb4e          leau    $05,u                    ; move pointer to next variable                                              
CA2D 20EF             (    rsdos_mmc.asm):01885                        bra     lcb41                    ; process another variable                                   
CA2F 3540             (    rsdos_mmc.asm):01886         lcb52          puls    u                        ; get address of next array to u                                           
CA31 11931F           (    rsdos_mmc.asm):01887         lcb54          cmpu    BasVarEnd                ; compare to end of arrays                                          
CA34 273A             (    rsdos_mmc.asm):01888                        beq     lcb93                    ; branch if end of arrays                                  
                      (    rsdos_mmc.asm):01889         
CA36 1F30             (    rsdos_mmc.asm):01890                        tfr     u,d                      ; save array start in accd, add offset                                             
CA38 E342             (    rsdos_mmc.asm):01891                        addd    $02,u                    ; to next array and save address of                                             
CA3A 3406             (    rsdos_mmc.asm):01892                        pshs    b,a                      ; next array on the stack                                 
CA3C A641             (    rsdos_mmc.asm):01893                        lda     $01,u                    ; get 2nd letter of variable name                                          
CA3E 2AEF             (    rsdos_mmc.asm):01894                        bpl     lcb52                    ; branch if numeric                            
CA40 E644             (    rsdos_mmc.asm):01895                        ldb     $04,u                    ; get the number of dimensions                                       
CA42 58               (    rsdos_mmc.asm):01896                        aslb                             ; x2:2 bytes per dimension                               
CA43 CB05             (    rsdos_mmc.asm):01897                        addb    #$05                     ; 5 bytes constant per array descriptor                                                
CA45 4F               (    rsdos_mmc.asm):01898                        clra                             ; clear msb of offset - (only 125 dimensions allowed)                                                          
CA46 33CB             (    rsdos_mmc.asm):01899                        leau    d,u                      ; point u to start of this array's variables                                                    
CA48 11A3E4           (    rsdos_mmc.asm):01900         lcb6b          cmpu    ,s                       ; at end of this array?                                   
CA4B 27E2             (    rsdos_mmc.asm):01901                        beq     lcb52                    ; yes              
                      (    rsdos_mmc.asm):01902         
CA4D 8D04             (    rsdos_mmc.asm):01903                        bsr     lcb76                    ; adjust string variable if in random file buffer                                                          
                      (    rsdos_mmc.asm):01904         
CA4F 3345             (    rsdos_mmc.asm):01905                        leau    $05,u                    ; move pointer to next descriptor                                           
CA51 20F5             (    rsdos_mmc.asm):01906                        bra     lcb6b                    ; check next variable                              
                      (    rsdos_mmc.asm):01907         ;
                      (    rsdos_mmc.asm):01908         ; check to see if a string is located in the random file buffer area. if it is
                      (    rsdos_mmc.asm):01909         ; the random file buffer in question, it will be deleted. if it is higher in the random
                      (    rsdos_mmc.asm):01910         ; file buffer space than the buffer in question, the length of the current
                      (    rsdos_mmc.asm):01911         ; buffer will be subtracted from the address of the string because the current
                      (    rsdos_mmc.asm):01912         ; buffer is being deleted (closed).
CA53 AE42             (    rsdos_mmc.asm):01913         lcb76          ldx     $02,u                    ; point x to start of string                                          
CA55 BC0948           (    rsdos_mmc.asm):01914                        cmpx    rnbfad                   ; compare to start of free random file buffer area                                                             
CA58 240E             (    rsdos_mmc.asm):01915                        bhs     lcb8b                    ; return if > start of free random file buffer area                                                            
                      (    rsdos_mmc.asm):01916         
CA5A AC22             (    rsdos_mmc.asm):01917                        cmpx    $02,y                    ; compare to start of this file's random buffer                                                         
CA5C 250A             (    rsdos_mmc.asm):01918                        blo     lcb8b                    ; return if < start of this file's random buffer                                                         
                      (    rsdos_mmc.asm):01919         
CA5E AC24             (    rsdos_mmc.asm):01920                        cmpx    $04,y                    ; compare to end of this file's random buffer                                                       
CA60 2507             (    rsdos_mmc.asm):01921                        blo     lcb8c                    ; return if < end of this file's random buffer                                                       
                      (    rsdos_mmc.asm):01922         
CA62 1F10             (    rsdos_mmc.asm):01923                        tfr     x,d                      ; save pointer in accd                             
CA64 A3A4             (    rsdos_mmc.asm):01924                        subd    ,y                       ; subtract record length from start of string address                                                            
CA66 ED42             (    rsdos_mmc.asm):01925                        std     $02,u                    ; save new start of string address                                           
CA68 39               (    rsdos_mmc.asm):01926         lcb8b          rts                                          
                      (    rsdos_mmc.asm):01927         
CA69 6FC4             (    rsdos_mmc.asm):01928         lcb8c          clr     ,u                       ; clear the length of the string                                           
CA6B 6F42             (    rsdos_mmc.asm):01929                        clr     $02,u                    ; clear the address                            
CA6D 6F43             (    rsdos_mmc.asm):01930                        clr     $03,u                    ; of the string                        
CA6F 39               (    rsdos_mmc.asm):01931                        rts                                     
                      (    rsdos_mmc.asm):01932         
                      (    rsdos_mmc.asm):01933         ; remove reserved space in random file buffer for a 'closed' random file
                      (    rsdos_mmc.asm):01934         ; adjust the start of random file buffer pointer in all random fcbs
CA70 F6095B           (    rsdos_mmc.asm):01935         lcb93          ldb     fcbact                   ; get the number of active files                                               
CA73 5C               (    rsdos_mmc.asm):01936                        incb                             ; add one              
CA74 3404             (    rsdos_mmc.asm):01937         lcb97          pshs    b                        ; save files count on the stack                                          
CA76 BDC626           (    rsdos_mmc.asm):01938                        jsr     >lc749                   ; point x to fcb                         
                      (    rsdos_mmc.asm):01939         
CA79 A684             (    rsdos_mmc.asm):01940                        lda     fcbtyp,x                 ; get file type                           
CA7B 8140             (    rsdos_mmc.asm):01941                        cmpa    #ranfil                  ; is it a random file?                                  
CA7D 260B             (    rsdos_mmc.asm):01942                        bne     lcbad                    ; branch if not                        
                      (    rsdos_mmc.asm):01943         
CA7F EC0B             (    rsdos_mmc.asm):01944                        ldd     fcbbuf,x                 ; get start of this file's random file buffer                                                         
CA81 10A324           (    rsdos_mmc.asm):01945                        cmpd    $04,y                    ; compare to end of random file buffer area and                                                         
CA84 2504             (    rsdos_mmc.asm):01946                        blo     lcbad                    ; branch if < end of random file buffer area                                                     
                      (    rsdos_mmc.asm):01947         
CA86 A3A4             (    rsdos_mmc.asm):01948                        subd    ,y                       ; = subtract record length of selected file                                                  
CA88 ED0B             (    rsdos_mmc.asm):01949                        std     fcbbuf,x                 ; = save new start of random file buffer                                                    
CA8A 3504             (    rsdos_mmc.asm):01950         lcbad          puls    b                        ; get the files counter                                  
CA8C 5A               (    rsdos_mmc.asm):01951                        decb                             ; decrement files counter                              
CA8D 26E5             (    rsdos_mmc.asm):01952                        bne     lcb97                    ; branch if all files not done                                       
                      (    rsdos_mmc.asm):01953         
CA8F 3556             (    rsdos_mmc.asm):01954                        puls    a,b,x,u                  ; u = end of random file buffer, x = start of random                                                                
                      (    rsdos_mmc.asm):01955         ; file buffer, accd = record length
                      (    rsdos_mmc.asm):01956         
                      (    rsdos_mmc.asm):01957         ; this would probably be the most convenient place to fix the bug which
                      (    rsdos_mmc.asm):01958         ; causes the system to hang if an error is encountered during 'copy'
                      (    rsdos_mmc.asm):01959         
                      (    rsdos_mmc.asm):01960         ;        cmpu fcbadr                               ; is the end of this fcb's buffer above the end
                      (    rsdos_mmc.asm):01961         ;                                                  ; of the start of the fcb area
                      (    rsdos_mmc.asm):01962         ;        blo     lcbb4                             no - free up the space used by this file in random buffer
                      (    rsdos_mmc.asm):01963         ;        ldx     #dflbuf                           yes - doing a 'copy'; reset start of random buffer
                      (    rsdos_mmc.asm):01964         ;        bra     lcbc0
                      (    rsdos_mmc.asm):01965         ; random file buffer area
                      (    rsdos_mmc.asm):01966         ; remove reserved space for closed file from random file buffer space
                      (    rsdos_mmc.asm):01967         
CA91 11B30948         (    rsdos_mmc.asm):01968         lcbb4          cmpu    rnbfad                   ; at the bottom of free random buffer area?                                                           
CA95 2706             (    rsdos_mmc.asm):01969                        beq     lcbc0                    ; branch if there                          
                      (    rsdos_mmc.asm):01970         
CA97 A6C0             (    rsdos_mmc.asm):01971                        lda     ,u+                      ; = grab a source byte and                                 
CA99 A780             (    rsdos_mmc.asm):01972                        sta     ,x+                      ; = move it to destination                                 
CA9B 20F4             (    rsdos_mmc.asm):01973                        bra     lcbb4                    ; keep moving bytes                            
CA9D BF0948           (    rsdos_mmc.asm):01974         lcbc0          stx     rnbfad                   ; save new start of free random buffer area                                                          
CAA0 BDC632           (    rsdos_mmc.asm):01975         lcbc3          jsr     >lc755                   ; point x to proper file allocation table                                                       
                      (    rsdos_mmc.asm):01976         
CAA3 6A84             (    rsdos_mmc.asm):01977                        dec     fat0,x                   ; remove one active file                                  
CAA5 6D01             (    rsdos_mmc.asm):01978                        tst     fat1,x                   ; new data in fat ram image?                                      
CAA7 2703             (    rsdos_mmc.asm):01979                        beq     lcbcf                    ; no             
                      (    rsdos_mmc.asm):01980         
CAA9 BDC5FB           (    rsdos_mmc.asm):01981                        jsr     >lc71e                   ; write out file allocation table to disk                                                  
                      (    rsdos_mmc.asm):01982         
CAAC 9EF1             (    rsdos_mmc.asm):01983         lcbcf          ldx     fcbtmp                   ; get file buffer pointer                                        
CAAE 3502             (    rsdos_mmc.asm):01984                        puls    a                        ; get file type                     
CAB0 8120             (    rsdos_mmc.asm):01985                        cmpa    #outfil                  ; is it a sequential output file?                                             
CAB2 2708             (    rsdos_mmc.asm):01986                        beq     lcbdf                    ; yes              
                      (    rsdos_mmc.asm):01987         
CAB4 8140             (    rsdos_mmc.asm):01988                        cmpa    #ranfil                  ; is it a random file?                                  
CAB6 26B0             (    rsdos_mmc.asm):01989                        bne     lcb8b                    ; return if not a random file (sequential input)                                                         
                      (    rsdos_mmc.asm):01990         
CAB8 A60F             (    rsdos_mmc.asm):01991                        lda     fcbflg,x                 ; test the get/put flag and                                       
CABA 270A             (    rsdos_mmc.asm):01992                        beq     lcbe9                    ; branch if 'get'                          
                      (    rsdos_mmc.asm):01993         
                      (    rsdos_mmc.asm):01994         
                      (    rsdos_mmc.asm):01995         ; write contents of file buffer to disk
CABC BDC640           (    rsdos_mmc.asm):01996         lcbdf          jsr     >lc763                   ; get proper track & sector numbers                                                 
                      (    rsdos_mmc.asm):01997         
CABF 338819           (    rsdos_mmc.asm):01998                        leau    fcbcon,x                 ; point u to start of fcb data                                           
CAC2 DFEE             (    rsdos_mmc.asm):01999                        stu     dcbpt                    ; set up file buffer pointer for dskcon                                                
CAC4 8D2C             (    rsdos_mmc.asm):02000                        bsr     lcc15                    ; go write a sector                            
                      (    rsdos_mmc.asm):02001         
CAC6 A68813           (    rsdos_mmc.asm):02002         lcbe9          lda     fcblst,x                 ; check the pre-saved flag                                           
                      (    rsdos_mmc.asm):02003         
CAC9 2A9D             (    rsdos_mmc.asm):02004                        bpl     lcb8b                    ; return if record has already been saved on disk                                                          
CACB E68812           (    rsdos_mmc.asm):02005                        ldb     fcbdir,x                 ; get directory number of this file                                               
CACE C407             (    rsdos_mmc.asm):02006                        andb    #$07                     ; 8 entries per sector                               
CAD0 8620             (    rsdos_mmc.asm):02007                        lda     #dirlen                  ; dirlen bytes per directory entry                                             
CAD2 3D               (    rsdos_mmc.asm):02008                        mul                              ; get sector offset for this entry                                      
CAD3 CE0600           (    rsdos_mmc.asm):02009                        ldu     #dbuf0                   ; get read/write buffer 0 and                                       
CAD6 DFEE             (    rsdos_mmc.asm):02010                        stu     dcbpt                    ; save it in dskcon register                                     
CAD8 31CB             (    rsdos_mmc.asm):02011                        leay    d,u                      ; y points to correct directory entry                                             
CADA E68812           (    rsdos_mmc.asm):02012                        ldb     fcbdir,x                 ; get directory entry number                                        
CADD 54               (    rsdos_mmc.asm):02013                        lsrb                             ;      
CADE 54               (    rsdos_mmc.asm):02014                        lsrb                             ;      
CADF 54               (    rsdos_mmc.asm):02015                        lsrb                             ; divide by 8; eight directory entries per sector                                                      
CAE0 CB03             (    rsdos_mmc.asm):02016                        addb    #$03                     ; add bias; first 3 sectors not directory                                                  
CAE2 D7ED             (    rsdos_mmc.asm):02017                        stb     dsec                     ; store sector number                             
CAE4 CC1102           (    rsdos_mmc.asm):02018                        ldd     #$1102                   ; directory track - read op code                                          
CAE7 97EC             (    rsdos_mmc.asm):02019                        sta     dctrk                    ; store track number                             
CAE9 8D09             (    rsdos_mmc.asm):02020                        bsr     lcc17                    ; go read directory                            
                      (    rsdos_mmc.asm):02021         
CAEB EC8813           (    rsdos_mmc.asm):02022                        ldd     fcblst,x                 ; get number of bytes in the last sector                                                    
                      (    rsdos_mmc.asm):02023         
CAEE 847F             (    rsdos_mmc.asm):02024                        anda    #$7f                     ; mask off the pre-saved flag                                      
CAF0 ED2E             (    rsdos_mmc.asm):02025                        std     dirlst,y                 ; save number of bytes in last sector of file in directory                                                                       
CAF2 C603             (    rsdos_mmc.asm):02026         lcc15          ldb     #$03                     ; write op code                            
CAF4 D7EA             (    rsdos_mmc.asm):02027         lcc17          stb     dcopc                    ; save dskcon op code variable                                            
CAF6 7ED4B5           (    rsdos_mmc.asm):02028                        jmp     >DoDiskReadWrite                   ; go read/write sector                               
                      (    rsdos_mmc.asm):02029         
                      (    rsdos_mmc.asm):02030         
                      (    rsdos_mmc.asm):02031         ; console out ram hook
CAF9 0D6F             (    rsdos_mmc.asm):02032         DosHookCharOut tst     TextDevN                 ; check device number                                    
CAFB 102FB774         (    rsdos_mmc.asm):02033                        lble    CoCoVec167               ; branch to ex basic if not a disk file                                                 
CAFF 3262             (    rsdos_mmc.asm):02034                        leas    $02,s                    ; pop return off stack                                
                      (    rsdos_mmc.asm):02035         ; send a character in acca to a disk file. a carriage return will reset the
                      (    rsdos_mmc.asm):02036         ; print position and control codes will not increment the print position.
CB01 3416             (    rsdos_mmc.asm):02037         lcc24          pshs    x,b,a                    ; save registers                               
CB03 8E0926           (    rsdos_mmc.asm):02038                        ldx     #fcbv1-2                 ; point x to table of file number vectors                                                     
CB06 D66F             (    rsdos_mmc.asm):02039                        ldb     TextDevN                 ; get current file number                                   
CB08 58               (    rsdos_mmc.asm):02040                        aslb                             ; 2 bytes per fcb address                              
CB09 AE85             (    rsdos_mmc.asm):02041                        ldx     b,x                      ; point x to proper fcb                              
CB0B E684             (    rsdos_mmc.asm):02042                        ldb     fcbtyp,x                 ; get file type                           
CB0D C110             (    rsdos_mmc.asm):02043                        cmpb    #inpfil                  ; is it an input file?                                  
CB0F 2736             (    rsdos_mmc.asm):02044                        beq     lcc6a                    ; return if so                       
                      (    rsdos_mmc.asm):02045         
CB11 810D             (    rsdos_mmc.asm):02046                        cmpa    #cr                      ; carriage return (enter)                                 
CB13 2602             (    rsdos_mmc.asm):02047                        bne     lcc3a                    ; no             
                      (    rsdos_mmc.asm):02048         
CB15 6F06             (    rsdos_mmc.asm):02049                        clr     fcbpos,x                 ; clear print position if carriage return                                                     
CB17 8120             (    rsdos_mmc.asm):02050         lcc3a          cmpa    #space                   ;                 
CB19 2502             (    rsdos_mmc.asm):02051                        blo     lcc40                    ;branch if control char                                
                      (    rsdos_mmc.asm):02052         
CB1B 6C06             (    rsdos_mmc.asm):02053                        inc     fcbpos,x                 ; increment print position                                      
CB1D C140             (    rsdos_mmc.asm):02054         lcc40          cmpb    #ranfil                  ; is it random file?                                     
CB1F 261A             (    rsdos_mmc.asm):02055                        bne     lcc5e                    ; branch if not random                               
                      (    rsdos_mmc.asm):02056         
                      (    rsdos_mmc.asm):02057         ; put a byte into a random file
CB21 EC8817           (    rsdos_mmc.asm):02058                        ldd     fcbput,x                 ; get 'put' byte counter                                    
CB24 C30001           (    rsdos_mmc.asm):02059                        addd    #$0001                   ; add one                    
CB27 10A309           (    rsdos_mmc.asm):02060                        cmpd    fcbrln,x                 ; compare to record length                                       
CB2A 1022017A         (    rsdos_mmc.asm):02061                        lbhi    lcdcb                    ; 'fr' error if 'put' byte counter > record length                                                            
CB2E ED8817           (    rsdos_mmc.asm):02062                        std     fcbput,x                 ; save new 'put' byte counter                                         
CB31 AE0B             (    rsdos_mmc.asm):02063                        ldx     fcbbuf,x                 ; point to random file buffer pointer                                                 
CB33 308B             (    rsdos_mmc.asm):02064                        leax    d,x                      ; point to one past end of current record data                                                      
CB35 3502             (    rsdos_mmc.asm):02065                        puls    a                        ; pull data from stack                            
CB37 A71F             (    rsdos_mmc.asm):02066                        sta     -1,x                     ; store in data buffer                              
CB39 3594             (    rsdos_mmc.asm):02067                        puls    b,x,pc                   ; restore registers and return                                         
                      (    rsdos_mmc.asm):02068         
                      (    rsdos_mmc.asm):02069         ; write a byte to sequential output file
CB3B 6C8818           (    rsdos_mmc.asm):02070         lcc5e          inc     fcblft,x                 ; increment character count                                            
CB3E E68818           (    rsdos_mmc.asm):02071                        ldb     fcblft,x                 ; get character count and branch                                            
CB41 2706             (    rsdos_mmc.asm):02072                        beq     lcc6c                    ; if the buffer is full                                
                      (    rsdos_mmc.asm):02073         
CB43 3A               (    rsdos_mmc.asm):02074                        abx                              ; add character count to fcb address                                        
CB44 A78818           (    rsdos_mmc.asm):02075                        sta     fcbcon-1,x               ; store new character (skip past 25 control bytes at fcb start)                                                                             
CB47 3596             (    rsdos_mmc.asm):02076         lcc6a          puls    a,b,x,pc                                      
                      (    rsdos_mmc.asm):02077         
                      (    rsdos_mmc.asm):02078         ; write out a full buffer and reset buffer
CB49 3460             (    rsdos_mmc.asm):02079         lcc6c          pshs    u,y                      ; save registers                             
CB4B A7890118         (    rsdos_mmc.asm):02080                        sta     seclen+fcbcon-1,x        ; store last character in buffer                                                     
CB4F E601             (    rsdos_mmc.asm):02081                        ldb     fcbdrv,x                 ; get drive number and save                                       
CB51 D7EB             (    rsdos_mmc.asm):02082                        stb     dcdrv                    ; it in dskcon control table                                     
CB53 6C04             (    rsdos_mmc.asm):02083                        inc     fcbsec,x                 ; increment sector number                                     
CB55 BDCABC           (    rsdos_mmc.asm):02084                        jsr     >lcbdf                   ; write the file buffer to disk                                        
                      (    rsdos_mmc.asm):02085         
CB58 3184             (    rsdos_mmc.asm):02086                        leay    ,x                       ; save fcb pointer in y                              
CB5A E603             (    rsdos_mmc.asm):02087                        ldb     fcbcgr,x                 ; get granule number                                
CB5C BDC632           (    rsdos_mmc.asm):02088                        jsr     >lc755                   ; point x to proper allocation table                                             
                      (    rsdos_mmc.asm):02089         
CB5F 3A               (    rsdos_mmc.asm):02090                        abx                              ; add the granule number to fat pointer                                           
CB60 3306             (    rsdos_mmc.asm):02091                        leau    fatcon,x                 ; point u to the correct granule in fat - skip past                                                                
                      (    rsdos_mmc.asm):02092         ; the six fat control bytes
CB62 A624             (    rsdos_mmc.asm):02093                        lda     fcbsec,y                 ; get current sector for this granule                                                 
CB64 8109             (    rsdos_mmc.asm):02094                        cmpa    #$09                     ; max sector number (9 sectors/granule)                                                
CB66 250E             (    rsdos_mmc.asm):02095                        blo     lcc99                    ; branch if not at end of granule                                          
                      (    rsdos_mmc.asm):02096         
CB68 6A24             (    rsdos_mmc.asm):02097                        dec     fcbsec,y                 ; decrement sector number and increment error flag in                                                                
CB6A 6C25             (    rsdos_mmc.asm):02098                        inc     fcbcpt,y                 ; case error found while looking for next granule -                                                              
                      (    rsdos_mmc.asm):02099                                                         ; the error flag is used to indicate that another sector
                      (    rsdos_mmc.asm):02100                                                         ; must be added to the length of file following error processing.
CB6C BDC69C           (    rsdos_mmc.asm):02101                        jsr     >lc7bf                   ; get next free granule                                
                      (    rsdos_mmc.asm):02102         
CB6F 6F24             (    rsdos_mmc.asm):02103                        clr     fcbsec,y                 ;clear sector number and                                    
CB71 6F25             (    rsdos_mmc.asm):02104                        clr     fcbcpt,y                 ;error flag - disk was not full                                           
CB73 A723             (    rsdos_mmc.asm):02105                        sta     fcbcgr,y                 ; save new granule in fcb                                     
CB75 8C               (    rsdos_mmc.asm):02106                        fcb      Skip2                   ; cmpx
CB76 8AC0             (    rsdos_mmc.asm):02107         lcc99          ora     #$c0                     ; force granule number to be final granule in file                                                               
CB78 A7C4             (    rsdos_mmc.asm):02108                        sta     ,u                       ; store in map                    
CB7A 30A4             (    rsdos_mmc.asm):02109                        leax    ,y                       ; point x to fcb                       
CB7C BDC562           (    rsdos_mmc.asm):02110                        jsr     >lc685                   ; increment record number                                  
                      (    rsdos_mmc.asm):02111         
CB7F BDC486           (    rsdos_mmc.asm):02112                        jsr     >lc5a9                   ; update file allocation table                                       
                      (    rsdos_mmc.asm):02113         
CB82 3560             (    rsdos_mmc.asm):02114                        puls    y,u                      ; restore registers                           
CB84 3596             (    rsdos_mmc.asm):02115                        puls    a,b,x,pc                 ; restore registers and return                                           
                      (    rsdos_mmc.asm):02116         
                      (    rsdos_mmc.asm):02117         ; dir command
CB86 BDD12C           (    rsdos_mmc.asm):02118         CmdDir         jsr     >GetDriveNoInB           ; scan drive number from input line                                               
CB89 BDC67A           (    rsdos_mmc.asm):02119                        jsr     >GetFAT                  ; get fat for this drive                                 
CB8C BDB958           (    rsdos_mmc.asm):02120                        jsr     TextOutCRLF              ; print carriage return to console out                                               
                      (    rsdos_mmc.asm):02121         
CB8F CC1102           (    rsdos_mmc.asm):02122                        ldd     #$1102                   ; get track 17 and                            
CB92 97EC             (    rsdos_mmc.asm):02123                        sta     dctrk                    ; read op code and                           
CB94 D7EA             (    rsdos_mmc.asm):02124                        stb     dcopc                    ; save in dskcon variables                                   
CB96 C603             (    rsdos_mmc.asm):02125                        ldb     #$03                     ; start with sector 3 (first directory sector)                                                      
                      (    rsdos_mmc.asm):02126         
                      (    rsdos_mmc.asm):02127         ; read a directory sector into the i/o buffer
CB98 D7ED             (    rsdos_mmc.asm):02128         lccbb          stb     dsec                     ; save sector number in dskcon variable                                                    
CB9A 8E0600           (    rsdos_mmc.asm):02129                        ldx     #dbuf0                   ; use i/o buffer 0 for data transfer                                              
CB9D 9FEE             (    rsdos_mmc.asm):02130                        stx     dcbpt                    ; save in dskcon variable                                  
CB9F BDD4B5           (    rsdos_mmc.asm):02131                        jsr     >DoDiskReadWrite                   ; read a sector                        
                      (    rsdos_mmc.asm):02132         
                      (    rsdos_mmc.asm):02133         
                      (    rsdos_mmc.asm):02134         ; send directory information to console out
CBA2 3540             (    rsdos_mmc.asm):02135         lccc5          puls    u                        ; save top of stack                              
CBA4 BDA549           (    rsdos_mmc.asm):02136                        jsr     la549                    ; go do a break check                              
                      (    rsdos_mmc.asm):02137         
CBA7 3440             (    rsdos_mmc.asm):02138                        pshs    u                        ; restore stack                     
CBA9 A684             (    rsdos_mmc.asm):02139                        lda     dirnam,x                 ; test file name first byte                                       
CBAB 2738             (    rsdos_mmc.asm):02140                        beq     lcd08                    ; branch if killed                           
                      (    rsdos_mmc.asm):02141         
CBAD 43               (    rsdos_mmc.asm):02142                        coma                             ; ff = end of directory                            
CBAE 2744             (    rsdos_mmc.asm):02143                        beq     lcd17                    ; return if end of directory                                     
                      (    rsdos_mmc.asm):02144         
CBB0 3410             (    rsdos_mmc.asm):02145                        pshs    x                        ; save directory pointer on stack                                       
CBB2 C608             (    rsdos_mmc.asm):02146                        ldb     #$08                     ; number characters to print                                    
CBB4 BDB9A2           (    rsdos_mmc.asm):02147                        jsr     lb9a2                    ; send filename to console out                                       
                      (    rsdos_mmc.asm):02148         
CBB7 8D3F             (    rsdos_mmc.asm):02149                        bsr     lcd1b                    ; send blank to console out                                    
                      (    rsdos_mmc.asm):02150         
CBB9 C603             (    rsdos_mmc.asm):02151                        ldb     #$03                     ; number characters to print                                    
CBBB BDB9A2           (    rsdos_mmc.asm):02152                        jsr     lb9a2                    ; send extension to console out                                        
                      (    rsdos_mmc.asm):02153         
CBBE 8D38             (    rsdos_mmc.asm):02154                        bsr     lcd1b                    ; send blank to console out                                    
                      (    rsdos_mmc.asm):02155         
CBC0 E684             (    rsdos_mmc.asm):02156                        ldb     fcbtyp,x                 ; get file type                           
CBC2 C10A             (    rsdos_mmc.asm):02157                        cmpb    #10                      ; check the number of decimal digits in                                               
CBC4 2402             (    rsdos_mmc.asm):02158                        bhs     lcceb                    ; accb: if there is only one digit,                                            
                      (    rsdos_mmc.asm):02159         
CBC6 8D30             (    rsdos_mmc.asm):02160                        bsr     lcd1b                    ; send blank to console out                                    
                      (    rsdos_mmc.asm):02161         
CBC8 4F               (    rsdos_mmc.asm):02162         lcceb          clra                             ; clear ms byte of acco                                 
CBC9 BDBDCC           (    rsdos_mmc.asm):02163                        jsr     TextOutNum16             ; print accd in decimal to console out                                               
                      (    rsdos_mmc.asm):02164         
CBCC 8D2A             (    rsdos_mmc.asm):02165                        bsr     lcd1b                    ; send blank to console out                                    
                      (    rsdos_mmc.asm):02166         
CBCE AEE4             (    rsdos_mmc.asm):02167                        ldx     ,s                       ; x now points to directory entry                                       
CBD0 8642             (    rsdos_mmc.asm):02168                        lda     #'B                      ; ascii bias                      
CBD2 AB0C             (    rsdos_mmc.asm):02169                        adda    dirasc,x                 ; add to ascii flag                                
CBD4 8D1F             (    rsdos_mmc.asm):02170                        bsr     lcd18                    ; print character and blank to console out                                                   
                      (    rsdos_mmc.asm):02171         
CBD6 E60D             (    rsdos_mmc.asm):02172                        ldb     dirgrn,x                 ; get first granule in file                                       
CBD8 8D21             (    rsdos_mmc.asm):02173                        bsr     lcd1e                    ; count granules                         
                      (    rsdos_mmc.asm):02174         
CBDA 1F89             (    rsdos_mmc.asm):02175                        tfr     a,b                      ; save count in accb                           
CBDC 4F               (    rsdos_mmc.asm):02176                        clra                             ; clear ms byte of accd                            
CBDD BDBDCC           (    rsdos_mmc.asm):02177                        jsr     TextOutNum16             ; print acco in decimal to console out                                               
                      (    rsdos_mmc.asm):02178         
CBE0 BDB958           (    rsdos_mmc.asm):02179                        jsr     TextOutCRLF              ; send carriage return to console out                                              
                      (    rsdos_mmc.asm):02180         
CBE3 3510             (    rsdos_mmc.asm):02181                        puls    x                        ; pull directory pointer off of the stack                                               
CBE5 308820           (    rsdos_mmc.asm):02182         lcd08          leax    dirlen,x                 ; move x to next directory entry                                                  
CBE8 8C0700           (    rsdos_mmc.asm):02183                        cmpx    #dbuf0+seclen            ; end of i/o buffer?                                      
CBEB 25B5             (    rsdos_mmc.asm):02184                        blo     lccc5                    ; branch if more directory entries in buffer                                                     
                      (    rsdos_mmc.asm):02185         
CBED D6ED             (    rsdos_mmc.asm):02186                        ldb     dsec                     ; get current sector                            
CBEF 5C               (    rsdos_mmc.asm):02187                        incb                             ; bump count                 
CBF0 C112             (    rsdos_mmc.asm):02188                        cmpb    #secmax                  ; secmax sectors in directory track                                               
CBF2 23A4             (    rsdos_mmc.asm):02189                        bls     lccbb                    ; get next sector                          
                      (    rsdos_mmc.asm):02190         
CBF4 39               (    rsdos_mmc.asm):02191         lcd17          rts                              ; finished                   
                      (    rsdos_mmc.asm):02192         
CBF5 BDA282           (    rsdos_mmc.asm):02193         lcd18          jsr     TextOutChar              ; send character to console out                                             
                      (    rsdos_mmc.asm):02194         
CBF8 7EB9AC           (    rsdos_mmc.asm):02195         lcd1b          jmp     TextOutSpace             ; send blank to console out                                         
                      (    rsdos_mmc.asm):02196         
                      (    rsdos_mmc.asm):02197         
                      (    rsdos_mmc.asm):02198         ; enter with accb pointing to first granule in a file; return the number of
                      (    rsdos_mmc.asm):02199         ; granules in the file in acca, the granule data for the last sector in accb
CBFB BDC632           (    rsdos_mmc.asm):02200         lcd1e          jsr     >lc755                   ; point x to file allocation buffer                                                 
                      (    rsdos_mmc.asm):02201         
CBFE 3306             (    rsdos_mmc.asm):02202                        leau    fatcon,x                 ; point u to start of granule data                                               
CC00 4F               (    rsdos_mmc.asm):02203                        clra                             ; reset granule counter                            
CC01 4C               (    rsdos_mmc.asm):02204         lcd24          inca                             ; increment granule counter                                     
CC02 8144             (    rsdos_mmc.asm):02205                        cmpa    #granmx                  ; checked all 68 granules?                                      
CC04 1022F928         (    rsdos_mmc.asm):02206                        lbhi    lc653                    ; yes - 'bad file structure' error                                            
CC08 30C4             (    rsdos_mmc.asm):02207                        leax    ,u                       ; point u to start of granule data                                         
CC0A 3A               (    rsdos_mmc.asm):02208                        abx                              ; add pointer to first granule                                  
CC0B E684             (    rsdos_mmc.asm):02209                        ldb     ,x                       ; get this granule's control byte                                       
CC0D C1C0             (    rsdos_mmc.asm):02210                        cmpb    #$c0                     ; is this the last granule in file?                                            
CC0F 25F0             (    rsdos_mmc.asm):02211                        blo     lcd24                    ; no - keep going                          
                      (    rsdos_mmc.asm):02212         
CC11 39               (    rsdos_mmc.asm):02213                        rts                                     
                      (    rsdos_mmc.asm):02214         
                      (    rsdos_mmc.asm):02215         
                      (    rsdos_mmc.asm):02216         ; input ram hook
CC12 0D6F             (    rsdos_mmc.asm):02217         DosHookInput         tst     TextDevN                 ; check device number and return                                                
CC14 2F5E             (    rsdos_mmc.asm):02218                        ble     lcd97                    ; if not a disk file                             
CC16 8EB069           (    rsdos_mmc.asm):02219                        ldx     #lb069                   ; = change the return address on the stack to re-enter basic's input                                                                              
CC19 AFE4             (    rsdos_mmc.asm):02220                        stx     ,s                       ; = routine at a different place than the calling routine                                                               
CC1B 8E02DD           (    rsdos_mmc.asm):02221                        ldx     #BasLinInpBuff+1         ; point x to the line input buffer                                               
CC1E C62C             (    rsdos_mmc.asm):02222                        ldb     #',                      ; =           
CC20 D701             (    rsdos_mmc.asm):02223                        stb     BasDelim1                ; =comma is read item separator (temporary string search flag)                                                                        
CC22 9606             (    rsdos_mmc.asm):02224                        lda     BasVarType               ; get variable type and branch if                                           
CC24 2602             (    rsdos_mmc.asm):02225                        bne     lcd4b                    ; it is a string                         
                      (    rsdos_mmc.asm):02226         
CC26 C620             (    rsdos_mmc.asm):02227                        ldb     #space                   ; space = numeric search delimiter                                            
CC28 8D6F             (    rsdos_mmc.asm):02228         lcd4b          bsr     lcdbc                    ; get an input character                                      
                      (    rsdos_mmc.asm):02229         
CC2A 8120             (    rsdos_mmc.asm):02230                        cmpa    #space                   ; space?                   
CC2C 27FA             (    rsdos_mmc.asm):02231                        beq     lcd4b                    ; yes - get another character                                      
                      (    rsdos_mmc.asm):02232         
CC2E 8122             (    rsdos_mmc.asm):02233                        cmpa    #'"                      ; quote?                 
CC30 260A             (    rsdos_mmc.asm):02234                        bne     lcd5f                    ; no             
                      (    rsdos_mmc.asm):02235         
CC32 C12C             (    rsdos_mmc.asm):02236                        cmpb    #',                      ; search character = comma?                                    
CC34 2606             (    rsdos_mmc.asm):02237                        bne     lcd5f                    ; no - numeric search                              
                      (    rsdos_mmc.asm):02238         
CC36 1F89             (    rsdos_mmc.asm):02239                        tfr     a,b                      ; save double quote as                             
CC38 D701             (    rsdos_mmc.asm):02240                        stb     BasDelim1                ; the search flag                           
CC3A 2022             (    rsdos_mmc.asm):02241                        bra     lcd81                    ; save double quotes as first item in buffer                                                     
                      (    rsdos_mmc.asm):02242         
CC3C C122             (    rsdos_mmc.asm):02243         lcd5f          cmpb    #'"                      ;               
CC3E 2711             (    rsdos_mmc.asm):02244                        beq     lcd74                    ;branch if inputting a string variable                                               
                      (    rsdos_mmc.asm):02245         
CC40 810D             (    rsdos_mmc.asm):02246                        cmpa    #cr                      ; is the input character a carriage return                                                  
CC42 260D             (    rsdos_mmc.asm):02247                        bne     lcd74                    ; no             
                      (    rsdos_mmc.asm):02248         
CC44 8C02DD           (    rsdos_mmc.asm):02249                        cmpx    #BasLinInpBuff+1         ;if at the start of inputbuffer, check for a                                                          
CC47 2744             (    rsdos_mmc.asm):02250                        beq     lcdb0                    ;following line feed and exit routine                                              
                      (    rsdos_mmc.asm):02251         
CC49 A61F             (    rsdos_mmc.asm):02252                        lda     -1,x                     ; =if the input character preceeding the cr was a line feed,                                                                    
CC4B 810A             (    rsdos_mmc.asm):02253                        cmpa    #lf                      ; =then insert the cr in the input string, otherwise                                                            
CC4D 263E             (    rsdos_mmc.asm):02254                        bne     lcdb0                    ; =check for a following line feed and exit the routine                                                                
                      (    rsdos_mmc.asm):02255         
CC4F 860D             (    rsdos_mmc.asm):02256                        lda     #cr                      ; restore carriage return as the input character                                                       
CC51 4D               (    rsdos_mmc.asm):02257         lcd74          tsta                             ;check for a null (zero) input character and                                                      
CC52 2717             (    rsdos_mmc.asm):02258                        beq     lcd8e                    ;ignore it if lt is a null                                   
                      (    rsdos_mmc.asm):02259         
CC54 9101             (    rsdos_mmc.asm):02260                        cmpa    BasDelim1                ; =              
CC56 271D             (    rsdos_mmc.asm):02261                        beq     lcd98                    ; =check to see if the input character matches                                                       
                      (    rsdos_mmc.asm):02262         
CC58 3404             (    rsdos_mmc.asm):02263                        pshs    b                        ; =either accb or charac and if it does, then                                                   
CC5A A1E0             (    rsdos_mmc.asm):02264                        cmpa    ,s+                      ; =branch to check for item separator or                                                
CC5C 2717             (    rsdos_mmc.asm):02265                        beq     lcd98                    ; =terminator sequence and exit routine                                                
                      (    rsdos_mmc.asm):02266         
CC5E A780             (    rsdos_mmc.asm):02267         lcd81          sta     ,x+                      ; store new character in buffer                                           
CC60 8C03D6           (    rsdos_mmc.asm):02268                        cmpx    #BasLinInpBuff+lbufmx    ; end of input buffer                                        
CC63 2606             (    rsdos_mmc.asm):02269                        bne     lcd8e                    ; no             
                      (    rsdos_mmc.asm):02270         
CC65 8D46             (    rsdos_mmc.asm):02271                        bsr     lcdd0                    ; get a character from console in                                          
                      (    rsdos_mmc.asm):02272         
CC67 2606             (    rsdos_mmc.asm):02273                        bne     lcd92                    ; exit routine if buffer empty                                       
                      (    rsdos_mmc.asm):02274         
CC69 201E             (    rsdos_mmc.asm):02275                        bra     lcdac                    ; check for cr or cr/lf and exit routine                                                 
                      (    rsdos_mmc.asm):02276         
CC6B 8D40             (    rsdos_mmc.asm):02277         lcd8e          bsr     lcdd0                    ; get a character from console in                                               
                      (    rsdos_mmc.asm):02278         
CC6D 27CD             (    rsdos_mmc.asm):02279                        beq     lcd5f                    ; branch if buffer not empty                                     
                      (    rsdos_mmc.asm):02280         
CC6F 6F84             (    rsdos_mmc.asm):02281         lcd92          clr     ,x                       ; put a zero at end of buffer when done                                                  
CC71 8E02DC           (    rsdos_mmc.asm):02282                        ldx     #BasLinInpBuff           ; point (x) to linbuf - reset pointer                                                
CC74 39               (    rsdos_mmc.asm):02283         lcd97          rts                                          
                      (    rsdos_mmc.asm):02284         
                      (    rsdos_mmc.asm):02285         
                      (    rsdos_mmc.asm):02286         ; check for item separator or terminator and exit the input routine
CC75 8122             (    rsdos_mmc.asm):02287         lcd98          cmpa    #'"                      ; quote?                      
CC77 2704             (    rsdos_mmc.asm):02288                        beq     lcda0                    ; yes              
                      (    rsdos_mmc.asm):02289         
CC79 8120             (    rsdos_mmc.asm):02290                        cmpa    #space                   ; space?                   
CC7B 26F2             (    rsdos_mmc.asm):02291                        bne     lcd92                    ; no - exit routine                            
                      (    rsdos_mmc.asm):02292         
CC7D 8D2E             (    rsdos_mmc.asm):02293         lcda0          bsr     lcdd0                    ; get a character from console in                                          
                      (    rsdos_mmc.asm):02294         
CC7F 26EE             (    rsdos_mmc.asm):02295                        bne     lcd92                    ; exit routine if buffer empty                                       
                      (    rsdos_mmc.asm):02296         
CC81 8120             (    rsdos_mmc.asm):02297                        cmpa    #space                   ; space?                   
CC83 27F8             (    rsdos_mmc.asm):02298                        beq     lcda0                    ; yes - get another character                                      
                      (    rsdos_mmc.asm):02299         
CC85 812C             (    rsdos_mmc.asm):02300                        cmpa    #',                      ; comma (item separator)?                                  
CC87 27E6             (    rsdos_mmc.asm):02301                        beq     lcd92                    ; yes - exit routine                             
                      (    rsdos_mmc.asm):02302         
CC89 810D             (    rsdos_mmc.asm):02303         lcdac          cmpa    #cr                      ; carriage return?                               
CC8B 2608             (    rsdos_mmc.asm):02304                        bne     lcdb8                    ; no             
                      (    rsdos_mmc.asm):02305         
CC8D 8D1E             (    rsdos_mmc.asm):02306         lcdb0          bsr     lcdd0                    ; get a character from console in                                          
                      (    rsdos_mmc.asm):02307         
CC8F 26DE             (    rsdos_mmc.asm):02308                        bne     lcd92                    ; exit routine if buffer empty                                       
                      (    rsdos_mmc.asm):02309         
CC91 810A             (    rsdos_mmc.asm):02310                        cmpa    #lf                      ; line feed? treat cr,lf as a cr                                        
CC93 27DA             (    rsdos_mmc.asm):02311                        beq     lcd92                    ; yes - exit routine                             
                      (    rsdos_mmc.asm):02312         
CC95 8D1C             (    rsdos_mmc.asm):02313         lcdb8          bsr     lcdd6                    ; back up ptr input pointer one                                             
                      (    rsdos_mmc.asm):02314         
CC97 20D6             (    rsdos_mmc.asm):02315                        bra     lcd92                    ; exit routine                       
                      (    rsdos_mmc.asm):02316         
CC99 8D12             (    rsdos_mmc.asm):02317         lcdbc          bsr     lcdd0                    ; get a char from input buffer - return in acca                                                             
                      (    rsdos_mmc.asm):02318         
CC9B 2715             (    rsdos_mmc.asm):02319                        beq     lcdd5                    ; return if buffer not empty                                     
                      (    rsdos_mmc.asm):02320         
CC9D BDC621           (    rsdos_mmc.asm):02321                        jsr     >lc744                   ; point x to start of file buffer                                          
                      (    rsdos_mmc.asm):02322         
CCA0 E684             (    rsdos_mmc.asm):02323                        ldb     fcbtyp,x                 ; get file type                           
CCA2 C140             (    rsdos_mmc.asm):02324                        cmpb    #ranfil                  ; is it random file type?                                     
CCA4 1026F587         (    rsdos_mmc.asm):02325                        lbne    lc352                    ; 'input past end of file' error if not random                                                        
                      (    rsdos_mmc.asm):02326         
CCA8 C64A             (    rsdos_mmc.asm):02327         lcdcb          ldb     #2*37                    ; 'write/input past end of record' error if random                                                                                            
CCAA 7EAC46           (    rsdos_mmc.asm):02328                        jmp     SysErr                   ; jump to the error handler                                    
                      (    rsdos_mmc.asm):02329         
                      (    rsdos_mmc.asm):02330         
CCAD BDA176           (    rsdos_mmc.asm):02331         lcdd0          jsr     la176                    ; get a char from input buffer                                            
                      (    rsdos_mmc.asm):02332         
CCB0 0D70             (    rsdos_mmc.asm):02333                        tst     cinbfl                   ; set flags according to console input flag                                                     
CCB2 39               (    rsdos_mmc.asm):02334         lcdd5          rts                                          
                      (    rsdos_mmc.asm):02335         
                      (    rsdos_mmc.asm):02336         
                      (    rsdos_mmc.asm):02337         ; move the input pointer back one (disk file)
CCB3 3414             (    rsdos_mmc.asm):02338         lcdd6          pshs    x,b                      ; save registers on stack                                      
CCB5 BDC621           (    rsdos_mmc.asm):02339                        jsr     >lc744                   ; point x to proper fcb                                
                      (    rsdos_mmc.asm):02340         
CCB8 E684             (    rsdos_mmc.asm):02341                        ldb     fcbtyp,x                 ; get file type of this fcb                                       
CCBA C140             (    rsdos_mmc.asm):02342                        cmpb    #ranfil                  ; is it a random file?                                  
CCBC 260B             (    rsdos_mmc.asm):02343                        bne     lcdec                    ; branch if not a random file                                      
                      (    rsdos_mmc.asm):02344         
CCBE EC8815           (    rsdos_mmc.asm):02345                        ldd     fcbget,x                 ;grab the random file 'get' pointer,                                                
CCC1 830001           (    rsdos_mmc.asm):02346                        subd    #$0001                   ;move it back one and restore it                                           
CCC4 ED8815           (    rsdos_mmc.asm):02347                        std     fcbget,x                 ;             
CCC7 3594             (    rsdos_mmc.asm):02348                        puls    b,x,pc                   ; restore registers and return                                         
CCC9 A78811           (    rsdos_mmc.asm):02349         lcdec          sta     fcbcdt,x                 ; save the character in the cache                                                  
CCCC 638810           (    rsdos_mmc.asm):02350                        com     fcbcfl,x                 ; set the cache flag to $ff - data in cache                                                       
CCCF 3594             (    rsdos_mmc.asm):02351                        puls    b,x,pc                   ; restore registers and return                                         
                      (    rsdos_mmc.asm):02352         
                      (    rsdos_mmc.asm):02353         ; cvn command
CCD1 BDB654           (    rsdos_mmc.asm):02354         FuncCvn            jsr     BasGetStrLenAddr         ; get length and address of string                                              
                      (    rsdos_mmc.asm):02355         
CCD4 C105             (    rsdos_mmc.asm):02356                        cmpb    #$05                     ; five bytes in a floating point number                                                
CCD6 1025E770         (    rsdos_mmc.asm):02357                        lbcs    BasFCError               ; 'fc' error if <> 5 bytes                                    
                      (    rsdos_mmc.asm):02358         
CCDA 0F06             (    rsdos_mmc.asm):02359                        clr     BasVarType               ; set variable type to numeric                                        
CCDC 7EBC14           (    rsdos_mmc.asm):02360                        jmp     lbc14                    ; copy a packed fp number from (x) to fpa0                                                   
                      (    rsdos_mmc.asm):02361         
                      (    rsdos_mmc.asm):02362         
                      (    rsdos_mmc.asm):02363         ; mkn$ command
CCDF BDB143           (    rsdos_mmc.asm):02364         FuncMkn            jsr     VarGetExprCC             ; 'tm' error if BasVarType=string                                         
                      (    rsdos_mmc.asm):02365         
CCE2 C605             (    rsdos_mmc.asm):02366                        ldb     #$05                     ; five bytes in a floating point number                                               
CCE4 BDB50F           (    rsdos_mmc.asm):02367                        jsr     BasResStr                ; reserve five bytes in string space                                             
                      (    rsdos_mmc.asm):02368         
CCE7 BDBC35           (    rsdos_mmc.asm):02369                        jsr     lbc35                    ; pack fpa0 and store it in string space                                                 
                      (    rsdos_mmc.asm):02370         
CCEA 7EB69B           (    rsdos_mmc.asm):02371                        jmp     lb69b                    ; save string descriptor on string stack                                                 
                      (    rsdos_mmc.asm):02372         
                      (    rsdos_mmc.asm):02373         
                      (    rsdos_mmc.asm):02374         ; loc command
CCED 8D07             (    rsdos_mmc.asm):02375         FuncLoc            bsr     lce19                    ; point x to file buffer                                    
                      (    rsdos_mmc.asm):02376         
CCEF EC07             (    rsdos_mmc.asm):02377                        ldd     fcbrec,x                 ; get record number (random file) or sector ctr (sequential)                                                                        
CCF1 DD52             (    rsdos_mmc.asm):02378         lce14          std     BasVarFPAcc1+3           ;save accd in bottom 2 bytes of fpa0 and                                                       
CCF3 7E880E           (    rsdos_mmc.asm):02379                        jmp     VarAssign16BitB          ;convert to floating point number                                          
                      (    rsdos_mmc.asm):02380         
                      (    rsdos_mmc.asm):02381         
                      (    rsdos_mmc.asm):02382         ; strip a device number from a basic statement, set print
                      (    rsdos_mmc.asm):02383         ; parameters according to it - error if file not
                      (    rsdos_mmc.asm):02384         ; open. return with (x) pointing to that file's fcb
CCF6 966F             (    rsdos_mmc.asm):02385         lce19          lda     TextDevN                 ; get current device number and                                              
CCF8 3402             (    rsdos_mmc.asm):02386                        pshs    a                        ; save it on the stack                            
CCFA BDB143           (    rsdos_mmc.asm):02387                        jsr     VarGetExprCC             ; 'tm' error if BasVarType=string                                      
                      (    rsdos_mmc.asm):02388         
CCFD BDA5AE           (    rsdos_mmc.asm):02389                        jsr     la5ae                    ; check for valid device number/set print parameters                                                             
                      (    rsdos_mmc.asm):02390         
CD00 0D6F             (    rsdos_mmc.asm):02391                        tst     TextDevN                 ; check device number                               
CD02 102FE744         (    rsdos_mmc.asm):02392                        lble    BasFCError               ; branch if not disk file 'illegal function call'                                                           
CD06 BDC621           (    rsdos_mmc.asm):02393                        jsr     >lc744                   ; point (x) to file buffer                                   
                      (    rsdos_mmc.asm):02394         
CD09 3502             (    rsdos_mmc.asm):02395                        puls    a                        ; get old device number off of the stack and                                                  
CD0B 976F             (    rsdos_mmc.asm):02396                        sta     TextDevN                 ; save it as device number                                    
CD0D 6D84             (    rsdos_mmc.asm):02397                        tst     fcbtyp,x                 ; is file open?                           
CD0F 1027D6E8         (    rsdos_mmc.asm):02398                        lbeq    la3fb                    ; 'file not open' error if not open                                             
                      (    rsdos_mmc.asm):02399         
CD13 39               (    rsdos_mmc.asm):02400                        rts                                     
                      (    rsdos_mmc.asm):02401         
                      (    rsdos_mmc.asm):02402         
                      (    rsdos_mmc.asm):02403         ; lof
CD14 8DE0             (    rsdos_mmc.asm):02404         FuncLof            bsr     lce19                    ; point x to file buffer                                    
                      (    rsdos_mmc.asm):02405         
CD16 A601             (    rsdos_mmc.asm):02406                        lda     fcbdrv,x                 ; get drive number and save it                                          
CD18 97EB             (    rsdos_mmc.asm):02407                        sta     dcdrv                    ; in dskcon variable                             
CD1A E602             (    rsdos_mmc.asm):02408                        ldb     fcbfgr,x                 ; get first granule of file                                       
CD1C 3410             (    rsdos_mmc.asm):02409                        pshs    x                        ; save fcb pointer on stack                                 
CD1E BDCBFB           (    rsdos_mmc.asm):02410                        jsr     >lcd1e                   ; find total number of granules in this file                                                     
                      (    rsdos_mmc.asm):02411         
CD21 4A               (    rsdos_mmc.asm):02412                        deca                             ; subtract the last granule in the file                                            
CD22 C43F             (    rsdos_mmc.asm):02413                        andb    #$3f                     ; get number of sectors used in last granule                                                     
CD24 3404             (    rsdos_mmc.asm):02414                        pshs    b                        ; save number of sectors in last granule on stack                                                       
CD26 1F89             (    rsdos_mmc.asm):02415                        tfr     a,b                      ; convert acca to positive                                 
CD28 4F               (    rsdos_mmc.asm):02416                        clra                             ; 2 byte value in accd                           
CD29 BDC656           (    rsdos_mmc.asm):02417                        jsr     >lc779                   ; mult number of full granules by 9                                            
                      (    rsdos_mmc.asm):02418         
CD2C EBE0             (    rsdos_mmc.asm):02419                        addb    ,s+                      ; add number sectors in last track                                          
CD2E 8900             (    rsdos_mmc.asm):02420                        adca    #$00                     ; propagate carry to ms byte of accd                                             
CD30 3510             (    rsdos_mmc.asm):02421                        puls    x                        ; get fcb pointer back                            
CD32 3402             (    rsdos_mmc.asm):02422                        pshs    a                        ; save acca on stack                          
CD34 A684             (    rsdos_mmc.asm):02423                        lda     fcbtyp,x                 ; get file type of this fcb and                                           
CD36 8140             (    rsdos_mmc.asm):02424                        cmpa    #ranfil                  ; check to see if it's a random file                                                
CD38 3502             (    rsdos_mmc.asm):02425                        puls    a                        ; restore acca                    
CD3A 26B5             (    rsdos_mmc.asm):02426                        bne     lce14                    ; if not a random file, then the total number of sectors in the file                                                                             
                      (    rsdos_mmc.asm):02427         
                      (    rsdos_mmc.asm):02428                                                                                                                                                    ; is the length of the file
                      (    rsdos_mmc.asm):02429         
                      (    rsdos_mmc.asm):02430         ; calculate lof for a random file - the length of a random file is the
                      (    rsdos_mmc.asm):02431         ; number of records in the file.
CD3C 3410             (    rsdos_mmc.asm):02432                        pshs    x                        ; save fcb pointer on stack                                 
CD3E 938A             (    rsdos_mmc.asm):02433                        subd    Misc16BitScratch         ; subtract zero from accd (number of sectors)                                                      
CD40 2703             (    rsdos_mmc.asm):02434                        beq     lce68                    ; branch if zero sectors                                 
                      (    rsdos_mmc.asm):02435         
CD42 830001           (    rsdos_mmc.asm):02436                        subd    #$0001                   ; subtract one sector - the last sector may not be iooz used                                                                       
CD45 8DAA             (    rsdos_mmc.asm):02437         lce68          bsr     lce14                    ; put accd into fpa0                                  
                      (    rsdos_mmc.asm):02438         
CD47 D64F             (    rsdos_mmc.asm):02439                        ldb     BasVarFPAcc1             ; get exponent of fpa0                                
CD49 2704             (    rsdos_mmc.asm):02440                        beq     lce72                    ; branch if fpa0 = 0                             
                      (    rsdos_mmc.asm):02441         
CD4B CB08             (    rsdos_mmc.asm):02442                        addb    #$08                     ; add 8 to exponent (multiply fpa0 by                                              
CD4D D74F             (    rsdos_mmc.asm):02443                        stb     BasVarFPAcc1             ; 256 bytes/sector) and save new exponent                                                   
CD4F BDBC5F           (    rsdos_mmc.asm):02444         lce72          jsr     lbc5f                    ; save number of bytes in full sectors in fpa1                                                            
                      (    rsdos_mmc.asm):02445         
CD52 AEE4             (    rsdos_mmc.asm):02446                        ldx     ,s                       ; point x to fcb                      
CD54 EC8813           (    rsdos_mmc.asm):02447                        ldd     fcblst,x                 ; get number of bytes in last sector                                                
                      (    rsdos_mmc.asm):02448         
CD57 847F             (    rsdos_mmc.asm):02449                        anda    #$7f                     ; mask off the pre-saved byte                                      
CD59 8D96             (    rsdos_mmc.asm):02450                        bsr     lce14                    ; put number bytes in last sector into fpa0                                                    
                      (    rsdos_mmc.asm):02451         
CD5B 0F62             (    rsdos_mmc.asm):02452                        clr     ressgn                   ; force sum sign = positive                                     
CD5D 965C             (    rsdos_mmc.asm):02453                        lda     BasVarFPAcc2             ; get exponents of fpa0 and                                     
CD5F D64F             (    rsdos_mmc.asm):02454                        ldb     BasVarFPAcc1             ; fpa1 prior to addition                                  
CD61 BDB9C5           (    rsdos_mmc.asm):02455                        jsr     CmdPlus                  ; add number bytes in last sector to number of                                                       
                      (    rsdos_mmc.asm):02456         
                      (    rsdos_mmc.asm):02457         ; bytes in full sectors
CD64 BDBC5F           (    rsdos_mmc.asm):02458                        jsr     lbc5f                    ; save total number of bytes in fpa1                                             
                      (    rsdos_mmc.asm):02459         
CD67 3510             (    rsdos_mmc.asm):02460                        puls    x                        ; point x to fcb                      
CD69 EC09             (    rsdos_mmc.asm):02461                        ldd     fcbrln,x                 ; get record length                               
CD6B 8D84             (    rsdos_mmc.asm):02462                        bsr     lce14                    ; put it into fpa0                           
                      (    rsdos_mmc.asm):02463         
CD6D 0F62             (    rsdos_mmc.asm):02464                        clr     ressgn                   ; force quotient sign = positive                                          
CD6F 965C             (    rsdos_mmc.asm):02465                        lda     BasVarFPAcc2             ; get exponents of fpa0 and                                     
CD71 D64F             (    rsdos_mmc.asm):02466                        ldb     BasVarFPAcc1             ; fpa1 prior to division                                  
CD73 BDBB91           (    rsdos_mmc.asm):02467                        jsr     CmdDivide                ; divide total number of bytes by number of bytes in a record                                                                      
                      (    rsdos_mmc.asm):02468         
CD76 7EBCEE           (    rsdos_mmc.asm):02469                        jmp     CmdINT                   ; convert fpa0 to an integer                                   
                      (    rsdos_mmc.asm):02470         
                      (    rsdos_mmc.asm):02471         
                      (    rsdos_mmc.asm):02472         ; free command
CD79 BDB143           (    rsdos_mmc.asm):02473         FuncFree           jsr     VarGetExprCC             ; number type check                                
                      (    rsdos_mmc.asm):02474         
CD7C BDB70E           (    rsdos_mmc.asm):02475                        jsr     lb70e                    ;evaluate numeric expression and return value in accb                                                              
                      (    rsdos_mmc.asm):02476         
CD7F C103             (    rsdos_mmc.asm):02477                        cmpb    #$03                     ; only 4 legal drives                              
CD81 1022D89A         (    rsdos_mmc.asm):02478                        lbhi    la61f                    ; 'device number' error if drive number is > 3                                                        
CD85 D7EB             (    rsdos_mmc.asm):02479                        stb     dcdrv                    ; save in drive number                               
CD87 BDC67A           (    rsdos_mmc.asm):02480                        jsr     >GetFAT                   ; get file allocation table and store in buffer                                                        
                      (    rsdos_mmc.asm):02481         
CD8A BDC632           (    rsdos_mmc.asm):02482                        jsr     >lc755                   ; point x to start of file allocation table buffer                                                           
                      (    rsdos_mmc.asm):02483         
CD8D 3006             (    rsdos_mmc.asm):02484                        leax    fatcon,x                 ; move to first granule data byte                                              
CD8F 6FE2             (    rsdos_mmc.asm):02485                        clr     ,-s                      ; space for free granule counter                                       
CD91 C644             (    rsdos_mmc.asm):02486                        ldb     #granmx                  ; get maximum number of granules                                           
CD93 A680             (    rsdos_mmc.asm):02487         lceb6          lda     ,x+                      ; get granule data                              
CD95 43               (    rsdos_mmc.asm):02488                        coma                             ;free granules $ff                       
CD96 2602             (    rsdos_mmc.asm):02489                        bne     lcebd                    ;branch if not free                            
                      (    rsdos_mmc.asm):02490         
CD98 6CE4             (    rsdos_mmc.asm):02491                        inc     ,s                       ; increment free granule counter                                      
CD9A 5A               (    rsdos_mmc.asm):02492         lcebd          decb                             ; decrement granule counter                                     
CD9B 26F6             (    rsdos_mmc.asm):02493                        bne     lceb6                    ; branch if not done                             
                      (    rsdos_mmc.asm):02494         
CD9D 3504             (    rsdos_mmc.asm):02495                        puls    b                        ; get free granule counter to accb                                        
CD9F 7EB4F3           (    rsdos_mmc.asm):02496                        jmp     VarAssign16Bit2          ; load accb into fpa0                              
                      (    rsdos_mmc.asm):02497         
                      (    rsdos_mmc.asm):02498         
                      (    rsdos_mmc.asm):02499         ; drive command
CDA2 BDB70B           (    rsdos_mmc.asm):02500         CmdDrive          jsr     VarGet8Bit               ; evaluate expr; return value in accb                                                      
                      (    rsdos_mmc.asm):02501         
CDA5 C103             (    rsdos_mmc.asm):02502                        cmpb    #$03                     ; max drive number = 3                               
CDA7 1022D874         (    rsdos_mmc.asm):02503                        lbhi    la61f                    ; 'device #' error if drive number > 3                                                
CDAB F7095A           (    rsdos_mmc.asm):02504                        stb     defdrv                   ; save default drive number                                     
CDAE 39               (    rsdos_mmc.asm):02505                        rts                                     
                      (    rsdos_mmc.asm):02506         
                      (    rsdos_mmc.asm):02507         
                      (    rsdos_mmc.asm):02508         ; evaluate expression ram vector
CDAF A664             (    rsdos_mmc.asm):02509         DosHookEvaluate         lda     $04,s                    ; = check stacked precedence flag and if it is not an end                                                                        
CDB1 2613             (    rsdos_mmc.asm):02510                        bne     lcee9                    ; = of operation, branch to extended basic's expression                                                                
                      (    rsdos_mmc.asm):02511         
                      (    rsdos_mmc.asm):02512                                                                                                                                                    ; = evaluation routine
CDB3 AE65             (    rsdos_mmc.asm):02513                        ldx     $05,s                    ;          
CDB5 8CAF9A           (    rsdos_mmc.asm):02514                        cmpx    #laf9a                   ;            
CDB8 260C             (    rsdos_mmc.asm):02515                        bne     lcee9                    ; check two return addresses back on the stack                                                       
                      (    rsdos_mmc.asm):02516         
CDBA AE62             (    rsdos_mmc.asm):02517                        ldx     $02,s                    ; to see if the call to evaluate expression is                                                       
CDBC 8CB166           (    rsdos_mmc.asm):02518                        cmpx    #lb166                   ; coming from the 'let' command - branch out if                                                          
CDBF 2605             (    rsdos_mmc.asm):02519                        bne     lcee9                    ; not coming from 'let'                                
                      (    rsdos_mmc.asm):02520         
CDC1 8ECDC9           (    rsdos_mmc.asm):02521                        ldx     #lceec                   ; = if coming from 'let', replace the return addr                                                           
CDC4 AF65             (    rsdos_mmc.asm):02522                        stx     $05,s                    ; = with the disk basic 'let' modifier address                                                       
CDC6 7E8846           (    rsdos_mmc.asm):02523         lcee9          jmp     CoCoVect18B              ; extended basic expression evaluation                                                     
                      (    rsdos_mmc.asm):02524         
                      (    rsdos_mmc.asm):02525         
                      (    rsdos_mmc.asm):02526         ; let modifier
CDC9 3502             (    rsdos_mmc.asm):02527         lceec          puls    a                        ; pull variable type off of the stack                                           
CDCB 46               (    rsdos_mmc.asm):02528                        rora                             ; set carry if siring, clear carry if numeric                                                  
CDCC BDB148           (    rsdos_mmc.asm):02529                        jsr     lb148                    ; do a 'tm' check                          
                      (    rsdos_mmc.asm):02530         
CDCF 1027EE60         (    rsdos_mmc.asm):02531                        lbeq    lbc33                    ; if numeric variable, pack fpa0 into vardes                                                      
                      (    rsdos_mmc.asm):02532         
CDD3 9E52             (    rsdos_mmc.asm):02533                        ldx     BasVarFPAcc1+3           ; point x to string descriptor                                        
CDD5 EC02             (    rsdos_mmc.asm):02534                        ldd     $02,x                    ; get address of siring                                
CDD7 10830989         (    rsdos_mmc.asm):02535                        cmpd    #dflbuf                  ; compare to start of random file buffers                                                     
CDDB 2507             (    rsdos_mmc.asm):02536                        blo     lcf07                    ; and branch if lower                              
                      (    rsdos_mmc.asm):02537         
CDDD B3094A           (    rsdos_mmc.asm):02538                        subd    fcbadr                   ; subtract out the end of random file buffers                                                        
CDE0 1025E1CD         (    rsdos_mmc.asm):02539                        lbcs    lafb1                    ; branch if string stored in random file buffer -                                                           
                      (    rsdos_mmc.asm):02540         
                      (    rsdos_mmc.asm):02541         ; move it into the string space
CDE4 7EAFA4           (    rsdos_mmc.asm):02542         lcf07          jmp     lafa4                    ; branch back to basic's 'let' command                                                    
                      (    rsdos_mmc.asm):02543         
                      (    rsdos_mmc.asm):02544         
                      (    rsdos_mmc.asm):02545         ;modifier for exbas command interpretation handler
CDE7 81CA             (    rsdos_mmc.asm):02546         dxcvec         cmpa    #$ca                     ; token for dload?                                 
CDE9 271C             (    rsdos_mmc.asm):02547                        beq     lcf2a                    ; yes              
                      (    rsdos_mmc.asm):02548         
CDEB 81C8             (    rsdos_mmc.asm):02549                        cmpa    #$c8                     ; token for pmode?                           
CDED 1026B34B         (    rsdos_mmc.asm):02550                        lbne    l813c                    ; no              
                      (    rsdos_mmc.asm):02551         
                      (    rsdos_mmc.asm):02552         ; disk basic modifier for pmode - allows for the ram the dos uses
CDF1 9D9F             (    rsdos_mmc.asm):02553                        jsr     BasChrGet                ; get next character from basic                                         
                      (    rsdos_mmc.asm):02554         
CDF3 812C             (    rsdos_mmc.asm):02555                        cmpa    #',                      ; check for comma                          
CDF5 1027C857         (    rsdos_mmc.asm):02556                        lbeq    l9650                    ; branch if comma                           
                      (    rsdos_mmc.asm):02557         
CDF9 BDB70B           (    rsdos_mmc.asm):02558                        jsr     VarGet8Bit               ; evaluate expression; return value in accb                                                       
                      (    rsdos_mmc.asm):02559         
CDFC C104             (    rsdos_mmc.asm):02560                        cmpb    #$04                     ; check for pmode 4                            
CDFE 1022E648         (    rsdos_mmc.asm):02561                        lbhi    BasFCError               ; 'fc' error if pmode > 4                                   
CE02 96BC             (    rsdos_mmc.asm):02562                        lda     GrStartPages             ; number blocks before graphics pages                                               
CE04 7E962E           (    rsdos_mmc.asm):02563                        jmp     l962e                    ; jump to exeas' pmode command                                       
                      (    rsdos_mmc.asm):02564         
                      (    rsdos_mmc.asm):02565         
                      (    rsdos_mmc.asm):02566         ; disk basic dload modifier
CE07 BDA429           (    rsdos_mmc.asm):02567         lcf2a          jsr     CasClosFiles             ; close files                           
                      (    rsdos_mmc.asm):02568         
CE0A 9D9F             (    rsdos_mmc.asm):02569                        jsr     BasChrGet                ; get next character from basic                                         
                      (    rsdos_mmc.asm):02570         
CE0C 7E8C1B           (    rsdos_mmc.asm):02571                        jmp     l8c1b                    ; jump to exeas' dload                               
                      (    rsdos_mmc.asm):02572         
                      (    rsdos_mmc.asm):02573         
CE0F C134             (    rsdos_mmc.asm):02574         dxivec         cmpb    #($9a-$80)*2             ; modified token for pos                                                                     
CE11 1026B353         (    rsdos_mmc.asm):02575                        lbne    l8168                    ; if not pos, go to exbas secondary comm handler                                                          
                      (    rsdos_mmc.asm):02576         
CE15 BDB262           (    rsdos_mmc.asm):02577                        jsr     lb262                    ; syntax check for '(' and evaluate expression                                                       
                      (    rsdos_mmc.asm):02578         
CE18 966F             (    rsdos_mmc.asm):02579                        lda     TextDevN                 ; get device number and                                 
CE1A 3402             (    rsdos_mmc.asm):02580                        pshs    a                        ; save it on stack                        
CE1C BDA5AE           (    rsdos_mmc.asm):02581                        jsr     la5ae                    ; evaluate device number                                 
                      (    rsdos_mmc.asm):02582         
CE1F BDA406           (    rsdos_mmc.asm):02583                        jsr     la406                    ; test device number                             
                      (    rsdos_mmc.asm):02584         
CE22 0D6F             (    rsdos_mmc.asm):02585                        tst     TextDevN                 ; check device number and branch                                          
CE24 2F13             (    rsdos_mmc.asm):02586                        ble     lcf5c                    ; if not a disk file                             
CE26 BDC621           (    rsdos_mmc.asm):02587                        jsr     >lc744                   ; point x to fcb                         
                      (    rsdos_mmc.asm):02588         
CE29 E684             (    rsdos_mmc.asm):02589                        ldb     fcbtyp,x                 ; get file type                           
CE2B C140             (    rsdos_mmc.asm):02590                        cmpb    #ranfil                  ; direct/random file?                                 
CE2D 260A             (    rsdos_mmc.asm):02591                        bne     lcf5c                    ; branch if not a random file                                      
                      (    rsdos_mmc.asm):02592         
CE2F 3502             (    rsdos_mmc.asm):02593                        puls    a                        ; restore device number                             
CE31 976F             (    rsdos_mmc.asm):02594                        sta     TextDevN                 ;           
CE33 EC8817           (    rsdos_mmc.asm):02595                        ldd     fcbput,x                 ; =grab the 'put' data item counter and convert                                                           
CE36 7EB4F4           (    rsdos_mmc.asm):02596                        jmp     givabf                   ; =it to a floating point number                                          
                      (    rsdos_mmc.asm):02597         
CE39 BDA35F           (    rsdos_mmc.asm):02598         lcf5c          jsr     la35f                    ; set print parameters                                    
                      (    rsdos_mmc.asm):02599         
CE3C 3502             (    rsdos_mmc.asm):02600                        puls    a                        ; restore device number                             
CE3E 976F             (    rsdos_mmc.asm):02601                        sta     TextDevN                 ;           
CE40 D66C             (    rsdos_mmc.asm):02602                        ldb     TextVDUCurrCol           ; =get print position and                                   
CE42 7EB4F3           (    rsdos_mmc.asm):02603                        jmp     VarAssign16Bit2          ; =convert it to floating point number in fpa0                                                       
                      (    rsdos_mmc.asm):02604         
                      (    rsdos_mmc.asm):02605         
                      (    rsdos_mmc.asm):02606         ; savem command
CE45 9D9F             (    rsdos_mmc.asm):02607         lcf68          jsr     BasChrGet                ; get next input character                                          
                      (    rsdos_mmc.asm):02608         
CE47 8D4F             (    rsdos_mmc.asm):02609                        bsr     lcfbb                    ; get filename, etc.                             
                      (    rsdos_mmc.asm):02610         
CE49 BD836C           (    rsdos_mmc.asm):02611                        jsr     l836c                    ; evaluate expression, put ii (2 bytes) on stack                                                         
                      (    rsdos_mmc.asm):02612         
CE4C BD836C           (    rsdos_mmc.asm):02613                        jsr     l836c                    ; ditto                
                      (    rsdos_mmc.asm):02614         
CE4F AC62             (    rsdos_mmc.asm):02615                        cmpx    $02,s                    ; compare end address to start address                                                
CE51 1025E5F5         (    rsdos_mmc.asm):02616                        lbcs    BasFCError               ; if start > end, then 'illegal function call'                                                        
                      (    rsdos_mmc.asm):02617         
CE55 BD836C           (    rsdos_mmc.asm):02618                        jsr     l836c                    ; eval expression (transfer address), put on stack                                                           
                      (    rsdos_mmc.asm):02619         
CE58 BDA5C7           (    rsdos_mmc.asm):02620                        jsr     la5c7                    ; syntax error if any more chars on this line                                                      
                      (    rsdos_mmc.asm):02621         
CE5B CC0200           (    rsdos_mmc.asm):02622                        ldd     #$0200                   ; file type=2, ascii flag = crunched (0)                                                  
CE5E FD0957           (    rsdos_mmc.asm):02623                        std     dfltyp                   ;           
CE61 BDC8E1           (    rsdos_mmc.asm):02624                        jsr     >lca04                   ; get next unopen file and initialize fcb                                                  
                      (    rsdos_mmc.asm):02625         
CE64 4F               (    rsdos_mmc.asm):02626                        clra                             ;zero flag - first byte of preamble                                        
CE65 8D2B             (    rsdos_mmc.asm):02627                        bsr     lcfb5                    ;write a byte to buffer                                
                      (    rsdos_mmc.asm):02628         
CE67 EC62             (    rsdos_mmc.asm):02629                        ldd     $02,s                    ; get end address                          
CE69 A364             (    rsdos_mmc.asm):02630                        subd    $04,s                    ; subtract the start address                                      
CE6B C30001           (    rsdos_mmc.asm):02631                        addd    #$0001                   ; the saved data block will include both the first and last bytes                                                                            
CE6E 1F02             (    rsdos_mmc.asm):02632                        tfr     d,y                      ; save length in y                         
CE70 8D1E             (    rsdos_mmc.asm):02633                        bsr     lcfb3                    ; write file length to buffer - first argument of preamble                                                                   
                      (    rsdos_mmc.asm):02634         
CE72 EC64             (    rsdos_mmc.asm):02635                        ldd     $04,s                    ; get the start address                                
CE74 8D1A             (    rsdos_mmc.asm):02636                        bsr     lcfb3                    ; write out the start address - second preamble argument                                                                 
                      (    rsdos_mmc.asm):02637         
CE76 AE64             (    rsdos_mmc.asm):02638                        ldx     $04,s                    ; get start address                            
CE78 A680             (    rsdos_mmc.asm):02639         lcf9b          lda     ,x+                      ; grab a byte                         
CE7A BDCB01           (    rsdos_mmc.asm):02640                        jsr     >lcc24                   ; write it out                       
                      (    rsdos_mmc.asm):02641         
CE7D 313F             (    rsdos_mmc.asm):02642                        leay    -1,y                     ; decrement byte counter                                 
CE7F 26F7             (    rsdos_mmc.asm):02643                        bne     lcf9b                    ; branch if all bytes not done                                       
                      (    rsdos_mmc.asm):02644         
CE81 86FF             (    rsdos_mmc.asm):02645                        lda     #$ff                     ; first byte of postamble                                 
CE83 8D0D             (    rsdos_mmc.asm):02646                        bsr     lcfb5                    ; write it out - eof record                                    
                      (    rsdos_mmc.asm):02647         
CE85 4F               (    rsdos_mmc.asm):02648                        clra                             ; first argument of postamble is                                     
CE86 5F               (    rsdos_mmc.asm):02649                        clrb                             ; a dummy - zero value                           
CE87 8D07             (    rsdos_mmc.asm):02650                        bsr     lcfb3                    ; write out postamble first argument                                             
                      (    rsdos_mmc.asm):02651         
CE89 3536             (    rsdos_mmc.asm):02652                        puls    a,b,x,y                  ; get control addresses from the stack                                                  
CE8B 8D03             (    rsdos_mmc.asm):02653                        bsr     lcfb3                    ; write out the transfer address - 2nd argument                                                        
                      (    rsdos_mmc.asm):02654         
CE8D 7EA42D           (    rsdos_mmc.asm):02655                        jmp     la42d                    ; go close all files                             
                      (    rsdos_mmc.asm):02656         
                      (    rsdos_mmc.asm):02657         
                      (    rsdos_mmc.asm):02658         ; write accd to the buffer
CE90 8D00             (    rsdos_mmc.asm):02659         lcfb3          bsr     lcfb5                    ; write acca to buffer, then swap acca,accb                                                         
                      (    rsdos_mmc.asm):02660         
CE92 BDCB01           (    rsdos_mmc.asm):02661         lcfb5          jsr     >lcc24                   ; write acca to buffer                                    
                      (    rsdos_mmc.asm):02662         
CE95 1E89             (    rsdos_mmc.asm):02663                        exg     a,b                      ; swap acca,accb                       
CE97 39               (    rsdos_mmc.asm):02664                        rts                                     
                      (    rsdos_mmc.asm):02665         
CE98 8EC18C           (    rsdos_mmc.asm):02666         lcfbb          ldx     #binext                  ; point to .bin extension                                         
CE9B 7EC815           (    rsdos_mmc.asm):02667                        jmp     >lc938                   ; get filename, etc.                             
                      (    rsdos_mmc.asm):02668         
                      (    rsdos_mmc.asm):02669         
                      (    rsdos_mmc.asm):02670         ; loadm command
CE9E 9D9F             (    rsdos_mmc.asm):02671         lcfc1          jsr     BasChrGet                ; get next input character                                         
                      (    rsdos_mmc.asm):02672         
CEA0 8DF6             (    rsdos_mmc.asm):02673                        bsr     lcfbb                    ; get filename, etc.                             
                      (    rsdos_mmc.asm):02674         
CEA2 BDC8E4           (    rsdos_mmc.asm):02675                        jsr     >lca07                   ; open next available file for input                                             
                      (    rsdos_mmc.asm):02676         
CEA5 FC0957           (    rsdos_mmc.asm):02677                        ldd     dfltyp                   ; get file type and ascii flag                                        
CEA8 830200           (    rsdos_mmc.asm):02678                        subd    #$0200                   ; for loadm file: type=2, ascii flag=0                                                 
CEAB 1026D767         (    rsdos_mmc.asm):02679                        lbne    BasFMError               ; 'bad file mode' error                                 
                      (    rsdos_mmc.asm):02680         
CEAF 9E8A             (    rsdos_mmc.asm):02681                        ldx     Misc16BitScratch         ; zero out x reg - default value of offset                                                  
CEB1 9DA5             (    rsdos_mmc.asm):02682                        jsr     BasChrGetCurr            ; get current character from basic                                            
                      (    rsdos_mmc.asm):02683         
CEB3 2706             (    rsdos_mmc.asm):02684                        beq     lcfde                    ; branch if end of line - no offset                                            
                      (    rsdos_mmc.asm):02685         
CEB5 BDB26D           (    rsdos_mmc.asm):02686                        jsr     VarCKComma               ; syntax check for comma                                    
                      (    rsdos_mmc.asm):02687         
CEB8 BDB73D           (    rsdos_mmc.asm):02688                        jsr     VarGet16Bit              ; evaluate expression                              
                      (    rsdos_mmc.asm):02689         
CEBB 9FD3             (    rsdos_mmc.asm):02690         lcfde          stx     vd3                      ; store offset in vd3                                 
CEBD BDA5C7           (    rsdos_mmc.asm):02691                        jsr     la5c7                    ; syntax error if other characters on line                                                   
                      (    rsdos_mmc.asm):02692         
                      (    rsdos_mmc.asm):02693         
                      (    rsdos_mmc.asm):02694         ; get preamble/postamble
CEC0 BDCC99           (    rsdos_mmc.asm):02695         lcfe3          jsr     >lcdbc                   ; get first byte                              
                      (    rsdos_mmc.asm):02696         
CEC3 3402             (    rsdos_mmc.asm):02697                        pshs    a                        ; save it on the stack                            
CEC5 8D29             (    rsdos_mmc.asm):02698                        bsr     ld013                    ; get first argument                             
                      (    rsdos_mmc.asm):02699         
CEC7 1F02             (    rsdos_mmc.asm):02700                        tfr     d,y                      ; save it in y                     
CEC9 8D25             (    rsdos_mmc.asm):02701                        bsr     ld013                    ; get the second argument                                  
                      (    rsdos_mmc.asm):02702         
CECB D3D3             (    rsdos_mmc.asm):02703                        addd    vd3                      ; add it to the offset                              
CECD DD9D             (    rsdos_mmc.asm):02704                        std     BasExecAddr              ; store it in the jump address of the exec command                                                            
CECF 1F01             (    rsdos_mmc.asm):02705                        tfr     d,x                      ; save it in x                     
CED1 A6E0             (    rsdos_mmc.asm):02706                        lda     ,s+                      ; get the first byte off of the stack                                            
CED3 1026D556         (    rsdos_mmc.asm):02707                        lbne    la42d                    ; close file if postamble (eof)                                         
                      (    rsdos_mmc.asm):02708         
                      (    rsdos_mmc.asm):02709         
                      (    rsdos_mmc.asm):02710         ; get record byte(s)
CED7 BDC4A1           (    rsdos_mmc.asm):02711         lcffa          jsr     >lc5c4                   ; get byte from buffer                                    
                      (    rsdos_mmc.asm):02712         
CEDA D670             (    rsdos_mmc.asm):02713                        ldb     cinbfl                   ; get status of console in buffer                                           
CEDC 2703             (    rsdos_mmc.asm):02714                        beq     ld004                    ; branch if buffer not empty                                     
                      (    rsdos_mmc.asm):02715         
CEDE 7EC22F           (    rsdos_mmc.asm):02716                        jmp     >lc352                   ; 'input past end of file' error                                         
                      (    rsdos_mmc.asm):02717         
CEE1 A784             (    rsdos_mmc.asm):02718         ld004          sta     ,x                       ; store byte in memory                                 
CEE3 A180             (    rsdos_mmc.asm):02719                        cmpa    ,x+                      ;test to see if it stored properly and                                              
CEE5 2703             (    rsdos_mmc.asm):02720                        beq     ld00d                    ;branch if proper store (not in rom or bad ram)                                                        
                      (    rsdos_mmc.asm):02721         
CEE7 7ED4CC           (    rsdos_mmc.asm):02722                        jmp     >ld709                   ; 'i/o error' if bad store                                   
                      (    rsdos_mmc.asm):02723         
CEEA 313F             (    rsdos_mmc.asm):02724         ld00d          leay    -1,y                     ; decrement byte count                                    
CEEC 26E9             (    rsdos_mmc.asm):02725                        bne     lcffa                    ; get next byte if not done                                    
                      (    rsdos_mmc.asm):02726         
CEEE 20D0             (    rsdos_mmc.asm):02727                        bra     lcfe3                    ; read another pre/post amble                                      
                      (    rsdos_mmc.asm):02728         ; read two bytes from buffer - return them in accd
CEF0 8D00             (    rsdos_mmc.asm):02729         ld013          bsr     ld015                    ; read a byte, save it in accb                                            
                      (    rsdos_mmc.asm):02730         
CEF2 BDCC99           (    rsdos_mmc.asm):02731         ld015          jsr     >lcdbc                   ; get a character from input buffer, return it in acca                                                                    
                      (    rsdos_mmc.asm):02732         
CEF5 1E89             (    rsdos_mmc.asm):02733                        exg     a,b                      ; swap acca,accb                       
CEF7 39               (    rsdos_mmc.asm):02734                        rts                                     
                      (    rsdos_mmc.asm):02735         
                      (    rsdos_mmc.asm):02736         
                      (    rsdos_mmc.asm):02737         ; rename command
CEF8 9EA6             (    rsdos_mmc.asm):02738         CmdRename         ldx     BasAddrSigByte           ; save current input pointer                                            
CEFA 3410             (    rsdos_mmc.asm):02739                        pshs    x                        ; on the stack                    
CEFC 8D35             (    rsdos_mmc.asm):02740                        bsr     ld056                    ; get filename of source file                                      
                      (    rsdos_mmc.asm):02741         
CEFE 96EB             (    rsdos_mmc.asm):02742                        lda     dcdrv                    ; save drive number                            
CF00 3402             (    rsdos_mmc.asm):02743                        pshs    a                        ; on the stack                    
CF02 8D2A             (    rsdos_mmc.asm):02744                        bsr     ld051                    ; syntax check for 'to' and get new filename                                                     
                      (    rsdos_mmc.asm):02745         
CF04 3502             (    rsdos_mmc.asm):02746                        puls    a                        ; get source drive number                               
CF06 91EB             (    rsdos_mmc.asm):02747                        cmpa    dcdrv                    ; compare to new file drive number                                            
CF08 1026E53E         (    rsdos_mmc.asm):02748                        lbne    BasFCError               ; 'fc' error if flies on different drives                                                   
                      (    rsdos_mmc.asm):02749         
CF0C 8D28             (    rsdos_mmc.asm):02750                        bsr     ld059                    ; verify that new file does not already exist                                                      
                      (    rsdos_mmc.asm):02751         
CF0E 3510             (    rsdos_mmc.asm):02752                        puls    x                        ; restore input pointer                             
CF10 9FA6             (    rsdos_mmc.asm):02753                        stx     BasAddrSigByte           ;           
CF12 8D1F             (    rsdos_mmc.asm):02754                        bsr     ld056                    ; get source filename again                                    
                      (    rsdos_mmc.asm):02755         
CF14 BDC569           (    rsdos_mmc.asm):02756                        jsr     >lc68c                   ; scan directory for source filename                                             
                      (    rsdos_mmc.asm):02757         
CF17 BDC5C2           (    rsdos_mmc.asm):02758                        jsr     >lc6e5                   ; 'ne' error if not found                                  
                      (    rsdos_mmc.asm):02759         
CF1A 8D12             (    rsdos_mmc.asm):02760                        bsr     ld051                    ; syntax check for 'to' and get new filename                                                     
                      (    rsdos_mmc.asm):02761         
CF1C 8E094C           (    rsdos_mmc.asm):02762                        ldx     #dnambf                  ; point x to filename                                
CF1F FE0974           (    rsdos_mmc.asm):02763                        ldu     v974                     ; point u to directory entry of source file                                                   
CF22 C60B             (    rsdos_mmc.asm):02764                        ldb     #$0b                     ; 11 characters in filename and extension                                                 
CF24 BDA59A           (    rsdos_mmc.asm):02765                        jsr     UtilCopyBXtoU            ; copy new filename to source file directory ram image                                                               
                      (    rsdos_mmc.asm):02766         
CF27 C603             (    rsdos_mmc.asm):02767                        ldb     #$03                     ; get write op code and                               
CF29 D7EA             (    rsdos_mmc.asm):02768                        stb     dcopc                    ; save in dskcon variable                                  
CF2B 7ED4B5           (    rsdos_mmc.asm):02769                        jmp     >DoDiskReadWrite                   ; write new directory sector                                     
                      (    rsdos_mmc.asm):02770         
                      (    rsdos_mmc.asm):02771         
                      (    rsdos_mmc.asm):02772         ; do a syntax check for 'to' and strip a filename from basic
CF2E C6A5             (    rsdos_mmc.asm):02773         ld051          ldb     #$a5                     ; 'to' token                         
CF30 BDB26F           (    rsdos_mmc.asm):02774                        jsr     VarCKChar                ; syntax check for 'to'                                
                      (    rsdos_mmc.asm):02775         
CF33 7EC812           (    rsdos_mmc.asm):02776         ld056          jmp     >lc935                   ; get filename from basic                                       
                      (    rsdos_mmc.asm):02777         
CF36 BDC569           (    rsdos_mmc.asm):02778         ld059          jsr     >lc68c                   ; scan directory for filename                                           
                      (    rsdos_mmc.asm):02779         
CF39 C642             (    rsdos_mmc.asm):02780                        ldb     #33*2                    ; 'file already exists' error                                                                     
CF3B 7D0973           (    rsdos_mmc.asm):02781                        tst     v973                     ; check for a match                           
CF3E 1026DD04         (    rsdos_mmc.asm):02782                        lbne    SysErr                   ; 'ae' error if file in directory                                           
                      (    rsdos_mmc.asm):02783         
CF42 39               (    rsdos_mmc.asm):02784                        rts                                     
                      (    rsdos_mmc.asm):02785         
                      (    rsdos_mmc.asm):02786         
                      (    rsdos_mmc.asm):02787         ; write command
CF43 1027EA11         (    rsdos_mmc.asm):02788         CmdWrite          lbeq    TextOutCRLF              ; print carriage return to console out if end of line                                                                    
                      (    rsdos_mmc.asm):02789         
CF47 8D03             (    rsdos_mmc.asm):02790                        bsr     ld06f                    ; go write an item list                                
                      (    rsdos_mmc.asm):02791         
CF49 0F6F             (    rsdos_mmc.asm):02792                        clr     TextDevN                 ; set device number to screen                                       
CF4B 39               (    rsdos_mmc.asm):02793         ld06e          rts                                          
                      (    rsdos_mmc.asm):02794         
CF4C 8123             (    rsdos_mmc.asm):02795         ld06f          cmpa    #'#                      ; check for device number flag                                            
CF4E 260F             (    rsdos_mmc.asm):02796                        bne     ld082                    ; default to current device number if none given                                                         
                      (    rsdos_mmc.asm):02797         
CF50 BDA5A5           (    rsdos_mmc.asm):02798                        jsr     la5a5                    ; set device number; check validity                                            
                      (    rsdos_mmc.asm):02799         
CF53 BDA406           (    rsdos_mmc.asm):02800                        jsr     la406                    ; make sure selected file is an output file                                                    
                      (    rsdos_mmc.asm):02801         
CF56 9DA5             (    rsdos_mmc.asm):02802                        jsr     BasChrGetCurr            ; get current input character                                       
                      (    rsdos_mmc.asm):02803         
CF58 1027E9FC         (    rsdos_mmc.asm):02804                        lbeq    TextOutCRLF              ; print cr to console out if end of line                                                  
                      (    rsdos_mmc.asm):02805         
CF5C BDB26D           (    rsdos_mmc.asm):02806         ld07f          jsr     VarCKComma               ; syntax check for comma                                         
                      (    rsdos_mmc.asm):02807         
CF5F BDB156           (    rsdos_mmc.asm):02808         ld082          jsr     VarGetStr                ; evaluate expression                                   
                      (    rsdos_mmc.asm):02809         
CF62 9606             (    rsdos_mmc.asm):02810                        lda     BasVarType               ; get variable type                             
CF64 261E             (    rsdos_mmc.asm):02811                        bne     ld0a7                    ; branch if string                           
                      (    rsdos_mmc.asm):02812         
CF66 BDBDD9           (    rsdos_mmc.asm):02813                        jsr     lbdd9                    ; convert fp number to ascii string                                            
                      (    rsdos_mmc.asm):02814         
CF69 BDB516           (    rsdos_mmc.asm):02815                        jsr     lb516                    ; put on temporary string stack                                        
                      (    rsdos_mmc.asm):02816         
CF6C BDB99F           (    rsdos_mmc.asm):02817                        jsr     lb99f                    ; print string to console out                                      
                      (    rsdos_mmc.asm):02818         
                      (    rsdos_mmc.asm):02819         
                      (    rsdos_mmc.asm):02820         ; print item separator to console out
CF6F 9DA5             (    rsdos_mmc.asm):02821         ld092          jsr     BasChrGetCurr            ; get current character                                      
                      (    rsdos_mmc.asm):02822         
CF71 1027E9E3         (    rsdos_mmc.asm):02823                        lbeq    TextOutCRLF              ; put cr to console out if end of line                                                
                      (    rsdos_mmc.asm):02824         
CF75 862C             (    rsdos_mmc.asm):02825                        lda     #',                      ; comma: non-cassette separator                                       
CF77 BDA35F           (    rsdos_mmc.asm):02826                        jsr     la35f                    ; set print parameters                               
                      (    rsdos_mmc.asm):02827         
CF7A 0D6E             (    rsdos_mmc.asm):02828                        tst     CasIOFlag                ; get console print device and                                        
CF7C 2702             (    rsdos_mmc.asm):02829                        beq     ld0a3                    ; branch if not cassette                                 
                      (    rsdos_mmc.asm):02830         
CF7E 860D             (    rsdos_mmc.asm):02831                        lda     #cr                      ; get carriage return - cassette item separator                                                      
CF80 8D14             (    rsdos_mmc.asm):02832         ld0a3          bsr     ld0b9                    ; send separator to console out                                             
                      (    rsdos_mmc.asm):02833         
CF82 20D8             (    rsdos_mmc.asm):02834                        bra     ld07f                    ; get next item                        
                      (    rsdos_mmc.asm):02835         
                      (    rsdos_mmc.asm):02836         ; print a string to console out
CF84 8D07             (    rsdos_mmc.asm):02837         ld0a7          bsr     ld0b0                    ; print leading string delimiter (")                                                  
                      (    rsdos_mmc.asm):02838         
CF86 BDB99F           (    rsdos_mmc.asm):02839                        jsr     lb99f                    ; print string to console out                                      
                      (    rsdos_mmc.asm):02840         
CF89 8D02             (    rsdos_mmc.asm):02841                        bsr     ld0b0                    ; print ending string delimiter (")                                            
                      (    rsdos_mmc.asm):02842         
CF8B 20E2             (    rsdos_mmc.asm):02843                        bra     ld092                    ; go print separator                             
                      (    rsdos_mmc.asm):02844         
                      (    rsdos_mmc.asm):02845         ; print string delimiter (") to console out
CF8D BDA35F           (    rsdos_mmc.asm):02846         ld0b0          jsr     la35f                    ; set print parameters                                    
                      (    rsdos_mmc.asm):02847         
CF90 0D6E             (    rsdos_mmc.asm):02848                        tst     CasIOFlag                ; get console print device and                                        
CF92 26B7             (    rsdos_mmc.asm):02849                        bne     ld06e                    ; return if cassette                             
                      (    rsdos_mmc.asm):02850         
CF94 8622             (    rsdos_mmc.asm):02851                        lda     #'"                      ; quote: non-cassette string delimiter                                              
CF96 7EA282           (    rsdos_mmc.asm):02852         ld0b9          jmp     TextOutChar              ; send to console out                                   
                      (    rsdos_mmc.asm):02853         
                      (    rsdos_mmc.asm):02854         
                      (    rsdos_mmc.asm):02855         ; field command
CF99 BDC70B           (    rsdos_mmc.asm):02856         CmdField          jsr     >lc82e                   ; evaluate device number & verify random file open                                                                
                      (    rsdos_mmc.asm):02857         
CF9C 4F               (    rsdos_mmc.asm):02858                        clra                             ;      
CF9D 5F               (    rsdos_mmc.asm):02859                        clrb                             ; clear total field length counter                                       
CF9E 3416             (    rsdos_mmc.asm):02860                        pshs    x,b,a                    ; save fcb pointer & initialize total field length to zero                                                                    
CFA0 9DA5             (    rsdos_mmc.asm):02861         ld0c3          jsr     BasChrGetCurr            ; get current input character                                            
                      (    rsdos_mmc.asm):02862         
CFA2 2602             (    rsdos_mmc.asm):02863                        bne     ld0c9                    ; branch if not end of line                                    
                      (    rsdos_mmc.asm):02864         
CFA4 3596             (    rsdos_mmc.asm):02865                        puls    a,b,x,pc                 ; clean up stack and return                                        
CFA6 BDB738           (    rsdos_mmc.asm):02866         ld0c9          jsr     VarGetComma8             ; syntax check for comma, evaluate expression                                                           
                      (    rsdos_mmc.asm):02867         
CFA9 3414             (    rsdos_mmc.asm):02868                        pshs    x,b                      ; save field length (accb) on stack, x is a dummy which will                                                                    
                      (    rsdos_mmc.asm):02869         ; reserve 2 bytes for the address which will be calculated below
                      (    rsdos_mmc.asm):02870         ; at this point the stack will have the following information on it:
                      (    rsdos_mmc.asm):02871         ; ,s = field length   1 2,s = random file buffer address
                      (    rsdos_mmc.asm):02872         ; 3 4,s = total field length  5 6,s = fcd pointer
CFAB 4F               (    rsdos_mmc.asm):02873                        clra                             ; clear ms byte                    
CFAC E363             (    rsdos_mmc.asm):02874                        addd    $03,s                    ; add field length to total field length counter                                                          
CFAE 2507             (    rsdos_mmc.asm):02875                        blo     ld0da                    ; 'fo' error if sum > $ffff                                    
                      (    rsdos_mmc.asm):02876         
CFB0 AE65             (    rsdos_mmc.asm):02877                        ldx     $05,s                    ; point x to fcb                         
CFB2 10A309           (    rsdos_mmc.asm):02878                        cmpd    fcbrln,x                 ; compare to record length & branch if                                                   
CFB5 2305             (    rsdos_mmc.asm):02879                        bls     ld0df                    ;total field length < record length                                            
                      (    rsdos_mmc.asm):02880         
CFB7 C644             (    rsdos_mmc.asm):02881         ld0da          ldb     #34*2                    ; 'field overflow' error                                                                     
CFB9 7EAC46           (    rsdos_mmc.asm):02882                        jmp     SysErr                   ; jump to error driver                               
                      (    rsdos_mmc.asm):02883         
CFBC EE63             (    rsdos_mmc.asm):02884         ld0df          ldu     $03,s                    ; load u with old total length of all fields                                                          
CFBE ED63             (    rsdos_mmc.asm):02885                        std     $03,s                    ; save new total field length                                      
CFC0 EC0B             (    rsdos_mmc.asm):02886                        ldd     fcbbuf,x                 ; point accd to start of random file buffer                                                       
CFC2 33CB             (    rsdos_mmc.asm):02887                        leau    d,u                      ;point u to this field's slot in the random                                                   
CFC4 EF61             (    rsdos_mmc.asm):02888                        stu     $01,s                    ;file buffer and save it on the stack                                              
CFC6 C6FF             (    rsdos_mmc.asm):02889                        ldb     #$ff                     ; secondary token                         
CFC8 BDB26F           (    rsdos_mmc.asm):02890                        jsr     VarCKChar                ; syntax check for secondary token                                           
                      (    rsdos_mmc.asm):02891         
CFCB C6A7             (    rsdos_mmc.asm):02892                        ldb     #$a7                     ; 'as' token                    
CFCD BDB26F           (    rsdos_mmc.asm):02893                        jsr     VarCKChar                ; syntax check for 'as' token                                      
                      (    rsdos_mmc.asm):02894         
CFD0 BDB357           (    rsdos_mmc.asm):02895                        jsr     VarGetVar                ; evaluate variable                            
                      (    rsdos_mmc.asm):02896         
CFD3 BDB146           (    rsdos_mmc.asm):02897                        jsr     VarGetExpr               ; 'tm' error if numeric variable                                         
                      (    rsdos_mmc.asm):02898         
CFD6 3544             (    rsdos_mmc.asm):02899                        puls    b,u                      ; pull string address and length                                        
CFD8 E784             (    rsdos_mmc.asm):02900                        stb     ,x                       ; off of the stack and save them                                      
CFDA EF02             (    rsdos_mmc.asm):02901                        stu     $02,x                    ; in string descriptor                               
CFDC 20C2             (    rsdos_mmc.asm):02902                        bra     ld0c3                    ; check for another field specification                                                
                      (    rsdos_mmc.asm):02903         
                      (    rsdos_mmc.asm):02904         ; rset command
CFDE                  (    rsdos_mmc.asm):02905         CmdRset
                      (    rsdos_mmc.asm):02906         ;              lda     #$4f                        ; skip one byte                           
CFDE 86               (    rsdos_mmc.asm):02907                         fcb     $86
                      (    rsdos_mmc.asm):02908         ; lset command
CFDF 4F               (    rsdos_mmc.asm):02909         CmdLset           clra                             ; lset flag = 0                        
CFE0 3402             (    rsdos_mmc.asm):02910                        pshs    a                        ; save rset($4f),lset(00) flag on the stack                                                 
CFE2 BDB357           (    rsdos_mmc.asm):02911                        jsr     VarGetVar                ; evaluate field string variable                                         
                      (    rsdos_mmc.asm):02912         
CFE5 BDB146           (    rsdos_mmc.asm):02913                        jsr     VarGetExpr               ; 'tm' error if numeric variable                                         
                      (    rsdos_mmc.asm):02914         
CFE8 3410             (    rsdos_mmc.asm):02915                        pshs    x                        ; save string descriptor on stack                                       
CFEA AE02             (    rsdos_mmc.asm):02916                        ldx     $02,x                    ; point x to address of string                                       
CFEC 8C0989           (    rsdos_mmc.asm):02917                        cmpx    #dflbuf                  ; compare string address to start of random                                                       
CFEF 2505             (    rsdos_mmc.asm):02918                        blo     ld119                    ; file buffer; 'se' error if < random file buffer                                                          
                      (    rsdos_mmc.asm):02919         
CFF1 BC094A           (    rsdos_mmc.asm):02920                        cmpx    fcbadr                   ; = compare string address to top of random file buffer                                                                  
CFF4 2505             (    rsdos_mmc.asm):02921                        blo     ld11e                    ; = area - branch if string in random file buffer                                                          
                      (    rsdos_mmc.asm):02922         
CFF6 C646             (    rsdos_mmc.asm):02923         ld119          ldb     #2*35                    ; 'set to non-fielded string' error                                                                           
CFF8 7EAC46           (    rsdos_mmc.asm):02924                        jmp     SysErr                   ; jump to error handler                                
                      (    rsdos_mmc.asm):02925         
CFFB C6B3             (    rsdos_mmc.asm):02926         ld11e          ldb     #$b3                     ;              
CFFD BDB26F           (    rsdos_mmc.asm):02927                        jsr     VarCKChar                ; syntax check for '=' token                                     
                      (    rsdos_mmc.asm):02928         
D000 BD8748           (    rsdos_mmc.asm):02929                        jsr     l8748                    ; =evaluate data string expression; return with x                                                          
                      (    rsdos_mmc.asm):02930         
                      (    rsdos_mmc.asm):02931                                                                                                                                                    ; =pointing to string; accb = length
D003 3520             (    rsdos_mmc.asm):02932                        puls    y                        ; point y to field string descriptor                                          
D005 A6A4             (    rsdos_mmc.asm):02933                        lda     ,y                       ; get length of field string                                  
D007 272E             (    rsdos_mmc.asm):02934                        beq     ld15a                    ; return if null string                                
                      (    rsdos_mmc.asm):02935         
D009 3404             (    rsdos_mmc.asm):02936                        pshs    b                        ; save length of data string on stack                                           
D00B C620             (    rsdos_mmc.asm):02937                        ldb     #space                   ; prepare to fill data string with blanks                                                   
D00D EE22             (    rsdos_mmc.asm):02938                        ldu     $02,y                    ; point u to field string address                                          
                      (    rsdos_mmc.asm):02939         ; fill the fielded string with blanks
D00F E7C0             (    rsdos_mmc.asm):02940         ld132          stb     ,u+                      ; store a space in fielded string                                             
D011 4A               (    rsdos_mmc.asm):02941                        deca                             ; decrement length counter                               
D012 26FB             (    rsdos_mmc.asm):02942                        bne     ld132                    ; keep filling w/spaces if not done                                            
                      (    rsdos_mmc.asm):02943         
D014 E6E0             (    rsdos_mmc.asm):02944                        ldb     ,s+                      ;get the length of the data string and                                             
D016 271F             (    rsdos_mmc.asm):02945                        beq     ld15a                    ;return if it is null (zero)                                     
                      (    rsdos_mmc.asm):02946         
D018 E1A4             (    rsdos_mmc.asm):02947                        cmpb    ,y                       ; =compare length of data string to length of field                                                          
D01A 2504             (    rsdos_mmc.asm):02948                        blo     ld143                    ; =string, branch if field string > data string                                                        
                      (    rsdos_mmc.asm):02949         
D01C E6A4             (    rsdos_mmc.asm):02950                        ldb     ,y                       ;get the length of the field string and force the                                                       
D01E 6FE4             (    rsdos_mmc.asm):02951                        clr     ,s                       ;rset/lset flag to lset (0) if data string length is                                                          
                      (    rsdos_mmc.asm):02952                                                         ;>= the field string length. this will cause the right
                      (    rsdos_mmc.asm):02953                                                         ;side of the data string to be truncated
D020 EE22             (    rsdos_mmc.asm):02954         ld143          ldu     $02,y                    ; load u with the address of the field string                                                           
D022 6DE0             (    rsdos_mmc.asm):02955                        tst     ,s+                      ; get the rset/lset flag from the stack                                              
D024 270E             (    rsdos_mmc.asm):02956                        beq     ld157                    ; and branch if lset                             
                      (    rsdos_mmc.asm):02957         
                      (    rsdos_mmc.asm):02958         ; rset routine
D026 3404             (    rsdos_mmc.asm):02959                        pshs    b                        ; save the number of bytes to move into the field string                                                              
D028 4F               (    rsdos_mmc.asm):02960                        clra                             ; = take the 2's complement of an unsigned                                               
D029 50               (    rsdos_mmc.asm):02961                        negb                             ; = number in accb - leave the double byte signed                                                      
D02A 8200             (    rsdos_mmc.asm):02962                        sbca    #$00                     ; = result in accd                           
D02C EBA4             (    rsdos_mmc.asm):02963                        addb    ,y                       ; add the length of the field string to the inverse                                                          
D02E 8900             (    rsdos_mmc.asm):02964                        adca    #$00                     ; of the number of bytes to be moved                                             
D030 33CB             (    rsdos_mmc.asm):02965                        leau    d,u                      ; =add result to start of field string. now u                                                     
                      (    rsdos_mmc.asm):02966                                                                                                                                                    ; =will point to (-number of bytes to move)
                      (    rsdos_mmc.asm):02967                                                                                                                                                    ;=from the right side of the field string
D032 3504             (    rsdos_mmc.asm):02968                        puls    b                        ; get the number of bytes to move                                       
D034 7EA59A           (    rsdos_mmc.asm):02969         ld157          jmp     UtilCopyBXtoU            ; move accb bytes from x to u (data to field string)                                                                  
                      (    rsdos_mmc.asm):02970         
D037 3582             (    rsdos_mmc.asm):02971         ld15a          puls    a,pc                     ; pull lset/rset flag off of stack and return                                                           
                      (    rsdos_mmc.asm):02972         
                      (    rsdos_mmc.asm):02973         ; files command
D039 BD95AC           (    rsdos_mmc.asm):02974         CmdFiles          jsr     TextResetVDU             ; reset sam display page and vdg mode                                                   
                      (    rsdos_mmc.asm):02975         
D03C FC094A           (    rsdos_mmc.asm):02976                        ldd     fcbadr                   ; get start of file buffers                                     
D03F 830989           (    rsdos_mmc.asm):02977                        subd    #dflbuf                  ; subtract the start of random file buffer space                                                            
D042 3406             (    rsdos_mmc.asm):02978                        pshs    b,a                      ; save default value of random file buffer space on stack                                                                 
D044 F6095B           (    rsdos_mmc.asm):02979                        ldb     fcbact                   ; get current number of fcbs                                      
D047 3404             (    rsdos_mmc.asm):02980                        pshs    b                        ; and save on the stack (default value)                                             
D049 9DA5             (    rsdos_mmc.asm):02981                        jsr     BasChrGetCurr            ; get current input char                                  
                      (    rsdos_mmc.asm):02982         
D04B 812C             (    rsdos_mmc.asm):02983                        cmpa    #',                      ; check for comma                          
D04D 270F             (    rsdos_mmc.asm):02984                        beq     ld181                    ; branch if comma - no buffer number parameter given                                                             
                      (    rsdos_mmc.asm):02985         
D04F BDB70B           (    rsdos_mmc.asm):02986                        jsr     VarGet8Bit               ; evaluate expression (buffer number)                                                 
                      (    rsdos_mmc.asm):02987         
D052 C10F             (    rsdos_mmc.asm):02988                        cmpb    #15                      ; 15 fcbs max                     
D054 1022E3F2         (    rsdos_mmc.asm):02989                        lbhi    BasFCError               ; branch if > 15 - 'illegal function call'                                                    
D058 E7E4             (    rsdos_mmc.asm):02990                        stb     ,s                       ; save number of fcbs on stack                                    
D05A 9DA5             (    rsdos_mmc.asm):02991                        jsr     BasChrGetCurr            ; check current input char                                    
                      (    rsdos_mmc.asm):02992         
D05C 2708             (    rsdos_mmc.asm):02993                        beq     ld189                    ; branch if end of line                                
                      (    rsdos_mmc.asm):02994         
D05E BDB26D           (    rsdos_mmc.asm):02995         ld181          jsr     VarCKComma               ; syntax check for comma                                         
                      (    rsdos_mmc.asm):02996         
D061 BDB3E6           (    rsdos_mmc.asm):02997                        jsr     lb3e6                    ; evaluate expression, return value in accd                                                    
                      (    rsdos_mmc.asm):02998         
D064 ED61             (    rsdos_mmc.asm):02999                        std     $01,s                    ; save random file buffer size on stack                                                
D066 BDC9C6           (    rsdos_mmc.asm):03000         ld189          jsr     DosCloseAllFiles                    ; close files                           
                      (    rsdos_mmc.asm):03001         
D069 E6E4             (    rsdos_mmc.asm):03002                        ldb     ,s                       ; get the number of buffers to make and                                             
D06B 3404             (    rsdos_mmc.asm):03003                        pshs    b                        ; initialize a buffer counter on the stack                                                
D06D CC0989           (    rsdos_mmc.asm):03004                        ldd     #dflbuf                  ; get start of random file buffers                                             
D070 E362             (    rsdos_mmc.asm):03005                        addd    $02,s                    ; add the newly specified random file buffer space                                                            
D072 2571             (    rsdos_mmc.asm):03006                        blo     ld208                    ; 'out of memory' error if > $ffff                                           
                      (    rsdos_mmc.asm):03007         
D074 ED62             (    rsdos_mmc.asm):03008                        std     $02,s                    ; save start of fcbs                             
                      (    rsdos_mmc.asm):03009                                                                                                                                                    ; reserve space for fcbs
D076 C30119           (    rsdos_mmc.asm):03010         ld199          addd    #fcblen                  ; fcblen required for each buffer                                                  
D079 256A             (    rsdos_mmc.asm):03011                        blo     ld208                    ; 'out of memory' error if > $ffff                                           
                      (    rsdos_mmc.asm):03012         
D07B 6AE4             (    rsdos_mmc.asm):03013                        dec     ,s                       ; decrement buffer counter                                
D07D 2AF7             (    rsdos_mmc.asm):03014                        bpl     ld199                    ;branch if not done - the bpl will set up one more buffer                                                                  
                      (    rsdos_mmc.asm):03015                                                         ;than the number requested. this extra buffer is the system buffer
                      (    rsdos_mmc.asm):03016                                                         ;and is located at the end of the normal fcbs. only system routines
                      (    rsdos_mmc.asm):03017                                                         ;(copy, backup, merge etc.) may access this buffer.
D07F 5D               (    rsdos_mmc.asm):03018                        tstb                             ; at an exact 256 byte boundary?                                     
D080 2703             (    rsdos_mmc.asm):03019                        beq     ld1a8                    ; yes              
                      (    rsdos_mmc.asm):03020         
D082 4C               (    rsdos_mmc.asm):03021                        inca                             ; no - add 256                   
D083 2760             (    rsdos_mmc.asm):03022                        beq     ld208                    ; 'out of memory' error if past $ffff                                              
                      (    rsdos_mmc.asm):03023         
D085 8501             (    rsdos_mmc.asm):03024         ld1a8          bita    #$01                     ; on a 512 byte boundary?                                       
D087 2703             (    rsdos_mmc.asm):03025                        beq     ld1af                    ; yes              
                      (    rsdos_mmc.asm):03026         
D089 4C               (    rsdos_mmc.asm):03027                        inca                             ; no - add 256                   
D08A 2759             (    rsdos_mmc.asm):03028                        beq     ld208                    ; 'om' error if past $ffff                                   
                      (    rsdos_mmc.asm):03029         
D08C A7E4             (    rsdos_mmc.asm):03030         ld1af          sta     ,s                       ; save ms byte of new graphic ram start                                                  
D08E DC1B             (    rsdos_mmc.asm):03031                        ldd     BasVarSimpleAddr         ; get start of variables                                  
D090 90BC             (    rsdos_mmc.asm):03032                        suba    GrStartPages             ;subtract the old graphic ram start - accd contains length                                                                     
                      (    rsdos_mmc.asm):03033                                                         ;of program plus reserved graphic ram
D092 ABE4             (    rsdos_mmc.asm):03034                        adda    ,s                       ; add in the amount of ram calculated above                                                  
D094 254F             (    rsdos_mmc.asm):03035                        blo     ld208                    ; 'out of memory' error if > $ffff                                           
                      (    rsdos_mmc.asm):03036         
D096 1F01             (    rsdos_mmc.asm):03037                        tfr     d,x                      ; save new vartab in x                             
D098 4C               (    rsdos_mmc.asm):03038                        inca                             ;add 256 - to guarantee enough room since all calculations use                                                                   
                      (    rsdos_mmc.asm):03039                                                         ;only the msb of the address
D099 274A             (    rsdos_mmc.asm):03040                        beq     ld208                    ; 'out of memory' error if past $ffff                                              
                      (    rsdos_mmc.asm):03041         
D09B 109321           (    rsdos_mmc.asm):03042                        cmpd    BasVarStringBase         ; is it greater than the start of string space                                                         
D09E 2445             (    rsdos_mmc.asm):03043                        bhs     ld208                    ; 'out of memory' if > start of string space                                                     
                      (    rsdos_mmc.asm):03044         
D0A0 4A               (    rsdos_mmc.asm):03045                        deca                             ; subtract 256 - compensate for inca above                                               
D0A1 931B             (    rsdos_mmc.asm):03046                        subd    BasVarSimpleAddr         ; subtract start of variables                                        
D0A3 D319             (    rsdos_mmc.asm):03047                        addd    BasStartProg             ; add start of basic                               
D0A5 1F02             (    rsdos_mmc.asm):03048                        tfr     d,y                      ; y has new start of basic                                 
D0A7 A6E4             (    rsdos_mmc.asm):03049                        lda     ,s                       ; get the graphic ram start, subtract                                           
D0A9 90BC             (    rsdos_mmc.asm):03050                        suba    GrStartPages             ; the old graphic ran start and save                                               
D0AB 1F89             (    rsdos_mmc.asm):03051                        tfr     a,b                      ; the difference in acca and accb                                        
D0AD 9BBA             (    rsdos_mmc.asm):03052                        adda    GrDisplayStartAddr       ; = add the old graphic page start and                                                 
D0AF 97BA             (    rsdos_mmc.asm):03053                        sta     GrDisplayStartAddr       ; = store the new start of graphics ram                                                 
D0B1 DBB7             (    rsdos_mmc.asm):03054                        addb    GrLastDisplayAddr        ; add the old graphic ram end address and                                                    
D0B3 D7B7             (    rsdos_mmc.asm):03055                        stb     GrLastDisplayAddr        ; store the new end of graphics ram                                             
D0B5 3546             (    rsdos_mmc.asm):03056                        puls    a,b,u                    ; = acca=msb of start of graphic ram; accb=number of file buffers                                                                           
                      (    rsdos_mmc.asm):03057                                                                                                                                                    ; = u=start of file buffers
D0B7 97BC             (    rsdos_mmc.asm):03058                        sta     GrStartPages             ; save new start of graphic ram                                         
D0B9 F7095B           (    rsdos_mmc.asm):03059                        stb     fcbact                   ; number of file buffers                                  
D0BC FF094A           (    rsdos_mmc.asm):03060                        stu     fcbadr                   ; start of file buffers                                 
D0BF 9668             (    rsdos_mmc.asm):03061                        lda     BasCurrentLine           ; get current line number                                   
D0C1 4C               (    rsdos_mmc.asm):03062                        inca                             ; are we in direct mode?                             
D0C2 2708             (    rsdos_mmc.asm):03063                        beq     ld1ef                    ; yes - move basic program                                   
                      (    rsdos_mmc.asm):03064         
D0C4 1F20             (    rsdos_mmc.asm):03065                        tfr     y,d                      ; move new start of basic to accd                                        
D0C6 9319             (    rsdos_mmc.asm):03066                        subd    BasStartProg             ; subtract old start of basic                                        
D0C8 D3A6             (    rsdos_mmc.asm):03067                        addd    BasAddrSigByte           ; add old input pointer                                  
D0CA DDA6             (    rsdos_mmc.asm):03068                        std     BasAddrSigByte           ; save new input pointer                                  
D0CC DE1B             (    rsdos_mmc.asm):03069         ld1ef          ldu     BasVarSimpleAddr         ; point u to old start of variables                                                  
D0CE 9F1B             (    rsdos_mmc.asm):03070                        stx     BasVarSimpleAddr         ; save new start of varibles                                      
D0D0 11931B           (    rsdos_mmc.asm):03071                        cmpu    BasVarSimpleAddr         ; compare old start of variables to new start of                                                           
D0D3 2213             (    rsdos_mmc.asm):03072                        bhi     ld20b                    ; variables & branch if old > new                                          
                      (    rsdos_mmc.asm):03073         ; move basic program if old start address <= new start address
D0D5 A6C2             (    rsdos_mmc.asm):03074         ld1f8          lda     ,-u                      ; get a byte                        
D0D7 A782             (    rsdos_mmc.asm):03075                        sta     ,-x                      ; move lt                
D0D9 119319           (    rsdos_mmc.asm):03076                        cmpu    BasStartProg             ; at start of basic program?                                       
D0DC 26F7             (    rsdos_mmc.asm):03077                        bne     ld1f8                    ; no             
                      (    rsdos_mmc.asm):03078         
D0DE 109F19           (    rsdos_mmc.asm):03079                        sty     BasStartProg             ; store new start of basic program                                            
D0E1 6F3F             (    rsdos_mmc.asm):03080                        clr     -1,y                     ; reset start of program flag                                     
D0E3 2013             (    rsdos_mmc.asm):03081                        bra     ld21b                    ; close all files                          
D0E5 7EAC44           (    rsdos_mmc.asm):03082         ld208          jmp     BasOMError               ; 'out of memory' error                                     
                      (    rsdos_mmc.asm):03083         
                      (    rsdos_mmc.asm):03084         ; move basic program if old start address > new start address
D0E8 DE19             (    rsdos_mmc.asm):03085         ld20b          ldu     BasStartProg             ; point u to old start of basic                                              
D0EA 109F19           (    rsdos_mmc.asm):03086                        sty     BasStartProg             ; save new start of basic                                   
D0ED 6F3F             (    rsdos_mmc.asm):03087                        clr     -1,y                     ; reset start of basic flag                                   
D0EF A6C0             (    rsdos_mmc.asm):03088         ld212          lda     ,u+                      ; get a byte                        
D0F1 A7A0             (    rsdos_mmc.asm):03089                        sta     ,y+                      ; move it                
D0F3 109C1B           (    rsdos_mmc.asm):03090                        cmpy    BasVarSimpleAddr         ; at start of variables                                  
D0F6 26F7             (    rsdos_mmc.asm):03091                        bne     ld212                    ; no - move another byte                                 
                      (    rsdos_mmc.asm):03092         
                      (    rsdos_mmc.asm):03093         
                      (    rsdos_mmc.asm):03094         ; close all fcbs and recalculate fcb start addresses
D0F8 CE0928           (    rsdos_mmc.asm):03095         ld21b          ldu     #fcbv1                   ; point u to file buffer pointers                                                
D0FB BE094A           (    rsdos_mmc.asm):03096                        ldx     fcbadr                   ; point x to start of buffers                                       
D0FE 5F               (    rsdos_mmc.asm):03097                        clrb                             ; reset file counter                         
D0FF AFC1             (    rsdos_mmc.asm):03098         ld222          stx     ,u++                     ; store file address in vector table                                                 
D101 6F84             (    rsdos_mmc.asm):03099                        clr     fcbtyp,x                 ; reset file type to closed                                       
D103 30890119         (    rsdos_mmc.asm):03100                        leax    fcblen,x                 ; go to next fcb                             
D107 5C               (    rsdos_mmc.asm):03101                        incb                             ; increment file counter                             
D108 F1095B           (    rsdos_mmc.asm):03102                        cmpb    fcbact                   ; close all active buffers and system fcb                                                    
D10B 23F2             (    rsdos_mmc.asm):03103                        bls     ld222                    ; branch if not done                             
                      (    rsdos_mmc.asm):03104         
D10D 7E96CB           (    rsdos_mmc.asm):03105                        jmp     l96cb                    ; readjust line numbers, etc.                                      
                      (    rsdos_mmc.asm):03106         
                      (    rsdos_mmc.asm):03107         
                      (    rsdos_mmc.asm):03108         ; unload command
D110 8D1A             (    rsdos_mmc.asm):03109         CmdUnload      bsr     GetDriveNoInB            ; get drive number                                 
                      (    rsdos_mmc.asm):03110         
D112 5F               (    rsdos_mmc.asm):03111                        clrb                             ; clear file counter                         
D113 5C               (    rsdos_mmc.asm):03112         ld236          incb                             ; increment file counter                                  
D114 BDC626           (    rsdos_mmc.asm):03113                        jsr     >lc749                   ; point x to fcb                         
                      (    rsdos_mmc.asm):03114         
D117 270D             (    rsdos_mmc.asm):03115                        beq     ld249                    ; branch if file not open                                  
                      (    rsdos_mmc.asm):03116         
D119 A601             (    rsdos_mmc.asm):03117                        lda     fcbdrv,x                 ; check drive number                                
D11B 91EB             (    rsdos_mmc.asm):03118                        cmpa    dcdrv                    ; does it match the 'unload' drive number?                                                    
D11D 2607             (    rsdos_mmc.asm):03119                        bne     ld249                    ; no match - do not close the file                                           
                      (    rsdos_mmc.asm):03120         
D11F 3404             (    rsdos_mmc.asm):03121                        pshs    b                        ; save file counter on the stack                                      
D121 BDC9E3           (    rsdos_mmc.asm):03122                        jsr     >lcb06                   ; close fcb                    
                      (    rsdos_mmc.asm):03123         
D124 3504             (    rsdos_mmc.asm):03124                        puls    b                        ; restore file counter                            
D126 F1095B           (    rsdos_mmc.asm):03125         ld249          cmpb    fcbact                   ; checked all files?                                    
D129 23E8             (    rsdos_mmc.asm):03126                        bls     ld236                    ; no             
                      (    rsdos_mmc.asm):03127         
D12B 39               (    rsdos_mmc.asm):03128                        rts                                     
                      (    rsdos_mmc.asm):03129         
                      (    rsdos_mmc.asm):03130         ; get drive number from basic - use the default drive if none given
D12C F6095A           (    rsdos_mmc.asm):03131         GetDriveNoInB  ldb     defdrv                   ; get default drive number                                         
D12F 9DA5             (    rsdos_mmc.asm):03132                        jsr     BasChrGetCurr            ; get next input char                               
                      (    rsdos_mmc.asm):03133         
D131 2709             (    rsdos_mmc.asm):03134                        beq     ld25f                    ; use default drive number if none given                                                 
                      (    rsdos_mmc.asm):03135         
D133 BDB70B           (    rsdos_mmc.asm):03136         ld256          jsr     VarGet8Bit               ; evaluate expression                                      
                      (    rsdos_mmc.asm):03137         
D136 C103             (    rsdos_mmc.asm):03138                        cmpb    #$03                     ; 4 drives max                       
D138 1022D4E3         (    rsdos_mmc.asm):03139                        lbhi    la61f                    ; 'device number error' if > 3                                        
D13C D7EB             (    rsdos_mmc.asm):03140         ld25f          stb     dcdrv                    ; store in dskcon variable                                        
D13E 39               (    rsdos_mmc.asm):03141                        rts                                     
                      (    rsdos_mmc.asm):03142         
                      (    rsdos_mmc.asm):03143         
                      (    rsdos_mmc.asm):03144         ; backup command
D13F 1027D4DC         (    rsdos_mmc.asm):03145         CmdBackup         lbeq    la61f                    ; device number error if no drive numbers given                                                               
                      (    rsdos_mmc.asm):03146         
D143 BD95AC           (    rsdos_mmc.asm):03147                        jsr     TextResetVDU             ; reset sam display page and vog mode                                              
                      (    rsdos_mmc.asm):03148         
D146 BDD133           (    rsdos_mmc.asm):03149                        jsr     >ld256                   ; get source drive number and save                                           
                      (    rsdos_mmc.asm):03150         
D149 F706FF           (    rsdos_mmc.asm):03151                        stb     dbuf0+255                ; it at top of dbuf0 (top of new stack)                                                    
D14C 9DA5             (    rsdos_mmc.asm):03152                        jsr     BasChrGetCurr            ; get a character from basic                                      
                      (    rsdos_mmc.asm):03153         
D14E 2708             (    rsdos_mmc.asm):03154                        beq     ld27b                    ; branch if end of line                                
                      (    rsdos_mmc.asm):03155         
D150 C6A5             (    rsdos_mmc.asm):03156                        ldb     #$a5                     ; token for 'to'                        
D152 BDB26F           (    rsdos_mmc.asm):03157                        jsr     VarCKChar                ; syntax check for 'to'                                
                      (    rsdos_mmc.asm):03158         
D155 BDD133           (    rsdos_mmc.asm):03159                        jsr     >ld256                   ; get destination drive number                                       
                      (    rsdos_mmc.asm):03160         
D158 10CE06FF         (    rsdos_mmc.asm):03161         ld27b          lds     #dbuf0+255               ; put stack at top of dbuf0                                              
D15C 3404             (    rsdos_mmc.asm):03162                        pshs    b                        ; save destination drive number on stack                                              
D15E BDA5C7           (    rsdos_mmc.asm):03163                        jsr     la5c7                    ; syntax error if not end of line                                          
                      (    rsdos_mmc.asm):03164         
D161 BDC9C6           (    rsdos_mmc.asm):03165                        jsr     DosCloseAllFiles                    ; close all files                          
                      (    rsdos_mmc.asm):03166         
D164 6FE2             (    rsdos_mmc.asm):03167                        clr     ,-s                      ; clear a track counter on stack                                       
D166 8E0988           (    rsdos_mmc.asm):03168                        ldx     #dflbuf-1                ; point x to top of disk ram variables                                                   
D169 6CE4             (    rsdos_mmc.asm):03169         ld28c          inc     ,s                       ; increment track counter                                    
D16B 30891200         (    rsdos_mmc.asm):03170                        leax    secmax*seclen,x          ; increment x by one track                                                                    
D16F 9C27             (    rsdos_mmc.asm):03171                        cmpx    AddrFWareRamTop          ; compare to top of non reserved ran                                               
D171 23F6             (    rsdos_mmc.asm):03172                        bls     ld28c                    ; keep going if more free ram left                                           
                      (    rsdos_mmc.asm):03173         
D173 6AE4             (    rsdos_mmc.asm):03174                        dec     ,s                       ; decrement track counter                               
D175 1027DACB         (    rsdos_mmc.asm):03175                        lbeq    BasOMError               ; 'om' error if < 1 track of free ram                                               
                      (    rsdos_mmc.asm):03176         
D179 8623             (    rsdos_mmc.asm):03177                        lda     #trkmax                  ; get maximum number of tracks - initialize remaining tracks ctr                                                                           
D17B 5F               (    rsdos_mmc.asm):03178                        clrb                             ; initialize tracks written counter to zero                                                
D17C 3406             (    rsdos_mmc.asm):03179                        pshs    b,a                      ; save tracks written and remaining counters on stack                                                             
                      (    rsdos_mmc.asm):03180         
                      (    rsdos_mmc.asm):03181         ; at this point the stack has the following data on it:
                      (    rsdos_mmc.asm):03182         ; ,s = tracks remaining counter; 1,s = tracks written counter
                      (    rsdos_mmc.asm):03183         ; 2,s = number of tracks which fit in ram; 3,s = destination drive number
                      (    rsdos_mmc.asm):03184         ; 4,s = source drive number
D17E 73095C           (    rsdos_mmc.asm):03185                        com     dresfl                   ; set the disk reset flag to cause a reset                                                    
D181 5F               (    rsdos_mmc.asm):03186         ld2a4          clrb                             ; initialize write track counter to zero                                                  
D182 5C               (    rsdos_mmc.asm):03187         ld2a5          incb                             ; add one to write track counter                                          
D183 6AE4             (    rsdos_mmc.asm):03188                        dec     ,s                       ; decrement remaining tracks counter                                          
D185 2704             (    rsdos_mmc.asm):03189                        beq     ld2ae                    ; and branch if no tracks left                                       
                      (    rsdos_mmc.asm):03190         
D187 E162             (    rsdos_mmc.asm):03191                        cmpb    $02,s                    ; = compare write track counter to number of tracks that                                                                  
D189 26F7             (    rsdos_mmc.asm):03192                        bne     ld2a5                    ; = will fit in ram and branch if room for more tracks in ram                                                                      
                      (    rsdos_mmc.asm):03193         
D18B D703             (    rsdos_mmc.asm):03194         ld2ae          stb     BasGenCount              ; save the number of tracks to be transferred                                                            
D18D E664             (    rsdos_mmc.asm):03195                        ldb     $04,s                    ; get source drive number                                  
D18F 8D48             (    rsdos_mmc.asm):03196                        bsr     ld2fc                    ; fill ram buffer with BasGenCount tracks of data                                                     
                      (    rsdos_mmc.asm):03197         
D191 86FF             (    rsdos_mmc.asm):03198                        lda     #$ff                     ; set source/destination flag to destination                                                    
D193 BDD1FF           (    rsdos_mmc.asm):03199                        jsr     >ld322                   ; print prompt message if needed                                         
                      (    rsdos_mmc.asm):03200         
D196 E663             (    rsdos_mmc.asm):03201                        ldb     $03,s                    ; get destination drive number                                       
D198 8D42             (    rsdos_mmc.asm):03202                        bsr     ld2ff                    ; write BasGenCount tracks from buffer                                          
                      (    rsdos_mmc.asm):03203         
D19A 6DE4             (    rsdos_mmc.asm):03204                        tst     ,s                       ; test tracks remaining flag                                  
D19C 270C             (    rsdos_mmc.asm):03205                        beq     ld2cd                    ; branch if backup done                                
                      (    rsdos_mmc.asm):03206         
D19E 4F               (    rsdos_mmc.asm):03207                        clra                             ; set source/destination flag to source                                            
D19F BDD1FF           (    rsdos_mmc.asm):03208                        jsr     >ld322                   ; print prompt message if needed                                         
                      (    rsdos_mmc.asm):03209         
D1A2 E661             (    rsdos_mmc.asm):03210                        ldb     $01,s                    ; get the tracks written counter, add the number of                                                            
D1A4 DB03             (    rsdos_mmc.asm):03211                        addb    BasGenCount              ; tracks moved this time through loop and                                                    
D1A6 E761             (    rsdos_mmc.asm):03212                        stb     $01,s                    ; save the new tracks written counter                                              
D1A8 20D7             (    rsdos_mmc.asm):03213                        bra     ld2a4                    ; copy some more tracks                                
                      (    rsdos_mmc.asm):03214         
D1AA 8D03             (    rsdos_mmc.asm):03215         ld2cd          bsr     CloseFilesInit2          ; check for dos initialization                                            
                      (    rsdos_mmc.asm):03216         
D1AC 7EAC73           (    rsdos_mmc.asm):03217                        jmp     BasCmdMode               ; jump back to basic's main loop                                         
                      (    rsdos_mmc.asm):03218         
                      (    rsdos_mmc.asm):03219         
D1AF                  (    rsdos_mmc.asm):03220         CloseFilesInit2          
D1AF 3540             (    rsdos_mmc.asm):03221                        puls    u                        ; put the return address in u                                        
D1B1 B6095C           (    rsdos_mmc.asm):03222                        lda     dresfl                   ; test disk reset flag                                
D1B4 2716             (    rsdos_mmc.asm):03223                        beq     ld2ef                    ; don't reset the dos if flag not set                                              
                      (    rsdos_mmc.asm):03224         
D1B6 8E0928           (    rsdos_mmc.asm):03225                        ldx     #fcbv1                   ; point x to table of fcb addresses                                             
D1B9 4F               (    rsdos_mmc.asm):03226                        clra                             ; set file counter to zero                               
D1BA 6F91             (    rsdos_mmc.asm):03227         ld2dd          clr     [,x++]                   ; mark fcb as closed                                   
D1BC 4C               (    rsdos_mmc.asm):03228                        inca                             ; add one to file counter                              
D1BD B1095B           (    rsdos_mmc.asm):03229                        cmpa    fcbact                   ; compare to number of reserved files                                                
D1C0 23F8             (    rsdos_mmc.asm):03230                        bls     ld2dd                    ; branch if any files not shut down                                            
                      (    rsdos_mmc.asm):03231         
D1C2 9E19             (    rsdos_mmc.asm):03232                        ldx     BasStartProg             ; load x with the start of basic                                          
D1C4 6F1F             (    rsdos_mmc.asm):03233                        clr     -1,x                     ; set first byte of basic program to zero                                                 
D1C6 BDAD19           (    rsdos_mmc.asm):03234                        jsr     BasNew                   ; go do a 'new'                        
                      (    rsdos_mmc.asm):03235         
D1C9 7F095C           (    rsdos_mmc.asm):03236                        clr     dresfl                   ; reset the dos reset flag                                    
D1CC B6095D           (    rsdos_mmc.asm):03237         ld2ef          lda     dloadfl                  ; check the load reset flag and                                              
D1CF 2706             (    rsdos_mmc.asm):03238                        beq     ld2fa                    ; branch if not set                            
                      (    rsdos_mmc.asm):03239         
D1D1 7F095D           (    rsdos_mmc.asm):03240                        clr     dloadfl                  ; clear the load reset flag                                     
D1D4 BDAD19           (    rsdos_mmc.asm):03241                        jsr     BasNew                   ; go do a 'new'                        
                      (    rsdos_mmc.asm):03242         
D1D7 6EC4             (    rsdos_mmc.asm):03243         ld2fa          jmp     ,u                       ; jump back to return address saved in u above                                                         
                      (    rsdos_mmc.asm):03244         
                      (    rsdos_mmc.asm):03245         
D1D9 8602             (    rsdos_mmc.asm):03246         ld2fc          lda     #$02                     ; read op code                           
D1DB 8C               (    rsdos_mmc.asm):03247                        fcb      Skip2                   ; cmpx
D1DC 8603             (    rsdos_mmc.asm):03248         ld2ff          lda     #$03                     ; write op code                            
D1DE DDEA             (    rsdos_mmc.asm):03249                        std     dcopc                    ; save in dskcon variable                                  
D1E0 A663             (    rsdos_mmc.asm):03250                        lda     $03,s                    ; get the number of the track being currently                                                      
D1E2 97EC             (    rsdos_mmc.asm):03251                        sta     dctrk                    ; written and save it in dskcon variable                                                 
D1E4 8E0989           (    rsdos_mmc.asm):03252                        ldx     #dflbuf                  ; = track buffer starts at dflbuf                                            
D1E7 9FEE             (    rsdos_mmc.asm):03253                        stx     dcbpt                    ; = save it in dskcon variable                                       
D1E9 9603             (    rsdos_mmc.asm):03254                        lda     BasGenCount              ; get number of tracks to move                                        
D1EB C601             (    rsdos_mmc.asm):03255         ld30e          ldb     #$01                     ; initialize sector counter to one                                               
D1ED D7ED             (    rsdos_mmc.asm):03256         ld310          stb     dsec                     ; save dskcon sector variable                                          
D1EF BDD4B5           (    rsdos_mmc.asm):03257                        jsr     >DoDiskReadWrite                   ; read/write a sector                              
                      (    rsdos_mmc.asm):03258         
D1F2 0CEE             (    rsdos_mmc.asm):03259                        inc     dcbpt                    ; move buffer pointer up one sector (256 bytes)                                                        
D1F4 5C               (    rsdos_mmc.asm):03260                        incb                             ; increment sector counter                               
D1F5 C112             (    rsdos_mmc.asm):03261                        cmpb    #secmax                  ; compare to maximum number of sectors per track                                                            
D1F7 23F4             (    rsdos_mmc.asm):03262                        bls     ld310                    ; branch if any sectors left                                     
                      (    rsdos_mmc.asm):03263         
D1F9 0CEC             (    rsdos_mmc.asm):03264                        inc     dctrk                    ; increment track counter variable to next track                                                         
D1FB 4A               (    rsdos_mmc.asm):03265                        deca                             ; decrement tracks to move counter                                       
D1FC 26ED             (    rsdos_mmc.asm):03266                        bne     ld30e                    ; read more tracks if any left                                       
                      (    rsdos_mmc.asm):03267         
D1FE 39               (    rsdos_mmc.asm):03268                        rts                                     
                      (    rsdos_mmc.asm):03269         
                      (    rsdos_mmc.asm):03270         
D1FF E665             (    rsdos_mmc.asm):03271         ld322          ldb     $05,s                    ; get the destinatlon drive number and                                                    
D201 E166             (    rsdos_mmc.asm):03272                        cmpb    $06,s                    ; compare it to the source drive number                                                 
                      (    rsdos_mmc.asm):03273         
                      (    rsdos_mmc.asm):03274         ; print source/destination disk switch prompt message
D203 2636             (    rsdos_mmc.asm):03275         ld326          bne     ld35e                    ; return if drive numbers not equal                                                 
                      (    rsdos_mmc.asm):03276         
D205 7F0985           (    rsdos_mmc.asm):03277                        clr     rdytmr                   ; reset the ready timer                                 
D208 7FFF40           (    rsdos_mmc.asm):03278                        clr     dskreg                   ; clear dskreg - turn off all disk motors                                                   
D20B 7F0986           (    rsdos_mmc.asm):03279                        clr     drgram                   ; clear dskreg ram image                                  
D20E 3402             (    rsdos_mmc.asm):03280                        pshs    a                        ; save source/destination flag on stack                                             
D210 BDA928           (    rsdos_mmc.asm):03281                        jsr     TextCls                  ; clear screen                       
                      (    rsdos_mmc.asm):03282         
D213 8ED23C           (    rsdos_mmc.asm):03283                        ldx     #ld35f                   ; point x to 'insert source' message                                              
D216 C60D             (    rsdos_mmc.asm):03284                        ldb     #13                      ; 13 bytes in message                            
D218 A6E0             (    rsdos_mmc.asm):03285                        lda     ,s+                      ; get source/destination flag from the stack                                                   
D21A 2705             (    rsdos_mmc.asm):03286                        beq     ld344                    ; branch if source                           
                      (    rsdos_mmc.asm):03287         
D21C 8ED249           (    rsdos_mmc.asm):03288                        ldx     #ld36c                   ; point x to 'insert destination' message                                                   
D21F C612             (    rsdos_mmc.asm):03289                        ldb     #18                      ; 18 bytes in message                            
D221 BDB9A2           (    rsdos_mmc.asm):03290         ld344          jsr     lb9a2                    ; send message to console out                                           
                      (    rsdos_mmc.asm):03291         
D224 8ED25B           (    rsdos_mmc.asm):03292                        ldx     #ld37e                   ; point x to 'diskette and' message                                             
D227 C61B             (    rsdos_mmc.asm):03293                        ldb     #27                      ; 27 bytes in message                            
D229 BDB9A2           (    rsdos_mmc.asm):03294                        jsr     lb9a2                    ; send message to console out                                      
                      (    rsdos_mmc.asm):03295         
D22C CC6405           (    rsdos_mmc.asm):03296                        ldd     #$6405                   ; set up 'sound' parameters                                     
D22F 978C             (    rsdos_mmc.asm):03297                        sta     SndPitch                 ; for a beep                      
D231 BDA951           (    rsdos_mmc.asm):03298                        jsr     SndBeep                  ; jump to 'sound' - do a beep                                      
                      (    rsdos_mmc.asm):03299         
D234 BDA171           (    rsdos_mmc.asm):03300         ld357          jsr     TextWaitKeyCurs2         ; get a character from console in                                               
                      (    rsdos_mmc.asm):03301         
D237 810D             (    rsdos_mmc.asm):03302                        cmpa    #cr                      ; keep looking at console in until                                          
D239 26F9             (    rsdos_mmc.asm):03303                        bne     ld357                    ; you get a carriage return                                    
                      (    rsdos_mmc.asm):03304         
D23B 39               (    rsdos_mmc.asm):03305         ld35e          rts                                          
                      (    rsdos_mmc.asm):03306         
                      (    rsdos_mmc.asm):03307         
D23C 494E534552542053 (    rsdos_mmc.asm):03308         ld35f          fcc     'INSERT SOURCE'                         
     4F55524345
D249 494E534552542044 (    rsdos_mmc.asm):03309         ld36c          fcc     'INSERT DESTINATION'                              
     455354494E415449
     4F4E
D25B 204449534B455454 (    rsdos_mmc.asm):03310         ld37e          fcc     ' DISKETTE AND'                         
     4520414E44
D268 0D               (    rsdos_mmc.asm):03311                        fcb     cr                                
D269 505245535320     (    rsdos_mmc.asm):03312                        fcc     'PRESS '
D26F 27               (    rsdos_mmc.asm):03313                        fcb      '''
D270 454E544552       (    rsdos_mmc.asm):03314                        fcc      'ENTER'
D275 27               (    rsdos_mmc.asm):03315                        fcb      '''
                      (    rsdos_mmc.asm):03316         
                      (    rsdos_mmc.asm):03317         ; push filename.ext and drive number onto the stack
D276 3520             (    rsdos_mmc.asm):03318         ld399          puls    y                        ; save return address in y                                     
D278 C60B             (    rsdos_mmc.asm):03319                        ldb     #11                      ; 11 characters in filename and extension                                                
D27A 8E0957           (    rsdos_mmc.asm):03320                        ldx     #dnambf+11               ; point x to top of disk name/ext buffer                                                      
D27D A682             (    rsdos_mmc.asm):03321         ld3a0          lda     ,-x                      ; get a character from filename.                                            
D27F 3402             (    rsdos_mmc.asm):03322                        pshs    a                        ; ext buffer and push it onto the                                       
D281 5A               (    rsdos_mmc.asm):03323                        decb                             ; stack - decrement counter and                                    
D282 26F9             (    rsdos_mmc.asm):03324                        bne     ld3a0                    ; keep looping until done                                  
                      (    rsdos_mmc.asm):03325         
D284 96EB             (    rsdos_mmc.asm):03326                        lda     dcdrv                    ; = get drive number and push                                      
D286 3402             (    rsdos_mmc.asm):03327                        pshs    a                        ; = it onto the stack                           
D288 6EA4             (    rsdos_mmc.asm):03328                        jmp     ,y                       ; pseudo - return to calling routine                                          
                      (    rsdos_mmc.asm):03329         
                      (    rsdos_mmc.asm):03330         
                      (    rsdos_mmc.asm):03331         ; pull filename.ext and drive number from (x) to ram
D28A A680             (    rsdos_mmc.asm):03332         ld3ad          lda     ,x+                      ; get drive number and save                                       
D28C 97EB             (    rsdos_mmc.asm):03333                        sta     dcdrv                    ; it in dskcon variable                                
D28E C60B             (    rsdos_mmc.asm):03334                        ldb     #11                      ; 11 bytes in filename and extension                                           
D290 CE094C           (    rsdos_mmc.asm):03335                        ldu     #dnambf                  ; point u to disk name buffer                                        
D293 7EA59A           (    rsdos_mmc.asm):03336                        jmp     UtilCopyBXtoU            ; move filenane.ext from (x) to dnambf                                               
                      (    rsdos_mmc.asm):03337         
                      (    rsdos_mmc.asm):03338         
                      (    rsdos_mmc.asm):03339         ; copy
                      (    rsdos_mmc.asm):03340         ; the copy process is performed by copying data from the source file
                      (    rsdos_mmc.asm):03341         ; to ram and then copying it to the destination file. the source and
                      (    rsdos_mmc.asm):03342         ; destination files are opened as random files and both use the system
                      (    rsdos_mmc.asm):03343         ; fcb above the reserved fcbs. all of available free ram above the
                      (    rsdos_mmc.asm):03344         ; variables is used as a copy buffer which speeds up the copying process
                      (    rsdos_mmc.asm):03345         ; but unfortunately the method used will allow an error encountered during
                      (    rsdos_mmc.asm):03346         ; the copy process to 'hang' the system. this is caused by pointing the fcb's
                      (    rsdos_mmc.asm):03347         ; random file buffer pointer (fcbbuf,x) to the free ram buffer. an error
                      (    rsdos_mmc.asm):03348         ; will then cause the open file to be closed with fcbbuf,x pointing to an
                      (    rsdos_mmc.asm):03349         ; area in ram where the random file buffer close routine (lcae2) will never
                      (    rsdos_mmc.asm):03350         ; look for it
D296 BDC812           (    rsdos_mmc.asm):03351         CmdCopy           jsr     >lc935                   ; get source filename.ext & drive number from basic                                                                
                      (    rsdos_mmc.asm):03352         
D299 8DDB             (    rsdos_mmc.asm):03353                        bsr     ld399                    ; and save them on the stack                                     
                      (    rsdos_mmc.asm):03354         
D29B 6FE2             (    rsdos_mmc.asm):03355                        clr     ,-s                      ; clear a byte on stack - single disk copy (sdc) flag                                                            
D29D 9DA5             (    rsdos_mmc.asm):03356                        jsr     BasChrGetCurr            ; get current input character                                       
                      (    rsdos_mmc.asm):03357         
D29F 270A             (    rsdos_mmc.asm):03358                        beq     ld3ce                    ; branch if end of line - single disk copy                                                   
                      (    rsdos_mmc.asm):03359         
D2A1 63E4             (    rsdos_mmc.asm):03360                        com     ,s                       ; set soc flag to $ff (no single disk copy)                                                 
D2A3 C6A5             (    rsdos_mmc.asm):03361                        ldb     #$a5                     ; token for 'to'                        
D2A5 BDB26F           (    rsdos_mmc.asm):03362                        jsr     VarCKChar                ; syntax check for 'to'                                
                      (    rsdos_mmc.asm):03363         
D2A8 BDC812           (    rsdos_mmc.asm):03364                        jsr     >lc935                   ; get destination filename.ext and drive number                                                        
                      (    rsdos_mmc.asm):03365         
D2AB 8DC9             (    rsdos_mmc.asm):03366         ld3ce          bsr     ld399                    ; save destination filename.ext & drive number on stack                                                                     
                      (    rsdos_mmc.asm):03367         
D2AD BDA5C7           (    rsdos_mmc.asm):03368                        jsr     la5c7                    ; syntax error if more characters on line                                                  
                      (    rsdos_mmc.asm):03369         
D2B0 BDC9C6           (    rsdos_mmc.asm):03370                        jsr     DosCloseAllFiles                    ; close all files                          
                      (    rsdos_mmc.asm):03371         
                      (    rsdos_mmc.asm):03372         
                      (    rsdos_mmc.asm):03373         ; count the number of sectors worth of free ram available
D2B3 6FE2             (    rsdos_mmc.asm):03374                        clr     ,-s                      ; clear a sector counter on the stack                                            
D2B5 30E9FF00         (    rsdos_mmc.asm):03375                        leax    -seclen,s                ; point x one sector length down from the top of stack                                                                    
D2B9 6CE4             (    rsdos_mmc.asm):03376         ld3dc          inc     ,s                       ; increment sector counter                                     
D2BB 3089FF00         (    rsdos_mmc.asm):03377                        leax    -seclen,x                ; decrement x by one sector                                         
D2BF 9C1F             (    rsdos_mmc.asm):03378                        cmpx    BasVarEnd                ; compare to top of arrays                                     
D2C1 24F6             (    rsdos_mmc.asm):03379                        bhs     ld3dc                    ; branch if not at bottom of free ram                                              
                      (    rsdos_mmc.asm):03380         
D2C3 6AE4             (    rsdos_mmc.asm):03381                        dec     ,s                       ; decrement sector counter                                
D2C5 1027D97B         (    rsdos_mmc.asm):03382                        lbeq    BasOMError               ; 'om' error if not at least one full sector of free ram                                                                  
                      (    rsdos_mmc.asm):03383         
D2C9 306E             (    rsdos_mmc.asm):03384                        leax    14,s                     ; point x to start of source data                                          
D2CB 8DBD             (    rsdos_mmc.asm):03385                        bsr     ld3ad                    ; put source data into dnambf and dskcon                                                 
                      (    rsdos_mmc.asm):03386         
D2CD BDC569           (    rsdos_mmc.asm):03387                        jsr     >lc68c                   ; scan directory for a match                                     
                      (    rsdos_mmc.asm):03388         
D2D0 BDC5C2           (    rsdos_mmc.asm):03389                        jsr     >lc6e5                   ; 'ne' error if match not found                                        
                      (    rsdos_mmc.asm):03390         
D2D3 BE0974           (    rsdos_mmc.asm):03391                        ldx     v974                     ; point x to directory ram image of found file                                                      
D2D6 EE0E             (    rsdos_mmc.asm):03392                        ldu     dirlst,x                 ; get number of bytes in last sector and                                                    
D2D8 AE0B             (    rsdos_mmc.asm):03393                        ldx     dirtyp,x                 ; source file type and ascii flag                                             
D2DA 3450             (    rsdos_mmc.asm):03394                        pshs    u,x                      ; and save them on the stack                                    
D2DC BDC67A           (    rsdos_mmc.asm):03395                        jsr     >GetFAT                   ; get valid fat data                             
                      (    rsdos_mmc.asm):03396         
D2DF F60976           (    rsdos_mmc.asm):03397                        ldb     v976                     ; get number of first granule in file                                             
D2E2 BDCBFB           (    rsdos_mmc.asm):03398                        jsr     >lcd1e                   ; get the number of granules in file                                             
                      (    rsdos_mmc.asm):03399         
D2E5 3402             (    rsdos_mmc.asm):03400                        pshs    a                        ; and save it on the stack                                
D2E7 4A               (    rsdos_mmc.asm):03401                        deca                             ; subtract off the last granule                                    
D2E8 C43F             (    rsdos_mmc.asm):03402                        andb    #$3f                     ; mask off last granule flag bits and save the                                                       
D2EA 3404             (    rsdos_mmc.asm):03403                        pshs    b                        ; number of sectors in last granule on stack                                                  
D2EC 1F89             (    rsdos_mmc.asm):03404                        tfr     a,b                      ; save the number of granules in accb                                            
D2EE 4F               (    rsdos_mmc.asm):03405                        clra                             ; clear the ms byte of accd                                
D2EF BDC656           (    rsdos_mmc.asm):03406                        jsr     >lc779                   ; multiply accd by nine                                
                      (    rsdos_mmc.asm):03407         
D2F2 EBE4             (    rsdos_mmc.asm):03408                        addb    ,s                       ; add the number of sectors in the last                                              
D2F4 8900             (    rsdos_mmc.asm):03409                        adca    #$00                     ; granule to accd                          
D2F6 8E0001           (    rsdos_mmc.asm):03410                        ldx     #$0001                   ; initialize record counter to one                                            
D2F9 3416             (    rsdos_mmc.asm):03411                        pshs    x,b,a                    ; initialize sector and record counters on the stack                                                              
                      (    rsdos_mmc.asm):03412         
                      (    rsdos_mmc.asm):03413         ; at this point the control variables for copy are stored on the stack.
                      (    rsdos_mmc.asm):03414         ;   0 1,s = remaining sectors counter; 2 3,s = record counter
                      (    rsdos_mmc.asm):03415         ;     4,s = number of sectors to be copied. initially set to number of
                      (    rsdos_mmc.asm):03416         ;           sectors in the last granule.
                      (    rsdos_mmc.asm):03417         ;     5,s = gran test flag. initially set to number of grans in file
                      (    rsdos_mmc.asm):03418         ;     6,s = file type; 7,s = ascii flag; 8 9,s = number of bytes in last sector
                      (    rsdos_mmc.asm):03419         ;    10,s = number of sectors which will fit in the currently available free ram
                      (    rsdos_mmc.asm):03420         ; 11-22,s = destination filename.ext and drive number
                      (    rsdos_mmc.asm):03421         ;    23,s = single disk copy flag; 24-35,s = source filename.ext and drive number
D2FB 5F               (    rsdos_mmc.asm):03422         ld41e          clrb                             ; set sector counter to zero                                      
D2FC AEE4             (    rsdos_mmc.asm):03423                        ldx     ,s                       ; get the number of sectors remaining in the file                                                       
D2FE 2709             (    rsdos_mmc.asm):03424                        beq     ld42c                    ; branch if no sectors left                                    
                      (    rsdos_mmc.asm):03425         
D300 5C               (    rsdos_mmc.asm):03426         ld423          incb                             ; add a sector to temporary sector counter                                                    
D301 301F             (    rsdos_mmc.asm):03427                        leax    -1,x                     ; decrement remaining sectors counter                                              
D303 2704             (    rsdos_mmc.asm):03428                        beq     ld42c                    ; branch if no sectors left                                    
                      (    rsdos_mmc.asm):03429         
D305 E16A             (    rsdos_mmc.asm):03430                        cmpb    10,s                     ;compare temporary counter to number of sectors which may                                                                  
                      (    rsdos_mmc.asm):03431                                                         ;be stored in free ram
D307 26F7             (    rsdos_mmc.asm):03432                        bne     ld423                    ; branch if still room for more sectors                                                
                      (    rsdos_mmc.asm):03433         
D309 AFE4             (    rsdos_mmc.asm):03434         ld42c          stx     ,s                       ; save the number of uncopied sectors remaining in the file                                                                      
D30B E764             (    rsdos_mmc.asm):03435                        stb     $04,s                    ; save the number of sectors to be copied this time through loop                                                                         
D30D 8D50             (    rsdos_mmc.asm):03436                        bsr     ld482                    ; 'get' accb sectors to ram buffer                                           
                      (    rsdos_mmc.asm):03437         
D30F 86FF             (    rsdos_mmc.asm):03438                        lda     #$ff                     ; set source/destination flag to destination                                                    
D311 8D40             (    rsdos_mmc.asm):03439                        bsr     ld476                    ; print prompt message if required                                           
                      (    rsdos_mmc.asm):03440         
D313 6D65             (    rsdos_mmc.asm):03441                        tst     $05,s                    ; check the gran test flag. if <> 0, it contains the                                                             
D315 2725             (    rsdos_mmc.asm):03442                        beq     ld45f                    ; number of grans in the file and the destination disk                                                               
                      (    rsdos_mmc.asm):03443         
                      (    rsdos_mmc.asm):03444                                                         ; must be checked for enough room. if it is =0
                      (    rsdos_mmc.asm):03445                                                         ; then the check has already been done
D317 306B             (    rsdos_mmc.asm):03446                        leax    11,s                     ; point to destination file parameters                                               
D319 BDD28A           (    rsdos_mmc.asm):03447                        jsr     >ld3ad                   ; get destination file parameters from stack                                                     
                      (    rsdos_mmc.asm):03448         
D31C BDCF36           (    rsdos_mmc.asm):03449                        jsr     >ld059                   ; scan directory for file - 'ae' error if it exists                                                            
                      (    rsdos_mmc.asm):03450         
D31F BDC67A           (    rsdos_mmc.asm):03451                        jsr     >GetFAT                   ; get valid fat data                             
                      (    rsdos_mmc.asm):03452         
                      (    rsdos_mmc.asm):03453         
                      (    rsdos_mmc.asm):03454         ; make sure there are enough free granules on the destination disk
D322 BDC632           (    rsdos_mmc.asm):03455                        jsr     >lc755                   ; point x to fat                         
                      (    rsdos_mmc.asm):03456         
D325 3006             (    rsdos_mmc.asm):03457                        leax    fatcon,x                 ; skip past the fat control bytes                                              
D327 A665             (    rsdos_mmc.asm):03458                        lda     $05,s                    ; get the number of grans in the file                                              
D329 C644             (    rsdos_mmc.asm):03459                        ldb     #granmx                  ; set gran counter to maximum                                        
D32B 6384             (    rsdos_mmc.asm):03460         ld44e          com     ,x                       ; check to see if a bran is free                                           
D32D 2603             (    rsdos_mmc.asm):03461                        bne     ld455                    ; and branch if it is not free                                       
                      (    rsdos_mmc.asm):03462         
D32F 4A               (    rsdos_mmc.asm):03463                        deca                             ; = decrement counter and branch if                                        
D330 2708             (    rsdos_mmc.asm):03464                        beq     ld45d                    ; = there are enough free granules                                           
                      (    rsdos_mmc.asm):03465         
D332 6380             (    rsdos_mmc.asm):03466         ld455          com     ,x+                      ; restore fat byte and increment pointer                                                    
D334 5A               (    rsdos_mmc.asm):03467                        decb                             ; decrement gran counter                             
D335 26F4             (    rsdos_mmc.asm):03468                        bne     ld44e                    ; branch if all grans not checked                                          
                      (    rsdos_mmc.asm):03469         
D337 7EC6D5           (    rsdos_mmc.asm):03470                        jmp     >lc7f8                   ; 'disk full' error                            
                      (    rsdos_mmc.asm):03471         
D33A 6384             (    rsdos_mmc.asm):03472         ld45d          com     ,x                       ; restore fat byte                             
D33C 8D1B             (    rsdos_mmc.asm):03473         ld45f          bsr     ld47c                    ; 'put' data from ram buffer to destination file                                                              
                      (    rsdos_mmc.asm):03474         
D33E AEE4             (    rsdos_mmc.asm):03475                        ldx     ,s                       ; get the number of remaining sectors                                           
D340 270D             (    rsdos_mmc.asm):03476                        beq     ld472                    ; exit routine if no sectors left                                          
                      (    rsdos_mmc.asm):03477         
D342 EC62             (    rsdos_mmc.asm):03478                        ldd     $02,s                    ;          
D344 EB64             (    rsdos_mmc.asm):03479                        addb    $04,s                    ; get the current record counter, add                                               
D346 8900             (    rsdos_mmc.asm):03480                        adca    #$00                     ; the number of sectors (records) moved                                                
D348 ED62             (    rsdos_mmc.asm):03481                        std     $02,s                    ; and save the new record counter                                          
D34A 4F               (    rsdos_mmc.asm):03482                        clra                             ; set source/destination flag to source                                            
D34B 8D06             (    rsdos_mmc.asm):03483                        bsr     ld476                    ; print prompt message if required                                           
                      (    rsdos_mmc.asm):03484         
D34D 20AC             (    rsdos_mmc.asm):03485                        bra     ld41e                    ; keep copying sectors                               
                      (    rsdos_mmc.asm):03486         
D34F 32E824           (    rsdos_mmc.asm):03487         ld472          leas    36,s                     ; remove temporary storage variables from stack                                                             
D352 39               (    rsdos_mmc.asm):03488                        rts                              ;;;; copy done ;;;;                       
                      (    rsdos_mmc.asm):03489         
                      (    rsdos_mmc.asm):03490         
D353 6DE819           (    rsdos_mmc.asm):03491         ld476          tst     25,s                     ;check single disk copy flag - if <> zero, then don't                                                                  
                      (    rsdos_mmc.asm):03492                                                         ;print the prompt message
D356 7ED203           (    rsdos_mmc.asm):03493                        jmp     >ld326                   ; print the prompt message if required                                               
                      (    rsdos_mmc.asm):03494         
                      (    rsdos_mmc.asm):03495         
                      (    rsdos_mmc.asm):03496         ; 'put'.'get' data from the destination/source files
D359 86FF             (    rsdos_mmc.asm):03497         ld47c          lda     #$ff                     ; 'put' flag                         
D35B 306D             (    rsdos_mmc.asm):03498                        leax    13,s                     ; point x to destination filename data                                               
D35D 2004             (    rsdos_mmc.asm):03499                        bra     ld486                    ; go 'put' some data                             
D35F 4F               (    rsdos_mmc.asm):03500         ld482          clra                             ; zero is the 'get' flag                                  
D360 30E81A           (    rsdos_mmc.asm):03501                        leax    26,s                     ; point x to the source filename data                                              
D363 97D8             (    rsdos_mmc.asm):03502         ld486          sta     vd8                      ; save the 'get'/'put' flag                                       
D365 BDD28A           (    rsdos_mmc.asm):03503                        jsr     >ld3ad                   ; get filename and drive data from the stack                                                     
                      (    rsdos_mmc.asm):03504         
D368 AE68             (    rsdos_mmc.asm):03505                        ldx     $08,s                    ; get ascii flag and file type and save                                                
D36A BF0957           (    rsdos_mmc.asm):03506                        stx     dfltyp                   ; them in the disk ram variables                                          
D36D 8E0100           (    rsdos_mmc.asm):03507                        ldx     #seclen                  ; = save one sector length in                                        
D370 BF097C           (    rsdos_mmc.asm):03508                        stx     dfflen                   ; = ram record length variable                                        
D373 8652             (    rsdos_mmc.asm):03509                        lda     #'R                      ; random file type flag                               
D375 F6095B           (    rsdos_mmc.asm):03510                        ldb     fcbact                   ; get the highest reserved fcb number, add one                                                        
D378 5C               (    rsdos_mmc.asm):03511                        incb                             ; and open a random file whose fcb will be one above                                                         
D379 BDC36A           (    rsdos_mmc.asm):03512                        jsr     >lc48d                   ; the highest reserved fcb (the system fcb)                                                    
                      (    rsdos_mmc.asm):03513         
D37C 9EF1             (    rsdos_mmc.asm):03514                        ldx     fcbtmp                   ; point x to the 'system' fcb                                       
D37E CC0100           (    rsdos_mmc.asm):03515                        ldd     #seclen                  ; set the number of bytes in the last sector                                                       
D381 ED8813           (    rsdos_mmc.asm):03516                        std     fcblst,x                 ; of the file equal to one sector length                                                    
                      (    rsdos_mmc.asm):03517         
D384 E666             (    rsdos_mmc.asm):03518                        ldb     $06,s                    ; =get the number of sectors to move and                                                 
D386 2729             (    rsdos_mmc.asm):03519                        beq     ld4d4                    ; =branch if none left                               
                      (    rsdos_mmc.asm):03520         
D388 D6D8             (    rsdos_mmc.asm):03521                        ldb     vd8                      ;grab the 'get'/'put' flag, 'and' it with the                                                    
D38A E467             (    rsdos_mmc.asm):03522                        andb    $07,s                    ;gran test flag - branch if 'get'ing data or this is                                                              
D38C 2709             (    rsdos_mmc.asm):03523                        beq     ld4ba                    ;not the first time through the loop                                             
                      (    rsdos_mmc.asm):03524         
D38E EC62             (    rsdos_mmc.asm):03525                        ldd     $02,s                    ; =get the number of sectors remaining to be copied and                                                                
D390 EB66             (    rsdos_mmc.asm):03526                        addb    $06,s                    ; =add the number to be copied this time through loop                                                               
D392 8900             (    rsdos_mmc.asm):03527                        adca    #$00                     ; =            
D394 BDC1C3           (    rsdos_mmc.asm):03528                        jsr     >lc2e6                   ;'put' the last record in the file to the system fcb.                                                              
                      (    rsdos_mmc.asm):03529         
                      (    rsdos_mmc.asm):03530         ;                                                    ;the record number is in accd.
D397 9EF1             (    rsdos_mmc.asm):03531         ld4ba          ldx     fcbtmp                   ; point x to the system fcb                                          
D399 EE64             (    rsdos_mmc.asm):03532                        ldu     $04,s                    ; get the current record number                                        
D39B EF07             (    rsdos_mmc.asm):03533                        stu     fcbrec,x                 ; and save it in the fcb                                    
D39D E666             (    rsdos_mmc.asm):03534                        ldb     $06,s                    ; get the number of the record (sector) to move                                                        
D39F DE1F             (    rsdos_mmc.asm):03535                        ldu     BasVarEnd                ; end of arrays is the start of the copy free ram buffer                                                                  
D3A1 3444             (    rsdos_mmc.asm):03536         ld4c4          pshs    u,b                      ; save sector counter and buffer pointer on the stack                                                                  
D3A3 9EF1             (    rsdos_mmc.asm):03537                        ldx     fcbtmp                   ; point x to system fcb                                 
D3A5 EF0B             (    rsdos_mmc.asm):03538                        stu     fcbbuf,x                 ;set the random file buffer pointer to the 'copy' ram buffer                                                                        
                      (    rsdos_mmc.asm):03539         ;                                                    ;this will cause the system to 'hang' if an error occurs during copy.
D3A7 BDC1C7           (    rsdos_mmc.asm):03540                        jsr     >lc2ea                   ; go 'get' or 'put' data to the system fcb                                                   
                      (    rsdos_mmc.asm):03541         
D3AA 6C61             (    rsdos_mmc.asm):03542                        inc     $01,s                    ; add 256 (one sector) to the buffer pointer                                                     
D3AC 3544             (    rsdos_mmc.asm):03543                        puls    b,u                      ; get the sector counter and buffer poiner                                                  
D3AE 5A               (    rsdos_mmc.asm):03544                        decb                             ; decrement sector counter                               
D3AF 26F0             (    rsdos_mmc.asm):03545                        bne     ld4c4                    ; branch if all sectors not done                                         
                      (    rsdos_mmc.asm):03546         
D3B1 9EF1             (    rsdos_mmc.asm):03547         ld4d4          ldx     fcbtmp                   ; point x to system fcb                                      
D3B3 CE0989           (    rsdos_mmc.asm):03548                        ldu     #dflbuf                  ; reset the random file buffer pointer for the system                                                                
D3B6 EF0B             (    rsdos_mmc.asm):03549                        stu     fcbbuf,x                 ; fcb to the bottom of random file buffer area                                                          
D3B8 D6D8             (    rsdos_mmc.asm):03550                        ldb     vd8                      ; =grab the 'get'/'put' flag, 'and' it with the gran                                                           
D3BA E467             (    rsdos_mmc.asm):03551                        andb    $07,s                    ; =test flag - close the file if 'get'ing data and                                                            
D3BC 2709             (    rsdos_mmc.asm):03552                        beq     ld4ea                    ; =this is not the first time through the loop                                                       
                      (    rsdos_mmc.asm):03553         
D3BE 6F67             (    rsdos_mmc.asm):03554                        clr     $07,s                    ; reset the gran test flag if first time through loop                                                              
D3C0 EC6A             (    rsdos_mmc.asm):03555                        ldd     10,s                     ;get the number of bytes in the last sector,                                                    
D3C2 8A80             (    rsdos_mmc.asm):03556                        ora     #$80                     ;'or' in the pre-saved flag and                                       
D3C4 ED8813           (    rsdos_mmc.asm):03557                        std     fcblst,x                 ;save the number of bytes in the last sector in the fcb                                                                   
                      (    rsdos_mmc.asm):03558         
D3C7 7EC9E3           (    rsdos_mmc.asm):03559         ld4ea          jmp     >lcb06                   ; close the file                              
                      (    rsdos_mmc.asm):03560         
                      (    rsdos_mmc.asm):03561         
                      (    rsdos_mmc.asm):03562         ; dski$ command
D3CA 8D38             (    rsdos_mmc.asm):03563         CmdDski           bsr     ld527                    ; get the drive, track and sector numbers                                                      
                      (    rsdos_mmc.asm):03564         
D3CC 8D2B             (    rsdos_mmc.asm):03565                        bsr     ld51c                    ; evaluate string variable 1 and save                                              
                      (    rsdos_mmc.asm):03566         
D3CE 3410             (    rsdos_mmc.asm):03567                        pshs    x                        ; the descriptor address on the stack                                           
D3D0 8D27             (    rsdos_mmc.asm):03568                        bsr     ld51c                    ; = evaluate string variable 2 and save                                                
                      (    rsdos_mmc.asm):03569         
D3D2 3410             (    rsdos_mmc.asm):03570                        pshs    x                        ; = the descriptor address on the stack                                             
D3D4 C602             (    rsdos_mmc.asm):03571                        ldb     #$02                     ; dskcon read op code                             
D3D6 BDD46C           (    rsdos_mmc.asm):03572                        jsr     >ld58f                   ; reao a sector into dbuf0                                   
                      (    rsdos_mmc.asm):03573         
D3D9 CE0680           (    rsdos_mmc.asm):03574                        ldu     #dbuf0+128               ; point u to top half of dbuf0                                            
D3DC 3510             (    rsdos_mmc.asm):03575                        puls    x                        ; get string 2 descriptor address                                       
D3DE 8D05             (    rsdos_mmc.asm):03576                        bsr     ld508                    ; put string 2 into string space                                         
                      (    rsdos_mmc.asm):03577         
D3E0 CE0600           (    rsdos_mmc.asm):03578                        ldu     #dbuf0                   ; point u to bottom half of dbuf0                                           
D3E3 3510             (    rsdos_mmc.asm):03579                        puls    x                        ; get string 1 descriptor address                                       
D3E5 3450             (    rsdos_mmc.asm):03580         ld508          pshs    u,x                      ; put string descriptor & source pointer on the stack                                                                  
D3E7 C680             (    rsdos_mmc.asm):03581                        ldb     #128                     ;         
D3E9 BDB50F           (    rsdos_mmc.asm):03582                        jsr     BasResStr                ; reserve 128 bytes in string space                                            
                      (    rsdos_mmc.asm):03583         
D3EC 3384             (    rsdos_mmc.asm):03584                        leau    ,x                       ; point u to reserved string space                                         
D3EE 3510             (    rsdos_mmc.asm):03585                        puls    x                        ; get string descriptor address                                     
D3F0 E784             (    rsdos_mmc.asm):03586                        stb     ,x                       ; save descriptor data (length and address)                                                 
D3F2 EF02             (    rsdos_mmc.asm):03587                        stu     $02,x                    ; of the new string                            
D3F4 3510             (    rsdos_mmc.asm):03588                        puls    x                        ; get the source (dbuf0) pointer                                      
D3F6 7EA59A           (    rsdos_mmc.asm):03589         ld519          jmp     UtilCopyBXtoU            ; move sector data from dbuf0 to string space                                                           
                      (    rsdos_mmc.asm):03590         
                      (    rsdos_mmc.asm):03591         
D3F9 BDB26D           (    rsdos_mmc.asm):03592         ld51c          jsr     VarCKComma               ; syntax check for a comma                                           
                      (    rsdos_mmc.asm):03593         
D3FC 8EB357           (    rsdos_mmc.asm):03594                        ldx     #VarGetVar               ; point x to evaluate variable routine                                                
D3FF 8D2F             (    rsdos_mmc.asm):03595                        bsr     ld553                    ; evaluate a variable                              
                      (    rsdos_mmc.asm):03596         
D401 7EB146           (    rsdos_mmc.asm):03597         ld524          jmp     VarGetExpr               ; 'tm' error if numeric variable                                              
                      (    rsdos_mmc.asm):03598         
                      (    rsdos_mmc.asm):03599         
                      (    rsdos_mmc.asm):03600         ; evaluate drive, track and sector numbers
D404 BDB70B           (    rsdos_mmc.asm):03601         ld527          jsr     VarGet8Bit               ; evaluate expression, return value in accb                                                            
                      (    rsdos_mmc.asm):03602         
D407 C103             (    rsdos_mmc.asm):03603                        cmpb    #$03                     ; compare to 3 (highest drive number) -                                                
D409 221C             (    rsdos_mmc.asm):03604                        bhi     ld54a                    ; 'fc' error if it's > 3                                 
D40B 3404             (    rsdos_mmc.asm):03605                        pshs    b                        ; save drive number on the stack                                      
D40D BDB738           (    rsdos_mmc.asm):03606                        jsr     VarGetComma8             ; syntax check for comma. evaluate expression (track number)                                                                     
                      (    rsdos_mmc.asm):03607         
D410 C122             (    rsdos_mmc.asm):03608                        cmpb    #trkmax-1                ; check for maximum track number                                              
D412 2213             (    rsdos_mmc.asm):03609                        bhi     ld54a                    ; 'fc' error if track number > 34                                          
D414 3404             (    rsdos_mmc.asm):03610                        pshs    b                        ; save track number on the stack                                      
D416 BDB738           (    rsdos_mmc.asm):03611                        jsr     VarGetComma8             ; syntax check for comma, evaluate expression (sector number)                                                                      
                      (    rsdos_mmc.asm):03612         
D419 D7ED             (    rsdos_mmc.asm):03613                        stb     dsec                     ; save sector number in dskcon variable                                               
D41B 5A               (    rsdos_mmc.asm):03614                        decb                             ;useless instruction. next instruction should just                                                       
D41C C111             (    rsdos_mmc.asm):03615                        cmpb    #secmax-1                ;check for maximum sector number (secmax)                                                       
D41E 2207             (    rsdos_mmc.asm):03616                        bhi     ld54a                    ; 'fc' error if sector number too big                                              
D420 3506             (    rsdos_mmc.asm):03617                        puls    a,b                      ; get track and drive number off of                                           
D422 97EC             (    rsdos_mmc.asm):03618                        sta     dctrk                    ; the stack and save in dskcon                                       
D424 D7EB             (    rsdos_mmc.asm):03619                        stb     dcdrv                    ; variables                    
D426 39               (    rsdos_mmc.asm):03620                        rts                                     
                      (    rsdos_mmc.asm):03621         
D427 7EB44A           (    rsdos_mmc.asm):03622         ld54a          jmp     BasFCError               ; jump to 'fc' error                                  
                      (    rsdos_mmc.asm):03623         
                      (    rsdos_mmc.asm):03624         
D42A BDB26D           (    rsdos_mmc.asm):03625         ld54d          jsr     VarCKComma               ; syntax check for comma                                         
                      (    rsdos_mmc.asm):03626         
D42D 8EB156           (    rsdos_mmc.asm):03627                        ldx     #VarGetStr               ; point x to 'evaluate expression' routine address                                                            
D430 D6EB             (    rsdos_mmc.asm):03628         ld553          ldb     dcdrv                    ; get the dskcon drive, track and                                               
D432 DEEC             (    rsdos_mmc.asm):03629                        ldu     dctrk                    ; sector values and save them on the stack                                                   
D434 3444             (    rsdos_mmc.asm):03630                        pshs    u,b                      ; pshs    s,b         
D436 AD84             (    rsdos_mmc.asm):03631                        jsr     ,x                       ; go evaluate an expression or a variable                                               
                      (    rsdos_mmc.asm):03632         
D438 3544             (    rsdos_mmc.asm):03633                        puls    b,u                      ; get the drive, track and sector                                         
D43A D7EB             (    rsdos_mmc.asm):03634                        stb     dcdrv                    ; numbers off of the stack and put                                           
D43C DFEC             (    rsdos_mmc.asm):03635                        stu     dctrk                    ; them back into the dskcon variables                                              
D43E 39               (    rsdos_mmc.asm):03636                        rts                                     
                      (    rsdos_mmc.asm):03637         
                      (    rsdos_mmc.asm):03638         
                      (    rsdos_mmc.asm):03639         ; dsko$ command
D43F 8DC3             (    rsdos_mmc.asm):03640         CmdDsko           bsr     ld527                    ; get the drive, track and sector numbers                                                      
                      (    rsdos_mmc.asm):03641         
D441 8DE7             (    rsdos_mmc.asm):03642                        bsr     ld54d                    ; get the descriptor of string 1                                         
                      (    rsdos_mmc.asm):03643         
D443 8DBC             (    rsdos_mmc.asm):03644                        bsr     ld524                    ; 'tm' error if numeric expression                                           
                      (    rsdos_mmc.asm):03645         
D445 9E52             (    rsdos_mmc.asm):03646                        ldx     BasVarFPAcc1+3           ; get string 1 descriptor address                                           
D447 3410             (    rsdos_mmc.asm):03647                        pshs    x                        ; and save it on the stack                                
D449 8DDF             (    rsdos_mmc.asm):03648                        bsr     ld54d                    ; get the descriptor of string 2                                         
                      (    rsdos_mmc.asm):03649         
D44B BDB654           (    rsdos_mmc.asm):03650                        jsr     BasGetStrLenAddr         ;get length and address of string 2 and                                                
                      (    rsdos_mmc.asm):03651         
D44E 3414             (    rsdos_mmc.asm):03652                        pshs    x,b                      ;save them on the stack                               
D450 5F               (    rsdos_mmc.asm):03653                        clrb                             ; set clear counter to 256 (full sector buffer)                                                    
D451 8E0600           (    rsdos_mmc.asm):03654                        ldx     #dbuf0                   ; use dbuf0 as the dsko$ i/o buffer                                             
D454 6F80             (    rsdos_mmc.asm):03655         ld577          clr     ,x+                      ; clear a byte in i/o buffer                                        
D456 5A               (    rsdos_mmc.asm):03656                        decb                             ; decrement clear counter                              
D457 26FB             (    rsdos_mmc.asm):03657                        bne     ld577                    ; branch if all 256 bytes not cleared                                              
                      (    rsdos_mmc.asm):03658         
D459 3514             (    rsdos_mmc.asm):03659                        puls    b,x                      ; get the length and address of string 2                                                
D45B CE0680           (    rsdos_mmc.asm):03660                        ldu     #dbuf0+128               ; point x to string 2 destination                                               
D45E 8D96             (    rsdos_mmc.asm):03661                        bsr     ld519                    ; move string 2 data into dbuf0                                        
                      (    rsdos_mmc.asm):03662         
D460 3510             (    rsdos_mmc.asm):03663                        puls    x                        ; point x to string 1 descriptor                                      
D462 BDB659           (    rsdos_mmc.asm):03664                        jsr     VarDelVar                ; get the length and address of string 1                                                 
                      (    rsdos_mmc.asm):03665         
D465 CE0600           (    rsdos_mmc.asm):03666                        ldu     #dbuf0                   ; point u to string 1 destination                                           
D468 8D8C             (    rsdos_mmc.asm):03667                        bsr     ld519                    ; move string 1 data into dbuf0                                        
                      (    rsdos_mmc.asm):03668         
D46A C603             (    rsdos_mmc.asm):03669                        ldb     #$03                     ; dskcon write op code                              
D46C 8E0600           (    rsdos_mmc.asm):03670         ld58f          ldx     #dbuf0                   ; point x to i/o buffer (dbuf0)                                         
D46F 9FEE             (    rsdos_mmc.asm):03671                        stx     dcbpt                    ;          
D471 D7EA             (    rsdos_mmc.asm):03672                        stb     dcopc                    ; save new dskcon buffer pointer and op code variables                                                               
D473 7ED4B5           (    rsdos_mmc.asm):03673                        jmp     >DoDiskReadWrite                   ; go write out a sector                                
                      (    rsdos_mmc.asm):03674         
                      (    rsdos_mmc.asm):03675         
                      (    rsdos_mmc.asm):03676         ; CmdDskini command
D476 1027D1A5         (    rsdos_mmc.asm):03677         CmdDskini      lbeq    la61f                    ; branch to 'dn' error if no drive number specified                                                                   
                      (    rsdos_mmc.asm):03678         
D47A BDD133           (    rsdos_mmc.asm):03679                        jsr     >ld256                   ; calculate drive number                                 
                      (    rsdos_mmc.asm):03680         
D47D C604             (    rsdos_mmc.asm):03681                        ldb     #$04                     ; skip factor default value                                   
D47F 9DA5             (    rsdos_mmc.asm):03682                        jsr     BasChrGetCurr            ; get current input char from basic                                             
                      (    rsdos_mmc.asm):03683         
D481 270C             (    rsdos_mmc.asm):03684                        beq     ld5b2                    ; branch if end of line                                
                      (    rsdos_mmc.asm):03685         
D483 BDB738           (    rsdos_mmc.asm):03686                        jsr     VarGetComma8             ; syntax check for comma and evaluate expression                                                         
                      (    rsdos_mmc.asm):03687         
D486 C111             (    rsdos_mmc.asm):03688                        cmpb    #17                      ; max value of skip factor = 16                                       
D488 1024DFBE         (    rsdos_mmc.asm):03689                        lbhs    BasFCError               ; 'illegal function call' if bad skip factor                                                      
                      (    rsdos_mmc.asm):03690         
D48C BDA5C7           (    rsdos_mmc.asm):03691                        jsr     la5c7                    ; syntax error if more characters on the line                                                      
                      (    rsdos_mmc.asm):03692         
D48F                  (    rsdos_mmc.asm):03693         ld5b2           
                      (    rsdos_mmc.asm):03694                         ifeq    1
                      (    rsdos_mmc.asm):03695                         
                      (    rsdos_mmc.asm):03696                        pshs    b                        ; save skip factor on the stack                                          
                      (    rsdos_mmc.asm):03697         
                      (    rsdos_mmc.asm):03698                        ldx     #dbuf1+secmax            ; point to end of logical sector number storage area                                                                     
                      (    rsdos_mmc.asm):03699                        ldb     #secmax                  ; 18 sectors per track                                 
D48F                  (    rsdos_mmc.asm):03700         ld5b9          clr     ,-x                      ; clear a byte in the buffer                                        
                      (    rsdos_mmc.asm):03701                        decb                             ; cleared all 18?                      
                      (    rsdos_mmc.asm):03702                        bne     ld5b9                    ; keep going if not                            
                      (    rsdos_mmc.asm):03703         
                      (    rsdos_mmc.asm):03704                        clra                             ; reset physical sector counter                                    
                      (    rsdos_mmc.asm):03705                        bra     ld5ce                    ; start with first physical sector = 1                                               
                      (    rsdos_mmc.asm):03706         
                      (    rsdos_mmc.asm):03707         ; calculate logical sector numbers
D48F                  (    rsdos_mmc.asm):03708         ld5c1          addb    ,s                       ; add skip factor to logical sector counter                                                       
D48F                  (    rsdos_mmc.asm):03709         ld5c3          incb                             ; add one to logical sector counter                                             
D48F                  (    rsdos_mmc.asm):03710         ld5c4          subb    #secmax                  ; subtract max number of sectors                                                 
                      (    rsdos_mmc.asm):03711                        bhs     ld5c4                    ; branch until 0 > accb >= -18                                       
                      (    rsdos_mmc.asm):03712         
                      (    rsdos_mmc.asm):03713                        addb    #secmax                  ; add 18, now accb is 0-17                                      
                      (    rsdos_mmc.asm):03714                        tst     b,x                      ; is anything stored here already?                                         
                      (    rsdos_mmc.asm):03715                        bne     ld5c3                    ; yes - get another sector                                   
                      (    rsdos_mmc.asm):03716         
D48F                  (    rsdos_mmc.asm):03717         ld5ce          inca                             ; increment physical sector number and                                                
                      (    rsdos_mmc.asm):03718                        sta     b,x                      ; save it in the ram buffer                                  
                      (    rsdos_mmc.asm):03719                        cmpa    #secmax                  ; finished with all sectors?                                        
                      (    rsdos_mmc.asm):03720                        blo     ld5c1                    ; no - keep going                          
                      (    rsdos_mmc.asm):03721         
                      (    rsdos_mmc.asm):03722                        leas    $01,s                    ; remove skip factor from stack                                         
                      (    rsdos_mmc.asm):03723                        ldx     #dflbuf+$1888-2          ; get top of ram used by CmdDskini                                                  
                      (    rsdos_mmc.asm):03724                        cmpx    AddrFWareRamTop          ; is it > cleared area?                                  
                      (    rsdos_mmc.asm):03725                        lbhi    BasOMError               ; 'out of memory' error if > cleared area                                                   
                      (    rsdos_mmc.asm):03726         
                      (    rsdos_mmc.asm):03727                         endc
                      (    rsdos_mmc.asm):03728         
D48F BDC9C6           (    rsdos_mmc.asm):03729                        jsr     DosCloseAllFiles                    ; close all files                          
                      (    rsdos_mmc.asm):03730         
D492 73095C           (    rsdos_mmc.asm):03731                        com     dresfl                   ; set reset flag to $ff - this will cause a dos reset                                                               
D495 10CE0800         (    rsdos_mmc.asm):03732                        lds     #dbuf1+seclen            ; set stack to top of dbuf1                                            
D499 BD95AC           (    rsdos_mmc.asm):03733                        jsr     TextResetVDU             ; reset sam to display page zero and alpha graphics                                                            
                      (    rsdos_mmc.asm):03734         
D49C 8600             (    rsdos_mmc.asm):03735                        lda     #$00                     ; you could delete this instruction and change following sta to clr                                                                           
D49E 97EA             (    rsdos_mmc.asm):03736                        sta     dcopc                    ; restore head to track zero dskcon op code                                                    
D4A0 0FEC             (    rsdos_mmc.asm):03737                        clr     dctrk                    ; set dskcon track variable to track zero                                                  
                      (    rsdos_mmc.asm):03738         ;               jsr     >DoDiskReadWrite                   ; restore head to track zero                                     
                      (    rsdos_mmc.asm):03739         
D4A2 96EB             (    rsdos_mmc.asm):03740                         lda     dcdrv                   ; get drive number
D4A4 C623             (    rsdos_mmc.asm):03741                         ldb     #trkmax                 ; RSdos 35 tracks / disk
D4A6 BDEE52           (    rsdos_mmc.asm):03742                         jsr     >MMC_FormatImage        ; Tell mmc to format virtual image
                      (    rsdos_mmc.asm):03743         
D4A9 BDD575           (    rsdos_mmc.asm):03744                         jsr     >DosFunctionRestore      ; restore to track 0
                      (    rsdos_mmc.asm):03745                      
D4AC 7ED1AA           (    rsdos_mmc.asm):03746                         jmp     >ld2cd                   ; go check for a dos reset                                   
                      (    rsdos_mmc.asm):03747         
                      (    rsdos_mmc.asm):03748                         ifeq    1
                      (    rsdos_mmc.asm):03749         
                      (    rsdos_mmc.asm):03750                        clr     rdytmr                   ; reset the ready timer                                 
                      (    rsdos_mmc.asm):03751         ;               lda     #WDCmdReadAddr           ; foc read address code                               
                      (    rsdos_mmc.asm):03752         ;               sta     fdcreg                   ;           
                      (    rsdos_mmc.asm):03753                        jsr     >WaitFDCNotBusy                   ; check drive ready - wait until ready                                               
                      (    rsdos_mmc.asm):03754         
                      (    rsdos_mmc.asm):03755                        beq     ld620                    ; branch if drives ready                                 
                      (    rsdos_mmc.asm):03756         
                      (    rsdos_mmc.asm):03757                        jmp     >ld688                   ; error if drives not ready                                    
                      (    rsdos_mmc.asm):03758         
D4AF                  (    rsdos_mmc.asm):03759         ld606          cmpa    #22                      ; = check for track 22 (precompensation)                                                     
                      (    rsdos_mmc.asm):03760                        blo     ld612                    ; = and branch if < track 22 - no precomp                                                  
                      (    rsdos_mmc.asm):03761         
                      (    rsdos_mmc.asm):03762                        lda     drgram                   ; get the ram image of dskreg, 'or'                                             
                      (    rsdos_mmc.asm):03763                        ora     #$10                     ; in the precompensation flag and                                         
                      (    rsdos_mmc.asm):03764                        sta     dskreg                   ; send it to dskreg                             
D4AF                  (    rsdos_mmc.asm):03765         ld612
                      (    rsdos_mmc.asm):03766         ;               lda     #WDStepIn                ; = get step in command                                    
                      (    rsdos_mmc.asm):03767         ;               sta     fdcreg                   ; = and send it to the 1793                                     
                      (    rsdos_mmc.asm):03768         ;               exg     a,a                      ; delay after issuing command to 1793                                            
                      (    rsdos_mmc.asm):03769         ;               exg     a,a                      ;        
                      (    rsdos_mmc.asm):03770                        jsr     >WaitFDCNotBusy                   ; check drive ready                            
                      (    rsdos_mmc.asm):03771         
                      (    rsdos_mmc.asm):03772                        bne     ld688                    ; branch if not ready - issue an error                                               
                      (    rsdos_mmc.asm):03773         
D4AF                  (    rsdos_mmc.asm):03774         ld620          
                      (    rsdos_mmc.asm):03775         ;               jsr     >MediumDelay             ; wait a while                            
                      (    rsdos_mmc.asm):03776                        bsr     ld691                    ; build a formatted track in ram                                         
                      (    rsdos_mmc.asm):03777         
                      (    rsdos_mmc.asm):03778                        ldy     #fdcreg+3                ; y points to 1793 data register                                             
                      (    rsdos_mmc.asm):03779                        orcc    #$50                     ; disable interrupts                             
                      (    rsdos_mmc.asm):03780                        ldx     #ld64f                   ; get return address and store                                        
                      (    rsdos_mmc.asm):03781                        stx     dnmivc                   ; it in the non maskable interrupt vector                                                   
                      (    rsdos_mmc.asm):03782                        ldx     #dflbuf                  ; point x to the formatted track ram image                                                     
                      (    rsdos_mmc.asm):03783                        lda     fdcreg                   ; reset status of the 1793                                    
                      (    rsdos_mmc.asm):03784                        lda     #$ff                     ; enable the nmi flag to vector                                       
                      (    rsdos_mmc.asm):03785                        sta     nmiflg                   ; out of an i/o loop upon an nmi interrupt                                                    
                      (    rsdos_mmc.asm):03786         
                      (    rsdos_mmc.asm):03787         ;               ldb     #WDCmdWriteTrack         ; = get write track command and                                       
                      (    rsdos_mmc.asm):03788         ;               stb     fdcreg                   ; = send to 1793                          
                      (    rsdos_mmc.asm):03789                        lda     drgram                   ; get the dskreg ram image and 'or' in the                                                    
                      (    rsdos_mmc.asm):03790                        ora     #$80                     ; flag which will enable the 1793 to halt                                                 
                      (    rsdos_mmc.asm):03791         ;               sta     dskreg                   ; the 6809. send result to dskreg                                           
D4AF                  (    rsdos_mmc.asm):03792         ld649          ldb     ,x+                      ; = get a byte from the formatted track                                                   
                      (    rsdos_mmc.asm):03793                        stb     ,y                       ; = ram image, send it to the 1793 and                                            
                      (    rsdos_mmc.asm):03794                        bra     ld649                    ; = loop back to get another byte                                          
                      (    rsdos_mmc.asm):03795         
D4AF                  (    rsdos_mmc.asm):03796         ld64f          lda     fdcreg                   ; get status                           
                      (    rsdos_mmc.asm):03797                        andcc   #$af                     ; enable interrupts                             
                      (    rsdos_mmc.asm):03798                        anda    #$44                     ; keep only write protect & lost data                                              
                      (    rsdos_mmc.asm):03799                        sta     dcsta                    ; and save it in the dskcon status byte                                                
                      (    rsdos_mmc.asm):03800                        bne     ld688                    ; branch if error                          
                      (    rsdos_mmc.asm):03801         
                      (    rsdos_mmc.asm):03802                        inc     dctrk                    ; skip to the next track                                 
                      (    rsdos_mmc.asm):03803                        lda     dctrk                    ; get the track number                               
                      (    rsdos_mmc.asm):03804                        cmpa    #trkmax                  ; was it the last track                                   
                      (    rsdos_mmc.asm):03805                        bne     ld606                    ; no - keep going                          
                      (    rsdos_mmc.asm):03806         
                      (    rsdos_mmc.asm):03807         ; verify that all sectors are readable
                      (    rsdos_mmc.asm):03808                        lda     #$02                     ; = get the dskcon read op code                                       
                      (    rsdos_mmc.asm):03809                        sta     dcopc                    ; = and save it in the dskcon variable                                               
                      (    rsdos_mmc.asm):03810                        ldx     #dbuf0                   ; point the dskcon buffer pointer                                           
                      (    rsdos_mmc.asm):03811                        stx     dcbpt                    ; to dbuf0                   
                      (    rsdos_mmc.asm):03812                        ldu     #dbuf1                   ; point u to the logical sector numbers                                                 
                      (    rsdos_mmc.asm):03813                        clra                             ; reset the track counter to zero                                      
D4AF                  (    rsdos_mmc.asm):03814         ld66f          sta     dctrk                    ; set the dskcon track variable                                             
                      (    rsdos_mmc.asm):03815                        clrb                             ; reset the sector counter                               
D4AF                  (    rsdos_mmc.asm):03816         ld672          lda     b,u                      ; get the physical sector number                                            
                      (    rsdos_mmc.asm):03817                        sta     dsec                     ; save dskcon sector variable                                     
                      (    rsdos_mmc.asm):03818                        jsr     >DoDiskReadWrite         ; read a sector                        
                      (    rsdos_mmc.asm):03819         
                      (    rsdos_mmc.asm):03820                        incb                             ; increment the sector counter                                   
                      (    rsdos_mmc.asm):03821                        cmpb    #secmax                  ; and compare it to maximum sector number                                                     
                      (    rsdos_mmc.asm):03822                        blo     ld672                    ; and keep looping if more sectors left                                                
                      (    rsdos_mmc.asm):03823         
                      (    rsdos_mmc.asm):03824                        lda     dctrk                    ; = get the current track number                                         
                      (    rsdos_mmc.asm):03825                        inca                             ; = add one to it, compare to the maximum track                                                    
                      (    rsdos_mmc.asm):03826                        cmpa    #trkmax                  ; = number and keep looping if                                          
                      (    rsdos_mmc.asm):03827                        blo     ld66f                    ; = there are still tracks to do                                         
                      (    rsdos_mmc.asm):03828         
                      (    rsdos_mmc.asm):03829                        jmp     >ld2cd                   ; go check for a dos reset                                   
                      (    rsdos_mmc.asm):03830         
D4AF                  (    rsdos_mmc.asm):03831         ld688          clr     drgram                   ; clear ram image of dskreg                                          
                      (    rsdos_mmc.asm):03832                        clr     dskreg                   ; clear dskreg - turn disk motors off                                               
                      (    rsdos_mmc.asm):03833                        jmp     >ld701                   ; process drives not ready error                                         
                      (    rsdos_mmc.asm):03834         
                      (    rsdos_mmc.asm):03835         
                      (    rsdos_mmc.asm):03836         ; build a formatted track of data in ram starting at dflbuf.
                      (    rsdos_mmc.asm):03837         
D4AF                  (    rsdos_mmc.asm):03838         ld691          ldx     #dflbuf                  ; start track buffer at dflbuf                                              
                      (    rsdos_mmc.asm):03839                        ldd     #$204e                   ; get set to write 32 bytes of $4e                                            
                      (    rsdos_mmc.asm):03840                        bsr     ld6c2                    ; go write gap iv                          
                      (    rsdos_mmc.asm):03841         
                      (    rsdos_mmc.asm):03842                        clrb                             ; reset sector counter                           
D4AF                  (    rsdos_mmc.asm):03843         ld69a          pshs    b                        ; save sector counter                                
                      (    rsdos_mmc.asm):03844                        ldu     #dbuf1                   ; point u to the table of logical sectors                                                   
                      (    rsdos_mmc.asm):03845                        ldb     b,u                      ; get logical sector number from table and                                                 
                      (    rsdos_mmc.asm):03846                        stb     dsec                     ; save it in the dskcon variable                                        
                      (    rsdos_mmc.asm):03847                        ldu     #ld6d4                   ; point u to table of sector formatting data                                                      
                      (    rsdos_mmc.asm):03848                        ldb     #$03                     ; get first 3 data blocks and                                     
                      (    rsdos_mmc.asm):03849                        bsr     ld6c8                    ; write them to buffer                               
                      (    rsdos_mmc.asm):03850         
                      (    rsdos_mmc.asm):03851                        lda     dctrk                    ; = get track number and store lt                                          
                      (    rsdos_mmc.asm):03852                        sta     ,x+                      ; = in the ram buffer                            
                      (    rsdos_mmc.asm):03853                        clr     ,x+                      ; clear a byte (side number) in buffer                                             
                      (    rsdos_mmc.asm):03854                        lda     dsec                     ; get sector number and                               
                      (    rsdos_mmc.asm):03855                        sta     ,x+                      ; store it in the buffer                               
                      (    rsdos_mmc.asm):03856                        ldb     #$09                     ; = get the last nine data blocks and                                             
                      (    rsdos_mmc.asm):03857                        bsr     ld6c8                    ; = write them to the buffer                                     
                      (    rsdos_mmc.asm):03858         
                      (    rsdos_mmc.asm):03859                        puls    b                        ; get sector counter                          
                      (    rsdos_mmc.asm):03860                        incb                             ; next sector                  
                      (    rsdos_mmc.asm):03861                        cmpb    #secmax                  ; 18 sectors per track                                  
                      (    rsdos_mmc.asm):03862                        blo     ld69a                    ; branch if all sectors not done                                         
                      (    rsdos_mmc.asm):03863         
                      (    rsdos_mmc.asm):03864                        ldd     #$c84e                   ; write 200 bytes of $4e at end of track                                                  
                      (    rsdos_mmc.asm):03865         
                      (    rsdos_mmc.asm):03866         ; write acca bytes of accb into buffer
D4AF                  (    rsdos_mmc.asm):03867         ld6c2          stb     ,x+                      ; store a byte in the buffer                                        
                      (    rsdos_mmc.asm):03868                        deca                             ; decrement counter                        
                      (    rsdos_mmc.asm):03869                        bne     ld6c2                    ; branch if all bytes not moved                                        
                      (    rsdos_mmc.asm):03870         
                      (    rsdos_mmc.asm):03871                        rts                                     
                      (    rsdos_mmc.asm):03872         
D4AF                  (    rsdos_mmc.asm):03873         ld6c8          pshs    b                        ; save the counter on the stack                                          
                      (    rsdos_mmc.asm):03874                        ldd     ,u++                     ; get two bytes of data from the table                                              
                      (    rsdos_mmc.asm):03875                        bsr     ld6c2                    ; write acca bytes of accb into the buffer                                                   
                      (    rsdos_mmc.asm):03876         
                      (    rsdos_mmc.asm):03877                        puls    b                        ; get the counter back, decrement                                       
                      (    rsdos_mmc.asm):03878                        decb                             ; it and branch if all data blocks                                       
                      (    rsdos_mmc.asm):03879                        bne     ld6c8                    ; not done                   
                      (    rsdos_mmc.asm):03880         
                      (    rsdos_mmc.asm):03881                        rts                                     
                      (    rsdos_mmc.asm):03882         
                      (    rsdos_mmc.asm):03883         
                      (    rsdos_mmc.asm):03884         ; data used to format a sector on the disk
                      (    rsdos_mmc.asm):03885         
                      (    rsdos_mmc.asm):03886         ; these data are close to the ibm system 34 format for 256 byte sectors.
                      (    rsdos_mmc.asm):03887         ; double density. the format generally conforms to that specified on the
                      (    rsdos_mmc.asm):03888         ; 1793 data sheet. the gap sizes have been reduced to the minimum
                      (    rsdos_mmc.asm):03889         ; allowable. the ibm format uses $40 as the fill character for the data
                      (    rsdos_mmc.asm):03890         ; blocks while color dos uses an $ff as the fill character.
D4AF                  (    rsdos_mmc.asm):03891         ld6d4          fcb     8,0                      ; sync field                        
                      (    rsdos_mmc.asm):03892                        fcb     3,$f5                                
                      (    rsdos_mmc.asm):03893                        fcb     1,$fe                    ; id address mark (am1)                                
                      (    rsdos_mmc.asm):03894         ; track, side, and sector numbers are inserted here
                      (    rsdos_mmc.asm):03895                        fcb     1,1                      ; sector size (256 byte sectors)                                       
                      (    rsdos_mmc.asm):03896                        fcb     1,$f7                    ; crc request                      
                      (    rsdos_mmc.asm):03897                        fcb     22,$4e                   ; gap ii (post-id gap)                                
                      (    rsdos_mmc.asm):03898                        fcb     12,0                     ; sync field                    
                      (    rsdos_mmc.asm):03899                        fcb     3,$f5                                
                      (    rsdos_mmc.asm):03900                        fcb     1,$fb                    ; data address mark (am2)                                  
                      (    rsdos_mmc.asm):03901                        fcb     0,$ff                    ; data field (256 bytes)                                 
                      (    rsdos_mmc.asm):03902                        fcb     1,$f7                    ; crc request                      
                      (    rsdos_mmc.asm):03903                        fcb     24,$4e                   ; gap iii (post data gap)                                   
                      (    rsdos_mmc.asm):03904         
                      (    rsdos_mmc.asm):03905                         endc
                      (    rsdos_mmc.asm):03906         
                      (    rsdos_mmc.asm):03907         ; dos command
D4AF 2654             (    rsdos_mmc.asm):03908         CmdDos         bne     ld742                    ; return if argument given                                      
D4B1 6E9FC00A         (    rsdos_mmc.asm):03909                        jmp     [dosvec]                 ; jump to the dos command                                     
                      (    rsdos_mmc.asm):03910         
D4B5                  (    rsdos_mmc.asm):03911         DoDiskReadWrite
D4B5 3404             (    rsdos_mmc.asm):03912                        pshs    b                        ; save accb                      
D4B7 C605             (    rsdos_mmc.asm):03913                        ldb     #$05                     ; 5 retries                   
D4B9 F70988           (    rsdos_mmc.asm):03914                        stb     attctr                   ; save retry count                            
D4BC 3504             (    rsdos_mmc.asm):03915                        puls    b                        ; restore accb                    
D4BE 8D62             (    rsdos_mmc.asm):03916         ld6fb          bsr     dskcon                   ; go execute command                                   
                      (    rsdos_mmc.asm):03917         
D4C0 0DF0             (    rsdos_mmc.asm):03918                        tst     dcsta                    ; check status                       
D4C2 270D             (    rsdos_mmc.asm):03919                        beq     ld70e                    ; branch if no errors                              
                      (    rsdos_mmc.asm):03920         
D4C4 96F0             (    rsdos_mmc.asm):03921         ld701          lda     dcsta                    ; get dskcon error status                                       
D4C6 C63C             (    rsdos_mmc.asm):03922                        ldb     #2*30                    ; 'write protected' error                                                              
D4C8 8540             (    rsdos_mmc.asm):03923                        bita    #$40                     ; check bit 6 of status                                
D4CA 2602             (    rsdos_mmc.asm):03924                        bne     ld70b                    ; branch if write protect error                                        
                      (    rsdos_mmc.asm):03925         
D4CC C628             (    rsdos_mmc.asm):03926         ld709          ldb     #2*20                    ; 'i/o error'                                                       
D4CE 7EAC46           (    rsdos_mmc.asm):03927         ld70b          jmp     SysErr                   ; jump to error driver                                    
                      (    rsdos_mmc.asm):03928         
D4D1 3402             (    rsdos_mmc.asm):03929         ld70e          pshs    a                        ; save acca                      
D4D3 96EA             (    rsdos_mmc.asm):03930                        lda     dcopc                    ; get operation code                             
D4D5 8103             (    rsdos_mmc.asm):03931                        cmpa    #$03                     ; check for write sector command                                         
D4D7 3502             (    rsdos_mmc.asm):03932                        puls    a                        ; restore acca                    
D4D9 262A             (    rsdos_mmc.asm):03933                        bne     ld742                    ; return if not write sector                                     
                      (    rsdos_mmc.asm):03934         
D4DB 7D0987           (    rsdos_mmc.asm):03935                        tst     dverfl                   ; check verify flag                             
D4DE 2725             (    rsdos_mmc.asm):03936                        beq     ld742                    ; return if no verify                              
                      (    rsdos_mmc.asm):03937         
D4E0 3456             (    rsdos_mmc.asm):03938                        pshs    u,x,b,a                  ; save registers                            
D4E2 8602             (    rsdos_mmc.asm):03939                        lda     #$02                     ; read operation code                             
D4E4 97EA             (    rsdos_mmc.asm):03940                        sta     dcopc                    ; store to dskcon parameter                                    
D4E6 DEEE             (    rsdos_mmc.asm):03941                        ldu     dcbpt                    ; point u to write buffer address                                          
D4E8 8E0700           (    rsdos_mmc.asm):03942                        ldx     #dbuf1                   ; address of verify buffer                                    
D4EB 9FEE             (    rsdos_mmc.asm):03943                        stx     dcbpt                    ; to dskcon variable                             
D4ED 8D33             (    rsdos_mmc.asm):03944                        bsr     dskcon                   ; go read sector                          
                      (    rsdos_mmc.asm):03945         
D4EF DFEE             (    rsdos_mmc.asm):03946                        stu     dcbpt                    ; restore write buffer                               
D4F1 8603             (    rsdos_mmc.asm):03947                        lda     #$03                     ; write op code                       
D4F3 97EA             (    rsdos_mmc.asm):03948                        sta     dcopc                    ; save in dskcon variable                                  
D4F5 96F0             (    rsdos_mmc.asm):03949                        lda     dcsta                    ; check status for the read operation                                              
D4F7 260D             (    rsdos_mmc.asm):03950                        bne     ld743                    ; branch if error                          
                      (    rsdos_mmc.asm):03951         
D4F9 5F               (    rsdos_mmc.asm):03952                        clrb                             ; check 256 bytes                      
D4FA A680             (    rsdos_mmc.asm):03953         ld737          lda     ,x+                      ; get byte from write buffer                                        
D4FC A1C0             (    rsdos_mmc.asm):03954                        cmpa    ,u+                      ; compare to read buffer                                
D4FE 2606             (    rsdos_mmc.asm):03955                        bne     ld743                    ; branch if not equal                              
                      (    rsdos_mmc.asm):03956         
D500 5A               (    rsdos_mmc.asm):03957                        decb                             ; decrement byte counter and                                 
D501 26F7             (    rsdos_mmc.asm):03958                        bne     ld737                    ; branch if not done                             
                      (    rsdos_mmc.asm):03959         
D503 3556             (    rsdos_mmc.asm):03960                        puls    a,b,x,u                  ; restore registers                               
D505 39               (    rsdos_mmc.asm):03961         ld742          rts                                          
                      (    rsdos_mmc.asm):03962         
D506 3556             (    rsdos_mmc.asm):03963         ld743          puls    a,b,x,u                  ; restore registers                                    
D508 7A0988           (    rsdos_mmc.asm):03964                        dec     attctr                   ; decrement the verify counter                                        
D50B 26B1             (    rsdos_mmc.asm):03965                        bne     ld6fb                    ; branch if more tries left                                    
                      (    rsdos_mmc.asm):03966         
D50D C648             (    rsdos_mmc.asm):03967                        ldb     #2*36                    ; 'verify error'                                                     
D50F 20BD             (    rsdos_mmc.asm):03968                        bra     ld70b                    ; jump to error handler                                
                      (    rsdos_mmc.asm):03969         
                      (    rsdos_mmc.asm):03970         ; verify command
D511 5F               (    rsdos_mmc.asm):03971         CmdVerify      clrb                             ; off flag = 0                         
D512 81AA             (    rsdos_mmc.asm):03972                        cmpa    #$aa                     ; off token ?                      
D514 2707             (    rsdos_mmc.asm):03973                        beq     ld75a                    ; yes              
                      (    rsdos_mmc.asm):03974         
D516 53               (    rsdos_mmc.asm):03975                        comb                             ; on flag = $ff                    
D517 8188             (    rsdos_mmc.asm):03976                        cmpa    #$88                     ; on token                   
D519 1026DD5A         (    rsdos_mmc.asm):03977                        lbne    BasSNError               ; branch to 'syntax error' if not on or off                                                     
                      (    rsdos_mmc.asm):03978         
D51D F70987           (    rsdos_mmc.asm):03979         ld75a          stb     dverfl                   ; set verify flag                                
D520 0E9F             (    rsdos_mmc.asm):03980                        jmp     BasChrGet                ; get next character from basic                                         
                      (    rsdos_mmc.asm):03981         
                      (    rsdos_mmc.asm):03982         
                      (    rsdos_mmc.asm):03983         ; dskcon routine
D522 3476             (    rsdos_mmc.asm):03984         dskcon         pshs    u,y,x,b,a                ; save registers                                    
D524 8605             (    rsdos_mmc.asm):03985                        lda     #$05                     ; get retry count and                             
D526 3402             (    rsdos_mmc.asm):03986                        pshs    a                        ; save it on the stack                            
D528 7F0985           (    rsdos_mmc.asm):03987         ld765          clr     rdytmr                   ; reset drive not ready timer                                            
D52B D6EB             (    rsdos_mmc.asm):03988                        ldb     dcdrv                    ; get drive number                           
D52D 8ED5EA           (    rsdos_mmc.asm):03989                        ldx     #ld89d                   ; point x to drive enable masks                                         
D530 B60986           (    rsdos_mmc.asm):03990                        lda     drgram                   ; get dskreg image                            
D533 84A8             (    rsdos_mmc.asm):03991                        anda    #$a8                     ; keep motor status, double density. halt enable                                                         
D535 AA85             (    rsdos_mmc.asm):03992                        ora     b,x                      ; 'or' in drive select data                                  
D537 8A20             (    rsdos_mmc.asm):03993                        ora     #$20                     ; 'or' in double density                                
D539 D6EC             (    rsdos_mmc.asm):03994                        ldb     dctrk                    ; get track number                           
D53B C116             (    rsdos_mmc.asm):03995                        cmpb    #22                      ; precompensation starts at track 22                                            
D53D 2502             (    rsdos_mmc.asm):03996                        blo     ld77e                    ; branch if less than 22                                 
                      (    rsdos_mmc.asm):03997         
D53F 8A10             (    rsdos_mmc.asm):03998                        ora     #$10                     ; turn on write precompensation if >= 22                                                
D541 1F89             (    rsdos_mmc.asm):03999         ld77e          tfr     a,b                      ; save partial image in accb                                        
D543 8A08             (    rsdos_mmc.asm):04000                        ora     #$08                     ; 'or' in motor on control bit                                      
D545 B70986           (    rsdos_mmc.asm):04001                        sta     drgram                   ; save image in ram                             
D548 B7FF40           (    rsdos_mmc.asm):04002                        sta     dskreg                   ; program the 1793 control register                                             
D54B C508             (    rsdos_mmc.asm):04003                        bitb    #$08                     ; = were motors already on?                                    
D54D 2600             (    rsdos_mmc.asm):04004                        bne     ld792                    ; = don't wait for it to come up to speed if already on                                                                
                      (    rsdos_mmc.asm):04005         
                      (    rsdos_mmc.asm):04006         ;               jsr     la7d1                    ; wait a while                       
                      (    rsdos_mmc.asm):04007         ;               jsr     la7d1                    ; wait some more for motor to come up to speed                                                       
                      (    rsdos_mmc.asm):04008         
D54F 8D38             (    rsdos_mmc.asm):04009         ld792          bsr     WaitFDCNotBusy           ; wait until not busy or time out                                               
                      (    rsdos_mmc.asm):04010         
D551 260A             (    rsdos_mmc.asm):04011                        bne     ld7a0                    ; branch if timed out (door open. no disk, no power. etc.)                                                                   
                      (    rsdos_mmc.asm):04012         
D553 0FF0             (    rsdos_mmc.asm):04013                        clr     dcsta                    ; clear status register                                
D555 8ED5E2           (    rsdos_mmc.asm):04014                        ldx     #DosFunctionTable        ; point to command jump vectors                                         
D558 D6EA             (    rsdos_mmc.asm):04015                        ldb     dcopc                    ; get command                      
D55A 58               (    rsdos_mmc.asm):04016                        aslb                             ; 2 bytes per command jump address                                       
D55B AD95             (    rsdos_mmc.asm):04017                        jsr     [b,x]                    ; go do it 
                      (    rsdos_mmc.asm):04018         
                      (    rsdos_mmc.asm):04019                           
D55D 3502             (    rsdos_mmc.asm):04020         ld7a0          puls    a                        ; get retry count                            
D55F D6F0             (    rsdos_mmc.asm):04021                        ldb     dcsta                    ; get status                     
D561 270B             (    rsdos_mmc.asm):04022                        beq     ld7b1                    ; branch if no errors                              
                      (    rsdos_mmc.asm):04023         
D563 4A               (    rsdos_mmc.asm):04024                        deca                             ; decrement retries counter                                
D564 2708             (    rsdos_mmc.asm):04025                        beq     ld7b1                    ; branch if no retries left                                    
                      (    rsdos_mmc.asm):04026         
D566 3402             (    rsdos_mmc.asm):04027                        pshs    a                        ; save retry count on stack                                 
D568 8D0B             (    rsdos_mmc.asm):04028                        bsr     DosFunctionRestore       ; restore head to track 0                                  
                      (    rsdos_mmc.asm):04029         
D56A 26F1             (    rsdos_mmc.asm):04030                        bne     ld7a0                    ; branch if seek error                               
                      (    rsdos_mmc.asm):04031         
D56C 20BA             (    rsdos_mmc.asm):04032                        bra     ld765                    ; go try command again if no error                                           
D56E 8678             (    rsdos_mmc.asm):04033         ld7b1          lda     #120                     ; 120 ;1/60 = 2 seconds (1/60 second for each irq interrupt)                                                                         
D570 B70985           (    rsdos_mmc.asm):04034                        sta     rdytmr                   ; wait 2 seconds before turning off motor                                                   
D573 35F6             (    rsdos_mmc.asm):04035                        puls    a,b,x,y,u,pc             ; restore registers - exit dskcon     
                      (    rsdos_mmc.asm):04036                                                      
                      (    rsdos_mmc.asm):04037         ; restore head to track 0
D575                  (    rsdos_mmc.asm):04038         DosFunctionRestore          
D575 8E097E           (    rsdos_mmc.asm):04039                        ldx     #dr0trk                  ; point to track table                                      
D578 D6EB             (    rsdos_mmc.asm):04040                        ldb     dcdrv                    ; get drive number                           
D57A 6F85             (    rsdos_mmc.asm):04041                        clr     b,x                      ; zero track number                          
                      (    rsdos_mmc.asm):04042         
                      (    rsdos_mmc.asm):04043         ;               lda     #WDRestore               ; restore head to track 0, unload the head                                                  
                      (    rsdos_mmc.asm):04044         ;               sta     fdcreg                   ; at start, 30 ms stepping rate                                         
                      (    rsdos_mmc.asm):04045         ;               exg     a,a                      ; =          
                      (    rsdos_mmc.asm):04046         ;               exg     a,a                      ; = wait for 1793 to respond to command                                              
D57C 8D0B             (    rsdos_mmc.asm):04047                        bsr     WaitFDCNotBusy                    ; wait till drive not busy                                   
                      (    rsdos_mmc.asm):04048         
                      (    rsdos_mmc.asm):04049         ;              bsr     MediumDelay                    ; wait some more                         
                      (    rsdos_mmc.asm):04050         
D57E 96EB             (    rsdos_mmc.asm):04051                        lda      dcdrv                   ; get drive
D580 5F               (    rsdos_mmc.asm):04052                        clrb                             ; get track (0)
D581 BDEE31           (    rsdos_mmc.asm):04053                        jsr      >MMC_SeekCheck          ; go seek it
                      (    rsdos_mmc.asm):04054         
D584 8410             (    rsdos_mmc.asm):04055                        anda    #$10                     ; 1793 status : keep only seek error                                             
D586 97F0             (    rsdos_mmc.asm):04056                        sta     dcsta                    ; save in dskcon status                                
D588                  (    rsdos_mmc.asm):04057         DosFunctionNOP          
D588 39               (    rsdos_mmc.asm):04058                         rts                                          
                      (    rsdos_mmc.asm):04059         
                      (    rsdos_mmc.asm):04060         ; wait for the 1793 to become unbusy. if it does not become unbusy,
                      (    rsdos_mmc.asm):04061         ; force an interrupt and issue a `drive not ready' 1793 error.
D589                  (    rsdos_mmc.asm):04062         WaitFDCNotBusy 
                      (    rsdos_mmc.asm):04063                         ifeq    1
                      (    rsdos_mmc.asm):04064                        ldx     Misc16BitScratch         ; get zero to x register - long wait                                                 
D589                  (    rsdos_mmc.asm):04065         ld7d3          leax    -1,x                     ; decrement long wait counter                                           
                      (    rsdos_mmc.asm):04066                        beq     ld7df                    ; lf not ready by now, force interrupt                                               
                      (    rsdos_mmc.asm):04067         
                      (    rsdos_mmc.asm):04068                        lda     fdcreg                   ; get 1793 status and test                                    
                      (    rsdos_mmc.asm):04069                        bita    #$01                     ; busy status bit                          
                      (    rsdos_mmc.asm):04070                        bne     ld7d3                    ; branch if busy                         
                      (    rsdos_mmc.asm):04071                         endc
D589 4F               (    rsdos_mmc.asm):04072                        clra
D58A 39               (    rsdos_mmc.asm):04073                        rts                                     
                      (    rsdos_mmc.asm):04074         
D58B                  (    rsdos_mmc.asm):04075         ld7df          
                      (    rsdos_mmc.asm):04076         ;               lda     #WDCmdForceInt           ; force interrupt command - terminate any command                                                              
                      (    rsdos_mmc.asm):04077         ;               sta     fdcreg                   ; in process. do not generate a 1793 interrupt request                                                                
                      (    rsdos_mmc.asm):04078         ;               exg     a,a                      ; wait before reading 1793                                 
                      (    rsdos_mmc.asm):04079         ;               exg     a,a                      ;        
                      (    rsdos_mmc.asm):04080         ;               lda     fdcreg                   ; reset intrq (fdc interrupt request)                                               
D58B 8680             (    rsdos_mmc.asm):04081                        lda     #$80                     ; return drive not ready status if the drive did not become unbusy                                                                          
D58D 97F0             (    rsdos_mmc.asm):04082                        sta     dcsta                    ; save dskcon status byte                                  
D58F 39               (    rsdos_mmc.asm):04083                        rts                                     
                      (    rsdos_mmc.asm):04084         
                      (    rsdos_mmc.asm):04085         ; medium delay
D590 8E222E           (    rsdos_mmc.asm):04086         MediumDelay    ldx     #8750                    ; delay for a while                                 
D593 301F             (    rsdos_mmc.asm):04087         ld7f3          leax    -1,x                     ; decrement delay counter and                                           
D595 26FC             (    rsdos_mmc.asm):04088                        bne     ld7f3                    ; branch if not done                             
                      (    rsdos_mmc.asm):04089         
D597 39               (    rsdos_mmc.asm):04090                        rts                                     
                      (    rsdos_mmc.asm):04091         
                      (    rsdos_mmc.asm):04092         ; read one sector
D598                  (    rsdos_mmc.asm):04093         DosFunctionReadSec
                      (    rsdos_mmc.asm):04094         
D598 8602             (    rsdos_mmc.asm):04095                        lda     #DosFnReadSec            ; $80 is read flag (1793 read sector)                                                  
                      (    rsdos_mmc.asm):04096         
                      (    rsdos_mmc.asm):04097         ;              cmpx    #$86a0                      ; skip two bytes                                
D59A 8C               (    rsdos_mmc.asm):04098                         fcb     Skip2                      ; cmpx
                      (    rsdos_mmc.asm):04099         ; write one sector
D59B                  (    rsdos_mmc.asm):04100         DosFunctionWriteSec
D59B 8603             (    rsdos_mmc.asm):04101                        lda     #DosFnWriteSec           ; $a0 is write flag (1793 write sector)                                                    
D59D 3402             (    rsdos_mmc.asm):04102                        pshs    a                           ; save read/write flag on stack                                     
                      (    rsdos_mmc.asm):04103                        
D59F 8E097E           (    rsdos_mmc.asm):04104                        ldx     #dr0trk                     ; point x to track number table in ram                                                 
D5A2 D6EB             (    rsdos_mmc.asm):04105                        ldb     dcdrv                       ; get drive number                           
D5A4 3A               (    rsdos_mmc.asm):04106                        abx                                 ; point x to correct drive's track byte                                           
D5A5 E684             (    rsdos_mmc.asm):04107                        ldb     ,x                          ; get track number of current head position                                                 
                      (    rsdos_mmc.asm):04108         ;               stb     fdcreg+1                    ; send to 1793 track register                                         
                      (    rsdos_mmc.asm):04109         ;               cmpb    dctrk                       ; compare to desired track                                    
                      (    rsdos_mmc.asm):04110         ;               beq     ld82c                       ; branch if on correct track                                     
D5A7 96EC             (    rsdos_mmc.asm):04111                        lda     dctrk                       ; get track desired                            
                      (    rsdos_mmc.asm):04112         ;               sta     fdcreg+3                    ; send to 1793 data register                                        
D5A9 A784             (    rsdos_mmc.asm):04113                        sta     ,x                          ; save in ram track image                               
                      (    rsdos_mmc.asm):04114                        
D5AB 96EB             (    rsdos_mmc.asm):04115                        lda      dcdrv                      ; get drive
D5AD D6EC             (    rsdos_mmc.asm):04116                        ldb      dctrk                      ; get track
D5AF BDEE31           (    rsdos_mmc.asm):04117                        jsr      >MMC_SeekCheck             ; go seek it
                      (    rsdos_mmc.asm):04118               
                      (    rsdos_mmc.asm):04119         ;               lda     #$17                        ; seek command for 1793: do not load the                                                
                      (    rsdos_mmc.asm):04120         ;               sta     fdcreg                      ; head at start, verify destination track,                                                    
                      (    rsdos_mmc.asm):04121         ;               exg     a,a                         ; 30 ms stepping rate - wait for                                       
                      (    rsdos_mmc.asm):04122         ;               exg     a,a                         ; valid status from 1793                               
                      (    rsdos_mmc.asm):04123         ;               bsr     ld7d1                       ; wait till not busy                             
                      (    rsdos_mmc.asm):04124         ;               bne     ld82a                       ; return if timed out                              
                      (    rsdos_mmc.asm):04125         ;               bsr     ld7f0                       ; wait some more                         
                      (    rsdos_mmc.asm):04126         
D5B2 8418             (    rsdos_mmc.asm):04127                        anda    #$18                        ; keep only seek error or crc error in id field                                                        
D5B4 2704             (    rsdos_mmc.asm):04128                        beq     ld82c                       ; branch if no errors - head on correct track                                                      
                      (    rsdos_mmc.asm):04129         
D5B6 97F0             (    rsdos_mmc.asm):04130                        sta     dcsta                       ; save in dskcon status                                
D5B8 3582             (    rsdos_mmc.asm):04131         ld82a          puls    a,pc                                      
                      (    rsdos_mmc.asm):04132         
                      (    rsdos_mmc.asm):04133         ; head positioned on correct track
D5BA 96ED             (    rsdos_mmc.asm):04134         ld82c          lda     dsec                        ; get sector number desired                                        
D5BC BDEE77           (    rsdos_mmc.asm):04135                        jsr      >MMC_SendHR                ; send to image. 
                      (    rsdos_mmc.asm):04136         ;               sta     fdcreg+2                    ; send to 1793 sector register                                          
                      (    rsdos_mmc.asm):04137         
                      (    rsdos_mmc.asm):04138         ;               ldx     #DoNMI                      ; point x to routine to be vectored                                             
                      (    rsdos_mmc.asm):04139         ;               stx     dnmivc                      ; to by nmi upon completion of disk i/o and save vector                                                                 
                      (    rsdos_mmc.asm):04140         
D5BF 9EEE             (    rsdos_mmc.asm):04141                        ldx     dcbpt                       ; point x to i/o buffer                                
                      (    rsdos_mmc.asm):04142         ;               lda     fdcreg                      ; reset intrq (fdc interrupt request)                                               
                      (    rsdos_mmc.asm):04143         ;               lda     drgram                      ; get dskreg image                            
                      (    rsdos_mmc.asm):04144         ;              ora     #$80                        ; set flag to enable 1793 to halt 6809                                              
                      (    rsdos_mmc.asm):04145         
                      (    rsdos_mmc.asm):04146                            
                      (    rsdos_mmc.asm):04147         
D5C1 3504             (    rsdos_mmc.asm):04148                        puls    b                           ; get read/write command from stack                                         
                      (    rsdos_mmc.asm):04149         ;               ldy     zero                        ; zero out y - timeout initial value                                            
D5C3 CEFF48           (    rsdos_mmc.asm):04150                        ldu     #fdcreg                     ; u points to 1793 interface registers                                                 
D5C6 730982           (    rsdos_mmc.asm):04151                        com     nmiflg                      ; nmi flag = $ff: enable nmi vector                                             
                      (    rsdos_mmc.asm):04152         ;               orcc    #$50                        ; disable firq,irq                           
                      (    rsdos_mmc.asm):04153         ;               stb     fdcreg                      ; send read/write command to 1793: single record, compare                                                                   
                      (    rsdos_mmc.asm):04154         ;               exg     a,a                         ; for side 0, no 15 ms delay, disable side select                                                        
                      (    rsdos_mmc.asm):04155         ;               exg     a,a                         ; compare, write data address mark (fb) - wait for status                                                                
                      (    rsdos_mmc.asm):04156         
                      (    rsdos_mmc.asm):04157         
D5C9 C102             (    rsdos_mmc.asm):04158                        cmpb    #DosFnReadSec               ; was this a read?                           
D5CB 2707             (    rsdos_mmc.asm):04159                        beq     DoReadData                  ; if so, go look for data                                  
                      (    rsdos_mmc.asm):04160         ; wait for the 1793 to acknowledge ready to write data
                      (    rsdos_mmc.asm):04161                         
D5CD 96EB             (    rsdos_mmc.asm):04162                        lda      dcdrv                      ; Get drive, x already contains buffer
D5CF BDEE0E           (    rsdos_mmc.asm):04163                        jsr      >MMC_WriteDOSSec           ; go write it
D5D2 2007             (    rsdos_mmc.asm):04164                        bra      ReadWriteDone              ; go here when done
                      (    rsdos_mmc.asm):04165          
                      (    rsdos_mmc.asm):04166                         ifeq    1
                      (    rsdos_mmc.asm):04167         
                      (    rsdos_mmc.asm):04168                        ldb     #$02                        ; drq mask bit                      
D5D4                  (    rsdos_mmc.asm):04169         ld85b          bitb    ,u                          ; is 1793 ready for a byte? (drq set in status byte)                                                                
                      (    rsdos_mmc.asm):04170                        bne     ld86b                       ; branch if so                       
                      (    rsdos_mmc.asm):04171                        leay    -1,y                        ; decrement wait timer                               
                      (    rsdos_mmc.asm):04172                        bne     ld85b                       ; keep waiting for the 1793 drq                                        
D5D4                  (    rsdos_mmc.asm):04173         ld863          clr     nmiflg                      ; reset nmi flag                               
                      (    rsdos_mmc.asm):04174                        andcc   #$af                        ; enable firq,irq                           
                      (    rsdos_mmc.asm):04175                        jmp     >ld7df                       ; force interrupt, set drive not ready error                                                     
                      (    rsdos_mmc.asm):04176         
                      (    rsdos_mmc.asm):04177         ; write a sector
D5D4                  (    rsdos_mmc.asm):04178         ld86b          ldb     ,x+                         ; get a byte from ram                                 
                      (    rsdos_mmc.asm):04179                        stb     fdcreg+3                    ; send it to 1793 data register                                           
                      (    rsdos_mmc.asm):04180                        sta     dskreg                      ; reprogram fdc control register                                          
                      (    rsdos_mmc.asm):04181                        bra     ld86b                       ; send more data                         
                      (    rsdos_mmc.asm):04182                        endc
                      (    rsdos_mmc.asm):04183                        
                      (    rsdos_mmc.asm):04184         ; wait for the 17933 to acknowledge ready to read data
D5D4                  (    rsdos_mmc.asm):04185         DoReadData     
D5D4 96EB             (    rsdos_mmc.asm):04186                        lda      dcdrv                      ; Get drive, x already contains buffer
D5D6 BDEDE0           (    rsdos_mmc.asm):04187                        jsr      >MMC_ReadDOSSec           ; go write it
D5D9 2000             (    rsdos_mmc.asm):04188                        bra      ReadWriteDone              ; go here when done
                      (    rsdos_mmc.asm):04189         
                      (    rsdos_mmc.asm):04190                         ifeq    1
                      (    rsdos_mmc.asm):04191                         ldb     #$02                        ; drq mask bit                           
D5DB                  (    rsdos_mmc.asm):04192         ld877          bitb    ,u                          ; does the 1793 have a byte? (drq set in status byte)                                                                 
                      (    rsdos_mmc.asm):04193                        bne     ld881                       ; yes, go read a sector                                
                      (    rsdos_mmc.asm):04194                        leay    -1,y                        ; decrement wait timer                               
                      (    rsdos_mmc.asm):04195                        bne     ld877                       ; keep waiting for 1793 drq                                    
                      (    rsdos_mmc.asm):04196                        bra     ld863                       ; generate drive not ready error                                         
                      (    rsdos_mmc.asm):04197                        
                      (    rsdos_mmc.asm):04198                         endc 
                      (    rsdos_mmc.asm):04199                         
                      (    rsdos_mmc.asm):04200         ; read a sector
D5DB                  (    rsdos_mmc.asm):04201         ld881          
                      (    rsdos_mmc.asm):04202                         ifeq    1
                      (    rsdos_mmc.asm):04203                         ldb     fdcreg+3                    ; get data byte from 1793 data register                                                        
                      (    rsdos_mmc.asm):04204                        stb     ,x+                         ; put it in ram                      
                      (    rsdos_mmc.asm):04205                        sta     dskreg                      ; reprogram fdc control register                                          
                      (    rsdos_mmc.asm):04206                        bra     ld881                       ; keep getting data                            
                      (    rsdos_mmc.asm):04207                         endc
                      (    rsdos_mmc.asm):04208                         
                      (    rsdos_mmc.asm):04209         ; branch here on completion of sector read/write
D5DB                  (    rsdos_mmc.asm):04210         ReadWriteDone   
D5DB 1CAF             (    rsdos_mmc.asm):04211                        andcc   #$af                        ; enable irq, firo                                 
D5DD 847C             (    rsdos_mmc.asm):04212                        anda    #$7c                        ; fault, record not found, crc error or lost data                                                          
D5DF 97F0             (    rsdos_mmc.asm):04213                        sta     dcsta                       ; save in dskcon status                                
D5E1 39               (    rsdos_mmc.asm):04214                        rts                                     
                      (    rsdos_mmc.asm):04215         
                      (    rsdos_mmc.asm):04216         ; dskcon operation code jump vectors
D5E2                  (    rsdos_mmc.asm):04217         DosFunctionTable          
D5E2 D575             (    rsdos_mmc.asm):04218                         fdb     DosFunctionRestore      ; restore head to track zero                                          
D5E4 D588             (    rsdos_mmc.asm):04219                         fdb     DosFunctionNOP          ; no op - return                         
D5E6 D598             (    rsdos_mmc.asm):04220                         fdb     DosFunctionReadSec      ; read sector                      
D5E8 D59B             (    rsdos_mmc.asm):04221                         fdb     DosFunctionWriteSec     ; write sector                       
                      (    rsdos_mmc.asm):04222         
                      (    rsdos_mmc.asm):04223         ; dskreg masks for disk drive select
D5EA 01               (    rsdos_mmc.asm):04224         ld89d          fcb     1                        ; drive sel 0                       
D5EB 02               (    rsdos_mmc.asm):04225                        fcb     2                        ; drive sel 1                  
D5EC 04               (    rsdos_mmc.asm):04226                        fcb     4                        ; drive sel 2                  
D5ED 40               (    rsdos_mmc.asm):04227                        fcb     $40                      ; drive sel 3                    
                      (    rsdos_mmc.asm):04228         
                      (    rsdos_mmc.asm):04229         ; nmi service
D5EE B60982           (    rsdos_mmc.asm):04230         dnmisv         lda     nmiflg                   ; get nmi flag                              
D5F1 2708             (    rsdos_mmc.asm):04231                        beq     ld8ae                    ; return if not active                               
                      (    rsdos_mmc.asm):04232         
D5F3 BE0983           (    rsdos_mmc.asm):04233                        ldx     dnmivc                   ; get new return vector                                 
D5F6 AF6A             (    rsdos_mmc.asm):04234                        stx     10,s                     ; store at stacked pc slot on stack                                           
D5F8 7F0982           (    rsdos_mmc.asm):04235                        clr     nmiflg                   ; reset nmi flag                          
D5FB 3B               (    rsdos_mmc.asm):04236         ld8ae          rti                                     
                      (    rsdos_mmc.asm):04237         
                      (    rsdos_mmc.asm):04238         
                      (    rsdos_mmc.asm):04239         ; irq service
D5FC B6FF03           (    rsdos_mmc.asm):04240         dirqsv         lda     pia0+3                   ; 63.5 micro second or 60 hz interrupt?                                                       
D5FF 2AFA             (    rsdos_mmc.asm):04241                        bpl     ld8ae                    ; return if 63.5 microsecond                                     
D601 B6FF02           (    rsdos_mmc.asm):04242                        lda     pia0+2                   ; reset 60 hz pia interrupt flag                                          
D604 B60985           (    rsdos_mmc.asm):04243                        lda     rdytmr                   ; get timer                     
D607 2711             (    rsdos_mmc.asm):04244                        beq     ld8cd                    ; branch if not active                               
                      (    rsdos_mmc.asm):04245         
D609 4A               (    rsdos_mmc.asm):04246                        deca                             ; decrement the timer                          
D60A B70985           (    rsdos_mmc.asm):04247                        sta     rdytmr                   ; save it                   
D60D 260B             (    rsdos_mmc.asm):04248                        bne     ld8cd                    ; branch if not time to turn off disk motors                                                     
                      (    rsdos_mmc.asm):04249         
D60F B60986           (    rsdos_mmc.asm):04250                        lda     drgram                   ; = get dskreg image                              
D612 84B0             (    rsdos_mmc.asm):04251                        anda    #$b0                     ; = turn all motors and drive selects off                                                  
D614 B70986           (    rsdos_mmc.asm):04252                        sta     drgram                   ; = put it back in ram image                                      
D617 B7FF40           (    rsdos_mmc.asm):04253                        sta     dskreg                   ; send to control register (motors off)                                                 
D61A 7E8955           (    rsdos_mmc.asm):04254         ld8cd          jmp     l8955                    ; jump to extended basic's irq handler                                                    
                      (    rsdos_mmc.asm):04255         
                      (    rsdos_mmc.asm):04256         
                      (    rsdos_mmc.asm):04257         ; this is the end of disk basic (except for the dos command at $df00).
                      (    rsdos_mmc.asm):04258         ; the code from this point to $df00 is garbage.
                      (    rsdos_mmc.asm):04259         ; dosbas 1.1 = 1686 wasted bytes
                      (    rsdos_mmc.asm):04260         
                      (    rsdos_mmc.asm):04261         ;                fcb     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                      (    rsdos_mmc.asm):04262         ;                fcb     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                      (    rsdos_mmc.asm):04263         ;                fcb     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                      (    rsdos_mmc.asm):04264         ;
                      (    rsdos_mmc.asm):04265         ;                fill    0,$600
                      (    rsdos_mmc.asm):04266         
                      (    rsdos_mmc.asm):04267         ;; this is the code for the dos command
                      (    rsdos_mmc.asm):04268         
                      (    rsdos_mmc.asm):04269         ;               org     $df00   
                      (    rsdos_mmc.asm):04270         
D61D 113F             (    rsdos_mmc.asm):04271         doscom         swi3                             ; do a software interrupt (#3)                                         
D61F 0F03             (    rsdos_mmc.asm):04272                        clr     BasGenCount              ; reset sector counter                                
D621 CC2600           (    rsdos_mmc.asm):04273                        ldd     #dosbuf                  ; ram load address for sector data                                             
D624 3406             (    rsdos_mmc.asm):04274                        pshs    b,a                      ; save ram load address                               
D626 BEC006           (    rsdos_mmc.asm):04275         ldf09          ldx     dskvar                   ; point x to dskcon variables                                            
D629 0C03             (    rsdos_mmc.asm):04276                        inc     BasGenCount              ; increment sector counter                                    
D62B 9603             (    rsdos_mmc.asm):04277                        lda     BasGenCount              ; get the sector counter                                  
D62D 8112             (    rsdos_mmc.asm):04278                        cmpa    #secmax                  ; loaded in 18 sectors? (one track)                                               
D62F 2222             (    rsdos_mmc.asm):04279                        bhi     ldf36                    ; yes - exit      
                      (    rsdos_mmc.asm):04280                        
D631 A703             (    rsdos_mmc.asm):04281                        sta     $03,x                    ; no - save sector number in dsec                                          
D633 CC0200           (    rsdos_mmc.asm):04282                        ldd     #$0200                   ; get fdc op code (read) and drive number (0)                                                       
D636 A784             (    rsdos_mmc.asm):04283                        sta     ,x                       ; save them in dskcon variables (bug - should be std ,x)                                                              
D638 8622             (    rsdos_mmc.asm):04284                        lda     #34                      ; get track number (34)                              
D63A A702             (    rsdos_mmc.asm):04285                        sta     $02,x                    ; save it in dskcon variables too                                          
D63C 3506             (    rsdos_mmc.asm):04286                        puls    a,b                      ; get ram load address                              
D63E ED04             (    rsdos_mmc.asm):04287                        std     $04,x                    ; and save it in the dskcon variables                                              
D640 8B01             (    rsdos_mmc.asm):04288                        adda    #$01                     ; add 256 (one sector) to ram load address (should be inca)                                                                    
D642 3406             (    rsdos_mmc.asm):04289                        pshs    b,a                      ; save new ram load address                                   
D644 AD9FC004         (    rsdos_mmc.asm):04290                        jsr     [dcnvec]                 ; go read a sector                              
                      (    rsdos_mmc.asm):04291         
D648 6D06             (    rsdos_mmc.asm):04292                        tst     $06,x                    ; check for errors                           
D64A 27DA             (    rsdos_mmc.asm):04293                        beq     ldf09                    ; keep reading if none                               
                      (    rsdos_mmc.asm):04294         
D64C 3506             (    rsdos_mmc.asm):04295                        puls    a,b                      ; pull load address off of the stack                                                 
D64E C628             (    rsdos_mmc.asm):04296                        ldb     #2*20                    ; 'io' error                                                   
D650 7EAC46           (    rsdos_mmc.asm):04297                        jmp     SysErr                   ; jump to error servicing routine                                          
                      (    rsdos_mmc.asm):04298         
D653 3506             (    rsdos_mmc.asm):04299         ldf36          puls    a,b                      ; pull ram load address off of the stack                                                
D655 FC2600           (    rsdos_mmc.asm):04300                        ldd     dosbuf                   ; get first two bytes of ram data                                           
D658 10834F53         (    rsdos_mmc.asm):04301                        cmpd    #"OS"                    ; look for 'os' (os9) at start of buffer                                                  
D65C 10274FA2         (    rsdos_mmc.asm):04302                        lbeq    dosbuf+2                 ; if 'os' then branch to data loaded in ram                                                        
                      (    rsdos_mmc.asm):04303         
D660 7F2600           (    rsdos_mmc.asm):04304                        clr     dosbuf                   ; otherwise clear the first two                                         
                      (    rsdos_mmc.asm):04305         
D663 7F2601           (    rsdos_mmc.asm):04306                        clr     dosbuf+1                 ; bytes of ram data                                     
D666 7EA0E8           (    rsdos_mmc.asm):04307                        jmp     bawmst                   ; jump to basic's warm start                                      
                      (    rsdos_mmc.asm):04308         
                      (    rsdos_mmc.asm):04309         
D669 CC3B3B           (    rsdos_mmc.asm):04310         dosini         ldd     #$3b3b                   ; two rti instructions                                
D66C FD0100           (    rsdos_mmc.asm):04311                        std     SecVecSWI3               ;           
D66F FD0102           (    rsdos_mmc.asm):04312                        std     SecVecSWI3+2             ; load the swi2 and swi3 jump                                         
D672 FD0104           (    rsdos_mmc.asm):04313                        std     SecVecSWI2+1             ; vectors with rtis                               
D675 39               (    rsdos_mmc.asm):04314         end            rts                                        
                      (    rsdos_mmc.asm):04315         
                      (    rsdos_mmc.asm):04316         
                      (    rsdos_mmc.asm):04317         ; end of the dos and dosini commands - the rest of the code
                      (    rsdos_mmc.asm):04318         ; to the end of the disk rom ($dfff) is garbage.
                      (    rsdos_mmc.asm):04319         ; dosbas 1.1 = 167 wasted bytes
                      (    rsdos_mmc.asm):04320         
                      (    rsdos_mmc.asm):04321                         ifne    0
                      (    rsdos_mmc.asm):04322         ;                org     $df80
                      (    rsdos_mmc.asm):04323         ;
                      (    rsdos_mmc.asm):04324         ; the following routine is (c) 2005, p.harvey-smith, and boots the coco into all ram mode
                      (    rsdos_mmc.asm):04325         ; this of course requires a coco with at least 64k.
                      (    rsdos_mmc.asm):04326         ;
                      (    rsdos_mmc.asm):04327         
                      (    rsdos_mmc.asm):04328         ;
                      (    rsdos_mmc.asm):04329         ; this routine copies the boot routine to the first graphics page.
                      (    rsdos_mmc.asm):04330         ; 
                      (    rsdos_mmc.asm):04331         
D676                  (    rsdos_mmc.asm):04332         start   leax    romcopy,pcr                     ; point to code to move
                      (    rsdos_mmc.asm):04333                 ldy     #$600                           ; point to destination, grapics page 0
                      (    rsdos_mmc.asm):04334                 ldu     #romcopylen                     ; get byte count
                      (    rsdos_mmc.asm):04335                 
D676                  (    rsdos_mmc.asm):04336         copyloop
                      (    rsdos_mmc.asm):04337                 lda     ,x+                             ; fetch a byte from source
                      (    rsdos_mmc.asm):04338                 sta     ,y+                             ; store in destination
                      (    rsdos_mmc.asm):04339                 leau    -1,u                            ; decrement count
                      (    rsdos_mmc.asm):04340                 cmpu    #$0                             ; done all ?
                      (    rsdos_mmc.asm):04341                 bne     copyloop                        ; no : do next
                      (    rsdos_mmc.asm):04342         
                      (    rsdos_mmc.asm):04343                 jmp     $600                            ; done, jump to copied code.
                      (    rsdos_mmc.asm):04344         
                      (    rsdos_mmc.asm):04345         
                      (    rsdos_mmc.asm):04346         ;
                      (    rsdos_mmc.asm):04347         ; this routine does the actual rom copy, it is first copied into ram at $600
                      (    rsdos_mmc.asm):04348         ; and then called, it switches backwards and forwards between rom and ram mode
                      (    rsdos_mmc.asm):04349         ; copying bytes.
                      (    rsdos_mmc.asm):04350         ;
                      (    rsdos_mmc.asm):04351         
D676                  (    rsdos_mmc.asm):04352         romcopy orcc    #$50                            ; disable inturrupts
                      (    rsdos_mmc.asm):04353                 ldx     #$8000                          ; point to beginning of rom
                      (    rsdos_mmc.asm):04354                 
D676                  (    rsdos_mmc.asm):04355         loop    clr     $ffde                           ; switch to rom mode
                      (    rsdos_mmc.asm):04356                 lda     ,x                              ; pickup a byte
                      (    rsdos_mmc.asm):04357                 clr     $ffdf                           ; switch to ram mode
                      (    rsdos_mmc.asm):04358                 sta     ,x+                             ; save byte in ram
                      (    rsdos_mmc.asm):04359                 cmpx    #$ff00                          ; done all bytes ?
                      (    rsdos_mmc.asm):04360                 bne     loop                            ; no : loop again
                      (    rsdos_mmc.asm):04361         
                      (    rsdos_mmc.asm):04362         
                      (    rsdos_mmc.asm):04363                 clr     $ffdf                           ; switch to ram mode
                      (    rsdos_mmc.asm):04364                 andcc   #$af                            ; yes : re-enable inturrupts
                      (    rsdos_mmc.asm):04365                 rts                                     ; return
                      (    rsdos_mmc.asm):04366         
D676                  (    rsdos_mmc.asm):04367         romcopyend
                      (    rsdos_mmc.asm):04368                 nop
                      (    rsdos_mmc.asm):04369                 
D676                  (    rsdos_mmc.asm):04370         romcopylen      equ     romcopyend-romcopy
                      (    rsdos_mmc.asm):04371                         endc
                      (    rsdos_mmc.asm):04372                         
D676                  (    rsdos_mmc.asm):04373         __rsdos_end
                      (    DragonMMC.asm):00142                         endc
                      (    DragonMMC.asm):00143         
D676                  (    DragonMMC.asm):00144         __dosspare      
D676 0000000000000000 (    DragonMMC.asm):00145                         zmb             ($e000-*)
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000
E000                  (    DragonMMC.asm):00146         __dosspare_end
                      (    DragonMMC.asm):00147                         
E000                  (    DragonMMC.asm):00148         __main
E000 444B             (    DragonMMC.asm):00149                         FCC     /DK/
E002 2008             (    DragonMMC.asm):00150                         BRA     RealMMCInit     
                      (    DragonMMC.asm):00151                         endc
                      (    DragonMMC.asm):00152         
                      (    DragonMMC.asm):00153         ;Util_SafeCopy
                      (    DragonMMC.asm):00154         ;               JMP             >DO_SafeCopy            ; Jump to safe copy routine     
                      (    DragonMMC.asm):00155         ;Util_RamCopy
                      (    DragonMMC.asm):00156         ;               JMP             >DO_RamCopy
E004                  (    DragonMMC.asm):00157         Util_Select     
E004 7EE02F           (    DragonMMC.asm):00158                         JMP             >DO_Select
                      (    DragonMMC.asm):00159         ;Util_AssignU16D
                      (    DragonMMC.asm):00160         ;               JMP             >DO_Assign16
                      (    DragonMMC.asm):00161         
E007 7EF2E7           (    DragonMMC.asm):00162                         jmp             >Inverse
                      (    DragonMMC.asm):00163                         
E00A                  (    DragonMMC.asm):00164         Signature:
E00A 2112             (    DragonMMC.asm):00165                         FDB             SignatureWord   ; So NMI chan check to see if we are paged in.
                      (    DragonMMC.asm):00166         ;
                      (    DragonMMC.asm):00167         ; Init Dos
                      (    DragonMMC.asm):00168         ; 
                      (    DragonMMC.asm):00169                         ifeq    BuildDos
E00C                  (    DragonMMC.asm):00170         MMCInit
                      (    DragonMMC.asm):00171                         else
E00C                  (    DragonMMC.asm):00172         RealMMCInit
                      (    DragonMMC.asm):00173                 endc
                      (    DragonMMC.asm):00174         
E00C 2033             (    DragonMMC.asm):00175                         bra             DoInit
                      (    DragonMMC.asm):00176                         
                      (    DragonMMC.asm):00177                         use     mmc_simple_func.asm
                      (c_simple_func.asm):00001         ;
                      (c_simple_func.asm):00002         ; Simple MMC functions.
                      (c_simple_func.asm):00003         ;
                      (c_simple_func.asm):00004         ; 2011-06-13 Phill Harvey-Smith.
                      (c_simple_func.asm):00005         ;
                      (c_simple_func.asm):00006         ; 2024-09-28, Moved into own function so could be included in early
                      (c_simple_func.asm):00007         ; part of rom that is the same for Dragon and CoCo. 
                      (c_simple_func.asm):00008         ;
                      (c_simple_func.asm):00009         ; Define MINIMUM to exclude code not needed by FLASH
                      (c_simple_func.asm):00010         ;
                      (c_simple_func.asm):00011         
                      (c_simple_func.asm):00012         ;
                      (c_simple_func.asm):00013         ; **** NOTE ****
                      (c_simple_func.asm):00014         ;
                      (c_simple_func.asm):00015         ; Send CMD_INIT_READ with MMC_sendCmdRaw *NOT* MMC_SendCmd
                      (c_simple_func.asm):00016         ;
E00E                  (c_simple_func.asm):00017         __mmc_simple_func
                      (c_simple_func.asm):00018         
                      (c_simple_func.asm):00019         ;
                      (c_simple_func.asm):00020         ; Send Command
                      (c_simple_func.asm):00021         ;
                      (c_simple_func.asm):00022         ; Entry a = command to send
                      (c_simple_func.asm):00023         ;
                      (c_simple_func.asm):00024         ; exit a = status code.
                      (c_simple_func.asm):00025         ;
                      (c_simple_func.asm):00026         
E00E                  (c_simple_func.asm):00027         MMC_SendCmd
E00E 8D07             (c_simple_func.asm):00028                         bsr             MMC_SendCmdRaw                  ; send the command
                      (c_simple_func.asm):00029         
                      (c_simple_func.asm):00030         ;               lda             #STATUS_FLAG_WRITTEN    ; Written flag
                      (c_simple_func.asm):00031         ;               anda    D_STATUS_REG                    ; is it set ?
                      (c_simple_func.asm):00032         ;               beq             MMC_SendCmdNoResult             ; no clear a and return
                      (c_simple_func.asm):00033         
E010 B6FF50           (c_simple_func.asm):00034                         lda             D_CMD_REG                               ; Get status (if any)
E013 4D               (c_simple_func.asm):00035                         tsta
E014 39               (c_simple_func.asm):00036                         rts                                                             ; return
                      (c_simple_func.asm):00037                         
E015                  (c_simple_func.asm):00038         MMC_SendCmdNoResult
                      (c_simple_func.asm):00039         
E015 4F               (c_simple_func.asm):00040                         clra                                                    ; flag no error
E016 39               (c_simple_func.asm):00041                         rts
                      (c_simple_func.asm):00042                         
                      (c_simple_func.asm):00043         ;
                      (c_simple_func.asm):00044         ; Send a command but don't read a result.
                      (c_simple_func.asm):00045         ;
                      (c_simple_func.asm):00046         
E017                  (c_simple_func.asm):00047         MMC_SendCmdRaw
E017 B7FF50           (c_simple_func.asm):00048                         sta             D_CMD_REG                               ; send the command
                      (c_simple_func.asm):00049         
                      (c_simple_func.asm):00050         ;
                      (c_simple_func.asm):00051         ; MMC_WaitNotBusy, waits for the Pico busy flag to be reset.
                      (c_simple_func.asm):00052         ;
E01A                  (c_simple_func.asm):00053         MMC_WaitNotBusy
                      (c_simple_func.asm):00054                 ifndef  EMULATE
                      (c_simple_func.asm):00055                 
E01A                  (c_simple_func.asm):00056         MMC_WaitNotBusyLoop        
                      (c_simple_func.asm):00057                         lda             D_STATUS_REG
                      (c_simple_func.asm):00058         ;               jsr             CON_HexByteAt0          
                      (c_simple_func.asm):00059                         tsta
                      (c_simple_func.asm):00060                         bmi             MMC_WaitNotBusyLoop             ; yes : keep waiting
                      (c_simple_func.asm):00061         
                      (c_simple_func.asm):00062                 endc
E01A 39               (c_simple_func.asm):00063                         rts
                      (c_simple_func.asm):00064         
                      (c_simple_func.asm):00065         ;
                      (c_simple_func.asm):00066         ; MMC_WaitPutLatchRead Send a byte in a to the AVR LATCH_REG and wait for it to read it
                      (c_simple_func.asm):00067         ;
E01B                  (c_simple_func.asm):00068         MMC_WaitPutLatchRead
E01B B7FF51           (c_simple_func.asm):00069                         sta             D_LATCH_REG                             ; write the data
E01E 20FA             (c_simple_func.asm):00070                         bra             MMC_WaitNotBusy
                      (c_simple_func.asm):00071         
                      (c_simple_func.asm):00072         ;
                      (c_simple_func.asm):00073         ; MMC_GetRAMCTRL
                      (c_simple_func.asm):00074         ; 
                      (c_simple_func.asm):00075         ; Return the current RAM_CTRL byte in a
                      (c_simple_func.asm):00076         ;
E020                  (c_simple_func.asm):00077         MMC_GetRAMCTRL
E020 86E8             (c_simple_func.asm):00078                         lda             #CMD_GET_RAM_CTRL               ; Get the RAM_CTRL register
                      (c_simple_func.asm):00079                         
                      (c_simple_func.asm):00080         ;
                      (c_simple_func.asm):00081         ; MMC_SendCmdLatchRead
                      (c_simple_func.asm):00082         ; 
                      (c_simple_func.asm):00083         ; Send command in a, and get single byte reply (from latch) in a
                      (c_simple_func.asm):00084         ;               
E022                  (c_simple_func.asm):00085         MMC_SendCmdLatchRead
E022 8DEA             (c_simple_func.asm):00086                         bsr             MMC_SendCmd                             ; send it
                      (c_simple_func.asm):00087                         
E024 B6FF51           (c_simple_func.asm):00088                         lda             D_LATCH_REG                             ; retrieve it.
E027 39               (c_simple_func.asm):00089                         rts
                      (c_simple_func.asm):00090         
                      (c_simple_func.asm):00091         ;
                      (c_simple_func.asm):00092         ; MMC_SetRAMCTRL
                      (c_simple_func.asm):00093         ; 
                      (c_simple_func.asm):00094         ; Set the RAM_CTRL byte in to the value in a
                      (c_simple_func.asm):00095         ;
                      (c_simple_func.asm):00096         
E028                  (c_simple_func.asm):00097         MMC_SetRAMCTRL
E028 8DF1             (c_simple_func.asm):00098                         bsr             MMC_WaitPutLatchRead    ; Put the new byte in the latch
E02A 86E9             (c_simple_func.asm):00099                         lda             #CMD_SET_RAM_CTRL               ; Set it.
E02C 8DE0             (c_simple_func.asm):00100                         bsr             MMC_SendCmd                             ; send it
E02E 39               (c_simple_func.asm):00101                         rts
                      (c_simple_func.asm):00102         
E02F                  (c_simple_func.asm):00103         __mmc_simple_func_end
                      (    DragonMMC.asm):00178                 
                      (    DragonMMC.asm):00179         ;
                      (    DragonMMC.asm):00180         ; First try and detect the machine type
                      (    DragonMMC.asm):00181         ;
E02F                  (    DragonMMC.asm):00182         DO_Select
                      (    DragonMMC.asm):00183                         
E02F 8DEF             (    DragonMMC.asm):00184                         bsr             MMC_GetRAMCTRL                  ; Get ram control reg
                      (    DragonMMC.asm):00185         
E031 84F7             (    DragonMMC.asm):00186                 anda    #D_SEL_DRAGON           ; Default to dragon
                      (    DragonMMC.asm):00187                 
E033 3402             (    DragonMMC.asm):00188                 pshs    a
E035 BDE337           (    DragonMMC.asm):00189                         jsr     >MachineDetect          ; Detect the machine
E038 3502             (    DragonMMC.asm):00190                         puls    a                                               ; note doesn't change flags
E03A 2702             (    DragonMMC.asm):00191                 beq     InitDragon
                      (    DragonMMC.asm):00192                 
E03C 8A08             (    DragonMMC.asm):00193                 ora     #D_SEL_COCO             ; Select CoCo version
                      (    DragonMMC.asm):00194                 
E03E                  (    DragonMMC.asm):00195         InitDragon
E03E 8DE8             (    DragonMMC.asm):00196                         bsr             MMC_SetRAMCTRL                  ; Update it
                      (    DragonMMC.asm):00197         
E040 39               (    DragonMMC.asm):00198                         rts
                      (    DragonMMC.asm):00199         
                      (    DragonMMC.asm):00200                         ifne    0
E041                  (    DragonMMC.asm):00201         DO_SWI
                      (    DragonMMC.asm):00202                         swi                                                             ; So we can test in MESS
                      (    DragonMMC.asm):00203                         rts
                      (    DragonMMC.asm):00204                         endc 
                      (    DragonMMC.asm):00205                         
                      (    DragonMMC.asm):00206         ;
                      (    DragonMMC.asm):00207         ; Init various low ram stuff, interrupt vectors, basic stub etc
                      (    DragonMMC.asm):00208         ; 
                      (    DragonMMC.asm):00209                 
E041                  (    DragonMMC.asm):00210         DoInit    
E041 BDE004           (    DragonMMC.asm):00211                         jsr             >Util_Select                    ; Select correct ROM version
E044 BDF053           (    DragonMMC.asm):00212                         jsr             >InterruptInit                  ; Initialize interrupt vectors
                      (    DragonMMC.asm):00213         
E047 8EE104           (    DragonMMC.asm):00214                 LDX     #RamVarPointer                  ; Point to rom copy of data to copy
E04A                  (    DragonMMC.asm):00215         MMCLC049   
E04A E680             (    DragonMMC.asm):00216                         LDB     ,X+                                             ; Get byte count byte
E04C 2707             (    DragonMMC.asm):00217                 BEQ     MMCLC054                                ; zero= end of table, exit copy
E04E EE81             (    DragonMMC.asm):00218                 LDU     ,X++                                    ; Get destination address
E050 BDA59A           (    DragonMMC.asm):00219                 JSR     >UtilCopyBXtoU                  ; do copy
E053 20F5             (    DragonMMC.asm):00220                 BRA     MMCLC049                                ; do next
                      (    DragonMMC.asm):00221         
E055                  (    DragonMMC.asm):00222         MMCLC054
E055 BDEC68           (    DragonMMC.asm):00223                         JSR             >SetPlatform                    ; Tell the Pico what our platform is
E058 BDEC72           (    DragonMMC.asm):00224                         JSR             >GetConfig                              ; get config byte
                      (    DragonMMC.asm):00225         
                      (    DragonMMC.asm):00226                         ifdef   BuildDos
E05B 9676             (    DragonMMC.asm):00227                         lda             <CFGByte                                ; Get config byte
                      (    DragonMMC.asm):00228                         
                      (    DragonMMC.asm):00229                         ifdef   EMULATE
E05D 8608             (    DragonMMC.asm):00230                 lda     #$08                                    ; show compile date only
E05F 9776             (    DragonMMC.asm):00231                 sta     <CFGByte
                      (    DragonMMC.asm):00232                         endc
                      (    DragonMMC.asm):00233                 
E061 8520             (    DragonMMC.asm):00234                         bita    #CFG_ENABLE_DOS                 ; is dos emulation enabled ?
E063 260F             (    DragonMMC.asm):00235                         bne             MMCNoMoveUSR                    ; dos emulation enabled don't move USR vectors
                      (    DragonMMC.asm):00236                         
                      (    DragonMMC.asm):00237                         endc
E065 8E00EC           (    DragonMMC.asm):00238                         LDX     #NewUsrVec                              ; Adjust usr vector base
E068 9FB0             (    DragonMMC.asm):00239                 STX     <BasUSRTableAddr        
E06A CEB44A           (    DragonMMC.asm):00240                 LDU     #BasFCError                             ; Setup the 10 usr vectors to point to BasFCError
E06D C60A             (    DragonMMC.asm):00241                 LDB     #$0A                                    ; do 10
E06F                  (    DragonMMC.asm):00242         MMCLC064   
E06F EF81             (    DragonMMC.asm):00243                         STU     ,X++                                    ; setup vector
E071 5A               (    DragonMMC.asm):00244                 DECB                                                    ; decrement count
E072 26FB             (    DragonMMC.asm):00245                 BNE     MMCLC064                                ; loop again if more to do
                      (    DragonMMC.asm):00246         
E074                  (    DragonMMC.asm):00247         MMCNoMoveUSR            
E074 8EE0FA           (    DragonMMC.asm):00248                 LDX     #ResetVector                    ; Setup new reset vector
E077 9F72             (    DragonMMC.asm):00249                 STX     <IndVecReset
E079 8655             (    DragonMMC.asm):00250                         lda             #$55                                    ; Mark reset vector valid
E07B 9771             (    DragonMMC.asm):00251                         sta             <WarmStartFlag
                      (    DragonMMC.asm):00252                                 
E07D 1CAF             (    DragonMMC.asm):00253                 ANDCC   #~(FlagIRQ+FlagFIRQ)    ; reenable inturrupts
                      (    DragonMMC.asm):00254                     
E07F 8E80E7           (    DragonMMC.asm):00255                 LDX     #BasSignonMess                  ; Print staandard Basic signon message
E082 BDB99C           (    DragonMMC.asm):00256                 JSR     >TextOutString
                      (    DragonMMC.asm):00257                 
E085 8EE344           (    DragonMMC.asm):00258                 LDX     #SignonMess-1
E088 BDB99C           (    DragonMMC.asm):00259                 JSR     >TextOutString
                      (    DragonMMC.asm):00260                 
E08B 9676             (    DragonMMC.asm):00261                 lda             <CFGByte                                ; Get config byte (as DosInit may have trashed it!)
E08D 8508             (    DragonMMC.asm):00262                         bita    #CFG_SHOW_COMPILE       ; show compile date?
E08F 2706             (    DragonMMC.asm):00263                 beq     CheckDateTime           ; nope
                      (    DragonMMC.asm):00264                 
E091 8EE363           (    DragonMMC.asm):00265                 LDX     #CompileDate-1          ; show compile date
E094 BDB99C           (    DragonMMC.asm):00266                 JSR     >TextOutString      
                      (    DragonMMC.asm):00267                 
E097                  (    DragonMMC.asm):00268         CheckDateTime
E097 9676             (    DragonMMC.asm):00269                 lda             <CFGByte                                ; Get config byte (as DosInit may have trashed it!)
E099 8510             (    DragonMMC.asm):00270                         bita    #CFG_SHOW_DATETIME      ; show date and time?
E09B 2703             (    DragonMMC.asm):00271                 beq     NoDateTime
                      (    DragonMMC.asm):00272                 
E09D BDEBB2           (    DragonMMC.asm):00273                 jsr     >ShowDateTime            ; Display date and time from RTC
E0A0                  (    DragonMMC.asm):00274         NoDateTime
                      (    DragonMMC.asm):00275                         
                      (    DragonMMC.asm):00276                         ifdef   BuildDos
E0A0 9676             (    DragonMMC.asm):00277                         lda             <CFGByte                                ; Get config byte
                      (    DragonMMC.asm):00278         
E0A2 8520             (    DragonMMC.asm):00279                         bita    #CFG_ENABLE_DOS                 ; is dos emulation enabled ?
E0A4 2703             (    DragonMMC.asm):00280                         BEQ             MMCNoDosInit                    ; nope : don't init
E0A6 7EC00F           (    DragonMMC.asm):00281                         JMP             DosInit                                 ; init dos if linked and enabled, exits to command mode
                      (    DragonMMC.asm):00282         
E0A9                  (    DragonMMC.asm):00283         MMCNoDosInit
                      (    DragonMMC.asm):00284                         endc
                      (    DragonMMC.asm):00285         
E0A9                  (    DragonMMC.asm):00286         MMC_InitDone
E0A9 BDE84B           (    DragonMMC.asm):00287                         jsr         >TestAutoBoot                       ; test for auto-boot, does not return if boots
                      (    DragonMMC.asm):00288         
E0AC 7EAC73           (    DragonMMC.asm):00289                 JMP     >BasCmdMode                             ; Jump to normal basic command mode
                      (    DragonMMC.asm):00290                 
                      (    DragonMMC.asm):00291         ;
                      (    DragonMMC.asm):00292         ; Dispatch routines for new functions/commands
                      (    DragonMMC.asm):00293         ;
                      (    DragonMMC.asm):00294         
E0AF                  (    DragonMMC.asm):00295         CmdDispatch   
E0AF 81FF             (    DragonMMC.asm):00296                         CMPA    #$FF                                    ; Token in range ?
E0B1 2704             (    DragonMMC.asm):00297                 BEQ     CmdDispatchSN                   ; nope : error
E0B3 80CE             (    DragonMMC.asm):00298                 SUBA    #DOSTokFirstC                   ; make our tokens zero based
E0B5 2A03             (    DragonMMC.asm):00299                 BPL     CmdCheckDOS                             
E0B7                  (    DragonMMC.asm):00300         CmdDispatchSN
E0B7 7EB277           (    DragonMMC.asm):00301                         JMP     >BasSNError                             ; Basic : ?SNerror
                      (    DragonMMC.asm):00302         
E0BA                  (    DragonMMC.asm):00303         CmdCheckDOS
E0BA 3402             (    DragonMMC.asm):00304                         pshs    a
E0BC 9676             (    DragonMMC.asm):00305                         lda             <CFGByte                                ; Get config byte
E0BE 8520             (    DragonMMC.asm):00306                         bita    #CFG_ENABLE_DOS                 ; is dos emulation enabled ?
E0C0 3502             (    DragonMMC.asm):00307                         puls    a                                               ; doesn't affect flags !
E0C2 2604             (    DragonMMC.asm):00308                         bne             CmdDOSOk                                ; dos emulation enabled accept all tokens
                      (    DragonMMC.asm):00309         
E0C4 8113             (    DragonMMC.asm):00310                         cmpa    #DOSTokCountC                   ; Is it a dos token with DOS disabled ?
E0C6 25EF             (    DragonMMC.asm):00311                         blo             CmdDispatchSN                   ; yes : ?SNError        
                      (    DragonMMC.asm):00312         
E0C8                  (    DragonMMC.asm):00313         CmdDOSOk
E0C8 8127             (    DragonMMC.asm):00314                         CMPA    #NoCmds                                 ; Is this one of our commands ?
E0CA 2406             (    DragonMMC.asm):00315                 BCC     JumpToNextStubCmd               ; nope : try next stub (if any)
E0CC 8EE11D           (    DragonMMC.asm):00316                 LDX     #CommandDispatchTable   ; point to table of commands
E0CF 7EADD4           (    DragonMMC.asm):00317                         JMP             BasDoDispatch                   ; go execute it !
                      (    DragonMMC.asm):00318                         
E0D2                  (    DragonMMC.asm):00319         JumpToNextStubCmd
                      (    DragonMMC.asm):00320                         ifdef   Dragon
                      (    DragonMMC.asm):00321                         JMP     [>DBasStub2+DStubResJumpOfs]
                      (    DragonMMC.asm):00322                         else
E0D2 6E9F0141         (    DragonMMC.asm):00323                         jmp             [>CBasStub3+DStubResJumpOfs]
                      (    DragonMMC.asm):00324                         endc
                      (    DragonMMC.asm):00325         
                      (    DragonMMC.asm):00326         ;
                      (    DragonMMC.asm):00327         ; On entering this routine, the function code has been left shifted 1 bit.
                      (    DragonMMC.asm):00328         ; This has the effect of discarding the top bit and converting the remaining
                      (    DragonMMC.asm):00329         ; bits to an offset into the jump table.
                      (    DragonMMC.asm):00330         ;
E0D6                  (    DragonMMC.asm):00331         FuncDispatch   
E0D6 C044             (    DragonMMC.asm):00332                         SUBB    #((DOSTokFirstF*2)&$FF)         ; Make function offset zero based
E0D8 2A02             (    DragonMMC.asm):00333                 BPL     LC691                                   ; is this a basic function ?
E0DA 20DB             (    DragonMMC.asm):00334                 BRA     CmdDispatchSN                   ; yep : error
                      (    DragonMMC.asm):00335         
E0DC C120             (    DragonMMC.asm):00336         LC691   CMPB    #((NoFunc+1)*2)                 ; is this function handled by us ?
E0DE 2416             (    DragonMMC.asm):00337                 BCC     JumpToNextStubFn                ; nope : try next stub
                      (    DragonMMC.asm):00338                         
E0E0 3402             (    DragonMMC.asm):00339                         pshs    a
E0E2 9676             (    DragonMMC.asm):00340                         lda             <CFGByte                                ; Get config byte
E0E4 8520             (    DragonMMC.asm):00341                         bita    #CFG_ENABLE_DOS                 ; is dos emulation enabled ?
E0E6 3502             (    DragonMMC.asm):00342                         puls    a                                               ; doesn't affect flags !
E0E8 2604             (    DragonMMC.asm):00343                         bne             FuncDOSOk                               ; dos emulation enabled accept all tokens
                      (    DragonMMC.asm):00344         
E0EA C10A             (    DragonMMC.asm):00345                         cmpb    #(DOSTokCountF*2)               ; Is it a dos token with DOS disabled ?
E0EC 25C9             (    DragonMMC.asm):00346                         blo             CmdDispatchSN                   ; yes : ?SNError        
                      (    DragonMMC.asm):00347                 
E0EE                  (    DragonMMC.asm):00348         FuncDOSOk               
E0EE 8EE16B           (    DragonMMC.asm):00349                 LDX     #FunctionDipatchTable
E0F1 AD95             (    DragonMMC.asm):00350                 JSR     [B,X]
E0F3 7EB143           (    DragonMMC.asm):00351                         JMP             VarGetExprCC
                      (    DragonMMC.asm):00352         
E0F6                  (    DragonMMC.asm):00353         JumpToNextStubFn
                      (    DragonMMC.asm):00354         
                      (    DragonMMC.asm):00355                         ifdef   Dragon
                      (    DragonMMC.asm):00356                         JMP     [>DBasStub2+DStubFuncsJumpOfs]
                      (    DragonMMC.asm):00357                         else
E0F6 6E9F0146         (    DragonMMC.asm):00358                         JMP     [>CBasStub3+DStubFuncsJumpOfs]
                      (    DragonMMC.asm):00359                         endc
                      (    DragonMMC.asm):00360         
                      (    DragonMMC.asm):00361         ;
                      (    DragonMMC.asm):00362         ; New reset vector
                      (    DragonMMC.asm):00363         ;
                      (    DragonMMC.asm):00364         
E0FA                  (    DragonMMC.asm):00365         ResetVector   
E0FA 12               (    DragonMMC.asm):00366                         NOP                                                             ; Main ROM checks for reset->NOP
E0FB 4F               (    DragonMMC.asm):00367                 CLRA                                                    ; Reset DP=0
E0FC 1F8B             (    DragonMMC.asm):00368                 TFR     A,DP            
                      (    DragonMMC.asm):00369                         
                      (    DragonMMC.asm):00370                         ifdef   BuildDos
E0FE BDC0BF           (    DragonMMC.asm):00371                         jsr             DOSResetVector                  ; Reset dos
                      (    DragonMMC.asm):00372                         endc
                      (    DragonMMC.asm):00373                         
                      (    DragonMMC.asm):00374         ;        LDA     #$35                                   ; Re-enable NMI
                      (    DragonMMC.asm):00375         ;        STA     PIA0CRB
                      (    DragonMMC.asm):00376                 
E101 7E80C0           (    DragonMMC.asm):00377                         JMP             WarmStart                               ; Jump back to Main ROM reset routine
                      (    DragonMMC.asm):00378         
E104                  (    DragonMMC.asm):00379         RamVarPointer   
                      (    DragonMMC.asm):00380         ; New basic dispatch stub
                      (    DragonMMC.asm):00381         ;
                      (    DragonMMC.asm):00382         ; The Dragon in an unexpanded state has both Colour basic an Extended colour basic
                      (    DragonMMC.asm):00383         ; in the same rom, and so only has one command table, so we put our commainds in
                      (    DragonMMC.asm):00384         ; the second stub.
                      (    DragonMMC.asm):00385         ; The CoCo has CB & ECB in seperate roms, and so already has two command tables
                      (    DragonMMC.asm):00386         ; therefore our commands must go in the third table.
                      (    DragonMMC.asm):00387         ;
E104 14               (    DragonMMC.asm):00388                 FCB     StubLen                                 ; No bytes
                      (    DragonMMC.asm):00389         
                      (    DragonMMC.asm):00390                         ifdef   Dragon
                      (    DragonMMC.asm):00391         ; Dragon
                      (    DragonMMC.asm):00392                 FDB     DBasStub1                               ; address to copy
                      (    DragonMMC.asm):00393                         else
                      (    DragonMMC.asm):00394         ;CoCo ECB only !                
E105 0134             (    DragonMMC.asm):00395                 FDB     CBasStub2                               ; address to copy
                      (    DragonMMC.asm):00396                         endc
                      (    DragonMMC.asm):00397         ;
                      (    DragonMMC.asm):00398         ; Stub for our new commands
                      (    DragonMMC.asm):00399         ;
                      (    DragonMMC.asm):00400         ; note NoCmds & No Funcs defined below....
E107                  (    DragonMMC.asm):00401         NewStub
E107 27               (    DragonMMC.asm):00402                 FCB     NoCmds                                  ; No of commands
E108 E189             (    DragonMMC.asm):00403                 FDB     CmdNames                                ; command list
E10A E0AF             (    DragonMMC.asm):00404                 FDB     CmdDispatch                             ; command dispatch routine
E10C 0F               (    DragonMMC.asm):00405                 FCB     NoFunc                                  ; No of functions
E10D E253             (    DragonMMC.asm):00406                 FDB     FuncNames                               ; function list
E10F E0D6             (    DragonMMC.asm):00407                 FDB     FuncDispatch                    ; function dispatch table
                      (    DragonMMC.asm):00408         
                      (    DragonMMC.asm):00409         ;
                      (    DragonMMC.asm):00410         ; New null terminating stub
                      (    DragonMMC.asm):00411         ;
E111 00               (    DragonMMC.asm):00412                 FCB     $00                                             ; No of commands
E112 0000             (    DragonMMC.asm):00413                 FDB     $0000                                   ; Null list
E114 B277             (    DragonMMC.asm):00414                 FDB     BasSNError                              ; command dispatch 
E116 00               (    DragonMMC.asm):00415                 FCB     $00                                             ; no of functions
E117 0000             (    DragonMMC.asm):00416                 FDB     $0000                                   ; function dispatch
E119 B277             (    DragonMMC.asm):00417                 FDB     BasSNError
     0014             (    DragonMMC.asm):00418         StubLen EQU             (*-NewStub)
                      (    DragonMMC.asm):00419                
E11B 00               (    DragonMMC.asm):00420                 FCB     $00                                             ; No bytes : terminate copy table
E11C 00               (    DragonMMC.asm):00421                 FCB     $00
                      (    DragonMMC.asm):00422         
                      (    DragonMMC.asm):00423         ;
                      (    DragonMMC.asm):00424         ; Command routine pointers
                      (    DragonMMC.asm):00425         ; 
                      (    DragonMMC.asm):00426         
E11D                  (    DragonMMC.asm):00427         CommandDispatchTable
                      (    DragonMMC.asm):00428                         use             dos_cmd_addrs.asm
E11D                  (dos_cmd_addrs.asm):00001         DosCommandDispatchTable   
E11D CB86             (dos_cmd_addrs.asm):00002                 fdb     CmdDir                   ; dir / ce                      
E11F CDA2             (dos_cmd_addrs.asm):00003                 fdb     CmdDrive                 ; drive / cf                     
E121 CF99             (dos_cmd_addrs.asm):00004                 fdb     CmdField                 ; field / d0                     
E123 D039             (dos_cmd_addrs.asm):00005                 fdb     CmdFiles                 ; files / d1                     
E125 C5CC             (dos_cmd_addrs.asm):00006                 fdb     CmdKill                  ; kill / d2                   
E127 C925             (dos_cmd_addrs.asm):00007                 fdb     CmdLoad                  ; load / d3                   
E129 CFDF             (dos_cmd_addrs.asm):00008                 fdb     CmdLset                  ; lset / d4                   
E12B C916             (dos_cmd_addrs.asm):00009                 fdb     CmdMerge                 ; merge / d5                     
E12D CEF8             (dos_cmd_addrs.asm):00010                 fdb     CmdRename                ; rename / d6                       
E12F CFDE             (dos_cmd_addrs.asm):00011                 fdb     CmdRset                  ; rset / d7                   
E131 C8BD             (dos_cmd_addrs.asm):00012                 fdb     CmdSave                  ; save / d8                   
E133 CF43             (dos_cmd_addrs.asm):00013                 fdb     CmdWrite                 ; write / d9                     
E135 D511             (dos_cmd_addrs.asm):00014                 fdb     CmdVerify                ; verify / da                       
E137 D110             (dos_cmd_addrs.asm):00015                 fdb     CmdUnload                ; unload / db                       
E139 D476             (dos_cmd_addrs.asm):00016                 fdb     CmdDskini                ; CmdDskini /dc                      
E13B D13F             (dos_cmd_addrs.asm):00017                 fdb     CmdBackup                ; backup / dd                       
E13D D296             (dos_cmd_addrs.asm):00018                 fdb     CmdCopy                  ; copy / de                   
E13F D3CA             (dos_cmd_addrs.asm):00019                 fdb     CmdDski                  ; dski$ / df                    
E141 D43F             (dos_cmd_addrs.asm):00020                 fdb     CmdDsko                  ; dsko$ / e0                    
E143 D4AF             (dos_cmd_addrs.asm):00021                 fdb     CmdDos                   ; dos / e1                 
                      (dos_cmd_addrs.asm):00022                         
                      (dos_cmd_addrs.asm):00023         ; Note no spaces must appear in the EQU below!
     0014             (dos_cmd_addrs.asm):00024         DosCMDTableLen          EQU     (*-DosCommandDispatchTable)/2
E145 E54F             (    DragonMMC.asm):00429                         FDB             CmdMCas 
E147 E4A0             (    DragonMMC.asm):00430                         FDB             CmdMMirror
E149 E3CD             (    DragonMMC.asm):00431                         FDB             CmdMMount
E14B E2E5             (    DragonMMC.asm):00432                         FDB             CmdHelp
E14D E50B             (    DragonMMC.asm):00433                         FDB             CmdRamBoot
E14F E588             (    DragonMMC.asm):00434                         FDB             CmdCat
E151 E65C             (    DragonMMC.asm):00435                         FDB             CmdMDelete
E153 E6B3             (    DragonMMC.asm):00436                         FDB             CmdMSave
E155 E729             (    DragonMMC.asm):00437                         FDB             CmdMLoad
E157 E8A0             (    DragonMMC.asm):00438                         FDB             CmdCartLoad
E159 E439             (    DragonMMC.asm):00439                         FDB             CmdTapeRun
E15B E5F9             (    DragonMMC.asm):00440                         FDB             CmdCWD
E15D EBD6             (    DragonMMC.asm):00441                         FDB             CmdSetCFG
E15F E8FC             (    DragonMMC.asm):00442                         FDB             CmdReTok
E161 EAB1             (    DragonMMC.asm):00443                         FDB             CmdMDisk
E163 E496             (    DragonMMC.asm):00444                         FDB             CmdRewind
E165 EBA2             (    DragonMMC.asm):00445                 FDB     CmdSetDT
E167 E60A             (    DragonMMC.asm):00446                         FDB             CmdMKDir
E169 E67D             (    DragonMMC.asm):00447                         FDB             CmdMFile
                      (    DragonMMC.asm):00448         
                      (    DragonMMC.asm):00449         ; Note no spaces must appear in the EQU below!
     0027             (    DragonMMC.asm):00450         CMDTableLen             EQU     (*-CommandDispatchTable)/2
                      (    DragonMMC.asm):00451         
                      (    DragonMMC.asm):00452         
E16B                  (    DragonMMC.asm):00453         FunctionDipatchTable   
                      (    DragonMMC.asm):00454                         use             dos_func_addrs.asm
E16B                  (os_func_addrs.asm):00001         DosFunctionDipatchTable
E16B CCD1             (os_func_addrs.asm):00002                 fdb     FuncCvn                 ; cvn / a2                      
E16D CD79             (os_func_addrs.asm):00003                 fdb     FuncFree                ; free / a3                   
E16F CCED             (os_func_addrs.asm):00004                 fdb     FuncLoc                 ; loc / a4                 
E171 CD14             (os_func_addrs.asm):00005                 fdb     FuncLof                 ; lof / a5                 
E173 CCDF             (os_func_addrs.asm):00006                 fdb     FuncMkn                 ; mkn$ / a6                   
E175 B277             (os_func_addrs.asm):00007                 fdb     BasSNError              ; as / a7               
                      (os_func_addrs.asm):00008                         
                      (os_func_addrs.asm):00009         ; Note no spaces must appear in the EQU below!
     0006             (os_func_addrs.asm):00010         DosFuncTableLen         EQU     (*-DosFunctionDipatchTable)/2
E177 B44A             (    DragonMMC.asm):00455                         FDB     BasFCError
E179 E618             (    DragonMMC.asm):00456                 FDB             FuncCWD
E17B E649             (    DragonMMC.asm):00457                         FDB             FuncFindFirst
E17D E64B             (    DragonMMC.asm):00458                         FDB             FuncFindNext
E17F E3FB             (    DragonMMC.asm):00459                         FDB             FuncCFType
E181 EC0D             (    DragonMMC.asm):00460                         FDB             FUNCGetCFG
E183 EBA7             (    DragonMMC.asm):00461                 FDB     FuncGetDT
E185 EB65             (    DragonMMC.asm):00462                 FDB     FuncGetIName
E187 E614             (    DragonMMC.asm):00463                 FDB             FuncGetSnapDir
                      (    DragonMMC.asm):00464                         
                      (    DragonMMC.asm):00465         ; Note no spaces must appear in the EQU below!
     000F             (    DragonMMC.asm):00466         FuncTableLen    EQU     (*-FunctionDipatchTable)/2
                      (    DragonMMC.asm):00467                 
E189                  (    DragonMMC.asm):00468         CmdNames   
                      (    DragonMMC.asm):00469                         use             dos_cmd_names.asm
E189                  (dos_cmd_names.asm):00001         DosCmdNames   
E189 4449D2           (dos_cmd_names.asm):00002                 fcs     /DIR/                   ; $CE           
E18C 44524956C5       (dos_cmd_names.asm):00003                 fcs     /DRIVE/                 ; $CF
E191 4649454CC4       (dos_cmd_names.asm):00004                 fcs     /FIELD/                 ; $D0
E196 46494C45D3       (dos_cmd_names.asm):00005                 fcs     /FILES/                 ; $D1 
E19B 4B494CCC         (dos_cmd_names.asm):00006                 fcs     /KILL/                  ; $D2
E19F 4C4F41C4         (dos_cmd_names.asm):00007                 fcs     /LOAD/                  ; $D3
E1A3 4C5345D4         (dos_cmd_names.asm):00008                 fcs     /LSET/                  ; $D4
E1A7 4D455247C5       (dos_cmd_names.asm):00009                 fcs     /MERGE/                 ; $D5
E1AC 52454E414DC5     (dos_cmd_names.asm):00010                 fcs     /RENAME/                ; $D6
E1B2 525345D4         (dos_cmd_names.asm):00011                 fcs     /RSET/                  ; $D7
E1B6 534156C5         (dos_cmd_names.asm):00012                 fcs     /SAVE/                  ; $D8
E1BA 57524954C5       (dos_cmd_names.asm):00013                 fcs     /WRITE/                 ; $D9
E1BF 5645524946D9     (dos_cmd_names.asm):00014                 fcs     /VERIFY/                ; $DA
E1C5 554E4C4F41C4     (dos_cmd_names.asm):00015                 fcs     /UNLOAD/                ; $DB
E1CB 44534B494EC9     (dos_cmd_names.asm):00016                 fcs     /DSKINI/                ; $DC
E1D1 4241434B55D0     (dos_cmd_names.asm):00017                 fcs     /BACKUP/                ; $DD
E1D7 434F50D9         (dos_cmd_names.asm):00018                 fcs     /COPY/                  ; $DE
E1DB 44534B49A4       (dos_cmd_names.asm):00019                 fcs     /DSKI$/                 ; $DE
E1E0 44534B4FA4       (dos_cmd_names.asm):00020                 fcs     /DSKO$/                 ; $E0
E1E5 444FD3           (dos_cmd_names.asm):00021                 fcs     /DOS/                   ; $E1
                      (    DragonMMC.asm):00470         
E1E8 4D4341D3         (    DragonMMC.asm):00471                         FCS             /MCAS/
E1EC 4D4D4952524FD2   (    DragonMMC.asm):00472                         FCS             /MMIRROR/
E1F3 4D4D4F554ED4     (    DragonMMC.asm):00473                         FCS             /MMOUNT/
E1F9 48454CD0         (    DragonMMC.asm):00474                         FCS             /HELP/
E1FD 52414D424F4FD4   (    DragonMMC.asm):00475                         FCS             /RAMBOOT/
E204 4341D4           (    DragonMMC.asm):00476                         FCS             /CAT/
E207 4D44454C4554C5   (    DragonMMC.asm):00477                         FCS             /MDELETE/
E20E 4D534156C5       (    DragonMMC.asm):00478                         FCS             /MSAVE/
E213 4D4C4F41C4       (    DragonMMC.asm):00479                         FCS             /MLOAD/
E218 4D434152544C4F41 (    DragonMMC.asm):00480                         FCS             /MCARTLOAD/
     C4
E221 4D544150455255CE (    DragonMMC.asm):00481                         FCS             /MTAPERUN/
E229 4357C4           (    DragonMMC.asm):00482                         FCS             /CWD/
E22C 4D5345544346C7   (    DragonMMC.asm):00483                         FCS             /MSETCFG/
E233 5245544FCB       (    DragonMMC.asm):00484                         FCS             /RETOK/
E238 4D444953CB       (    DragonMMC.asm):00485                         FCS             /MDISK/
E23D 524557494EC4     (    DragonMMC.asm):00486                         FCS             /REWIND/
E243 4D53455444D4     (    DragonMMC.asm):00487                 FCS     /MSETDT/
E249 4D4B4449D2       (    DragonMMC.asm):00488                         FCS             /MKDIR/
E24E 4D46494CC5       (    DragonMMC.asm):00489                         FCS             /MFILE/
                      (    DragonMMC.asm):00490                         
E253                  (    DragonMMC.asm):00491         FuncNames   
                      (    DragonMMC.asm):00492                         use             dos_func_names.asm
                      (os_func_names.asm):00001         ;
                      (os_func_names.asm):00002         ; New Function names table
                      (os_func_names.asm):00003         ;
                      (os_func_names.asm):00004         
E253                  (os_func_names.asm):00005         DosFuncNames           
E253 4356CE           (os_func_names.asm):00006                 fcs     /CVN/                   ; $A2
E256 465245C5         (os_func_names.asm):00007                 fcs     /FREE/                  ; $A3
E25A 4C4FC3           (os_func_names.asm):00008                 fcs     /LOC/                   ; $A4
E25D 4C4FC6           (os_func_names.asm):00009                 fcs     /LOF/                   ; $A5
E260 4D4B4EA4         (os_func_names.asm):00010                 fcs     /MKN$/                  ; $A6
E264 41D3             (os_func_names.asm):00011                 fcs     /AS/                    ; $A7
                      (    DragonMMC.asm):00493                         
E266 5645D2           (    DragonMMC.asm):00494                         FCS             /VER/
E269 5744A4           (    DragonMMC.asm):00495                         FCS             /WD$/
E26C 46494E4446495253 (    DragonMMC.asm):00496                         FCS             /FINDFIRST$/
     54A4
E276 46494E444E455854 (    DragonMMC.asm):00497                         FCS             /FINDNEXT$/
     A4
E27F 4346545950C5     (    DragonMMC.asm):00498                         FCS             /CFTYPE/
E285 4D4745544346C7   (    DragonMMC.asm):00499                         FCS             /MGETCFG/
E28C 4D4745544454A4   (    DragonMMC.asm):00500                 FCS     /MGETDT$/
E293 4D474554494E414D (    DragonMMC.asm):00501                 FCS     /MGETINAME$/
     45A4
E29D 5344A4           (    DragonMMC.asm):00502                 FCS             /SD$/
                      (    DragonMMC.asm):00503         
     0027             (    DragonMMC.asm):00504         NoCmds  EQU             CMDTableLen
     000F             (    DragonMMC.asm):00505         NoFunc  EQU     FuncTableLen
                      (    DragonMMC.asm):00506         
                      (    DragonMMC.asm):00507         ;
                      (    DragonMMC.asm):00508         ; Get string from command into temp var.
                      (    DragonMMC.asm):00509         ; Exits :
                      (    DragonMMC.asm):00510         ;       x = pointer to string data
                      (    DragonMMC.asm):00511         ;       b = length of string
                      (    DragonMMC.asm):00512         ;
                      (    DragonMMC.asm):00513         
E2A0                  (    DragonMMC.asm):00514         GetCmdStrXB
E2A0 BDB156           (    DragonMMC.asm):00515                 JSR     >VarGetStr                              ; get string into temp variable
E2A3 BDB654           (    DragonMMC.asm):00516                         JSR             >BasGetStrLenAddr               ; Get pointer in x len in b
E2A6 39               (    DragonMMC.asm):00517                         rts
                      (    DragonMMC.asm):00518         
                      (    DragonMMC.asm):00519         ;
                      (    DragonMMC.asm):00520         ; Get a filename and send to MMC
                      (    DragonMMC.asm):00521         ;
                      (    DragonMMC.asm):00522         
E2A7                  (    DragonMMC.asm):00523         GetSendFileName
E2A7 8DF7             (    DragonMMC.asm):00524                         bsr             GetCmdStrXB                             ; Get string from basic
                      (    DragonMMC.asm):00525         
E2A9 170A01           (    DragonMMC.asm):00526                         lbsr    MMC_SendName                    ; Send name to MMC
E2AC 39               (    DragonMMC.asm):00527                         rts
                      (    DragonMMC.asm):00528         
E2AD                  (    DragonMMC.asm):00529         GetSendFileName2
E2AD 8DF1             (    DragonMMC.asm):00530                         bsr             GetCmdStrXB                             ; Get string from basic
                      (    DragonMMC.asm):00531         
E2AF 1709FD           (    DragonMMC.asm):00532                         lbsr    MMC_SendName2                   ; Send name to MMC
E2B2 39               (    DragonMMC.asm):00533                         rts
                      (    DragonMMC.asm):00534                         
                      (    DragonMMC.asm):00535         ;
                      (    DragonMMC.asm):00536         ; Get a filename and send to MMC folowed by command in a
                      (    DragonMMC.asm):00537         ;
                      (    DragonMMC.asm):00538                         
E2B3                  (    DragonMMC.asm):00539         CmdSendFilenameCmd
E2B3                  (    DragonMMC.asm):00540         CmdSendStringCmd
E2B3 3402             (    DragonMMC.asm):00541                         pshs    a
E2B5 8DF0             (    DragonMMC.asm):00542                         bsr             GetSendFileName                 ; get filename and send it
                      (    DragonMMC.asm):00543                         
E2B7 3502             (    DragonMMC.asm):00544                         puls    a                                               ; Restore read or write
E2B9 17FD52           (    DragonMMC.asm):00545                         lbsr    MMC_SendCmd                             ; Open file
E2BC 170016           (    DragonMMC.asm):00546                         lbsr    CheckError                              ; Bomb out on error
                      (    DragonMMC.asm):00547                         
E2BF 4F               (    DragonMMC.asm):00548                         clra
E2C0 39               (    DragonMMC.asm):00549                         rts
                      (    DragonMMC.asm):00550         
E2C1                  (    DragonMMC.asm):00551         CkComma
E2C1 3404             (    DragonMMC.asm):00552                         pshs    b                                               ; save b
E2C3 C62C             (    DragonMMC.asm):00553                         ldb             #Comma                                  ; comma character
E2C5 E19F00A6         (    DragonMMC.asm):00554                         cmpb    [BasAddrSigByte]                
E2C9 3584             (    DragonMMC.asm):00555                         puls    b,pc                                    ; flags untouched
                      (    DragonMMC.asm):00556         
E2CB                  (    DragonMMC.asm):00557         CkOpenBrac
E2CB 3404             (    DragonMMC.asm):00558                         pshs    b                                               ; save b
E2CD C628             (    DragonMMC.asm):00559                         ldb             #OpenBrac                               ; comma character
E2CF E19F00A6         (    DragonMMC.asm):00560                         cmpb    [BasAddrSigByte]                
E2D3 3584             (    DragonMMC.asm):00561                         puls    b,pc                                    ; flags untouched
                      (    DragonMMC.asm):00562                         
E2D5                  (    DragonMMC.asm):00563         CheckError
E2D5 4D               (    DragonMMC.asm):00564                         tsta                                                    ; Test for error, if bit 7 set
E2D6 2B01             (    DragonMMC.asm):00565                         bmi             ReportError                             ; Yes : error
E2D8 39               (    DragonMMC.asm):00566                         rts
                      (    DragonMMC.asm):00567         
E2D9                  (    DragonMMC.asm):00568         ReportError     
E2D9 2601             (    DragonMMC.asm):00569                         bne             FlagError                               ; Yes : flag it
E2DB 39               (    DragonMMC.asm):00570                         rts
                      (    DragonMMC.asm):00571                 
E2DC                  (    DragonMMC.asm):00572         FlagError
E2DC 170BCB           (    DragonMMC.asm):00573                         lbsr    CON_WriteHexByte                ; Write to screen as hex
E2DF 170C56           (    DragonMMC.asm):00574                         lbsr    CON_EOL
E2E2 7EB44A           (    DragonMMC.asm):00575                         jmp             BasFCError
                      (    DragonMMC.asm):00576                 
                      (    DragonMMC.asm):00577         
E2E5                  (    DragonMMC.asm):00578         CmdHelp 
E2E5 8158             (    DragonMMC.asm):00579                 cmpa    #'X'                    ; helpx ?
E2E7 2606             (    DragonMMC.asm):00580                 bne     CmdHelpNoX              ; no skip
                      (    DragonMMC.asm):00581                 
E2E9 9D9F             (    DragonMMC.asm):00582                 jsr             <BasChrGet                              ; skip first char       
E2EB 86FF             (    DragonMMC.asm):00583                 lda     #$FF                    ; flag extended.
E2ED 2001             (    DragonMMC.asm):00584                 bra     CmdHelpMain             ; skip forward
                      (    DragonMMC.asm):00585                 
E2EF                  (    DragonMMC.asm):00586         CmdHelpNoX
E2EF 4F               (    DragonMMC.asm):00587                 clra                            ; Flag normal
E2F0                  (    DragonMMC.asm):00588         CmdHelpMain
E2F0 3402             (    DragonMMC.asm):00589                 pshs    a
                      (    DragonMMC.asm):00590                 
E2F2 8EE344           (    DragonMMC.asm):00591                 ldx     #SignonMess-1               ; Print signon message including compile date
E2F5 BDB99C           (    DragonMMC.asm):00592                 JSR     >TextOutString
                      (    DragonMMC.asm):00593                 
E2F8 8EE363           (    DragonMMC.asm):00594                 LDX     #CompileDate-1          ; show compile date
E2FB BDB99C           (    DragonMMC.asm):00595                 JSR     >TextOutString      
                      (    DragonMMC.asm):00596                         
E2FE 8EE388           (    DragonMMC.asm):00597                         ldx         #IFVerMess-1                        ; print IF ver message
E301 BDB99C           (    DragonMMC.asm):00598                         JSR     >TextOutString
                      (    DragonMMC.asm):00599                         
E304 86E0             (    DragonMMC.asm):00600                         lda             #CMD_GET_FW_VER                 ; Get firmware version
E306 BDE022           (    DragonMMC.asm):00601                         jsr         >MMC_SendCmdLatchRead       ; send command get version                      
E309 BDEF5D           (    DragonMMC.asm):00602                         jsr         >CON_NdotN                          ; Write msn.lsn
                      (    DragonMMC.asm):00603                                 
E30C BDEF38           (    DragonMMC.asm):00604                 jsr         >CON_EOL
                      (    DragonMMC.asm):00605                         
E30F 3502             (    DragonMMC.asm):00606                 puls    a                       ; retrieve flag
E311 4D               (    DragonMMC.asm):00607                 tsta                            ; Check it
E312 2708             (    DragonMMC.asm):00608                 beq     CmdHelpLoopExit         ; Not extended : exit
                      (    DragonMMC.asm):00609                 
                      (    DragonMMC.asm):00610         ; HelpX, also display AVR firmware & Bootloader compile dates.
                      (    DragonMMC.asm):00611                 
E314 86E0             (    DragonMMC.asm):00612                 lda             #CMD_GET_FW_VER                 ; Get firmware version
E316 8D06             (    DragonMMC.asm):00613                         bsr     CmdGetSend64            ; send command display string
                      (    DragonMMC.asm):00614                         
E318 86E1             (    DragonMMC.asm):00615                 lda             #CMD_GET_BL_VER                 ; Get bootloader version
E31A 8D02             (    DragonMMC.asm):00616                         bsr     CmdGetSend64            ; send command display string
                      (    DragonMMC.asm):00617                                 
E31C                  (    DragonMMC.asm):00618         CmdHelpLoopExit
E31C 4F               (    DragonMMC.asm):00619                         clra
E31D 39               (    DragonMMC.asm):00620                         rts
                      (    DragonMMC.asm):00621         
E31E                  (    DragonMMC.asm):00622         CmdGetSend64
E31E BDE00E           (    DragonMMC.asm):00623                 jsr         >MMC_SendCmd                        ; send the command
                      (    DragonMMC.asm):00624         
E321 8620             (    DragonMMC.asm):00625                         lda     #CMD_INIT_READ                  ; Read compile message
E323 BDE017           (    DragonMMC.asm):00626                         jsr         >MMC_SendCmdRaw                     
                      (    DragonMMC.asm):00627                 
E326 C640             (    DragonMMC.asm):00628                         ldb             #64                                             ; 64 chars max.
                      (    DragonMMC.asm):00629         
E328                  (    DragonMMC.asm):00630         GetSendBBytes
E328 BDECCA           (    DragonMMC.asm):00631                         jsr         >MMC_WaitGetWritten         ; Wait for byte
                      (    DragonMMC.asm):00632                         
E32B 4D               (    DragonMMC.asm):00633                         tsta                                                    ; test a
E32C 2706             (    DragonMMC.asm):00634                         beq             GetSendBBytesExit               ; Zero : exit loop
                      (    DragonMMC.asm):00635                         
E32E BDA30A           (    DragonMMC.asm):00636                         jsr             >BasicScreenOut                 ; output character
                      (    DragonMMC.asm):00637                         
E331 5A               (    DragonMMC.asm):00638                         decb                                                    ; decrement character count
E332 26F4             (    DragonMMC.asm):00639                         bne             GetSendBBytes                   ; loop if more
                      (    DragonMMC.asm):00640                         
E334                  (    DragonMMC.asm):00641         GetSendBBytesExit
E334 7EEF38           (    DragonMMC.asm):00642                         jmp             >CON_EOL                                ; newline & return
                      (    DragonMMC.asm):00643         
                      (    DragonMMC.asm):00644         ;
                      (    DragonMMC.asm):00645         ; Detect Dragon or CoCo, returns cc.z = 1 if Dragon 
                      (    DragonMMC.asm):00646         ;
                      (    DragonMMC.asm):00647                         
E337                  (    DragonMMC.asm):00648         MachineDetect
E337 8EB4BC           (    DragonMMC.asm):00649                         ldx     #$B4BC                  ; Dragon ROM contains the word DRAGON at $B4BC.
E33A EC81             (    DragonMMC.asm):00650                 ldd             ,x++                                    ; looks for 'DRAGON' string 
E33C E381             (    DragonMMC.asm):00651                         addd    ,x++
E33E E381             (    DragonMMC.asm):00652                         addd    ,x++
E340 1083D4E7         (    DragonMMC.asm):00653                         cmpd    #$D4E7                                  ; Sum of the letters of 'DR' + 'AG' + 'ON'
E344 39               (    DragonMMC.asm):00654                         rts
                      (    DragonMMC.asm):00655         
E345                  (    DragonMMC.asm):00656         __main_end
                      (    DragonMMC.asm):00657         
                      (    DragonMMC.asm):00658         ; Messages
                      (    DragonMMC.asm):00659                         use             message.asm
                      (      message.asm):00001         ;
                      (      message.asm):00002         ; Message.asm : text messages.
                      (      message.asm):00003         ;
                      (      message.asm):00004         
E345                  (      message.asm):00005         __message
                      (      message.asm):00006         
                      (      message.asm):00007                 ifne    0
E345                  (      message.asm):00008         MessPressAnyKey   
                      (      message.asm):00009                         FCB     $00
                      (      message.asm):00010                 FCC     /PRESS ANY KEY     /
                      (      message.asm):00011                 FCB     $0D
                      (      message.asm):00012                 FCB     $00
                      (      message.asm):00013                 endc
                      (      message.asm):00014         
E345                  (      message.asm):00015         SignonMess      
                      (      message.asm):00016                 IFdef   Dragon
                      (      message.asm):00017                 FCC     /DRAGON/
                      (      message.asm):00018                 ELSE
E345 434F434F         (      message.asm):00019                 FCC     /COCO/
                      (      message.asm):00020                 ENDC
                      (      message.asm):00021                 
E349 205049434F2D5344 (      message.asm):00022                 FCC     / PICO-SD V1.00 BETA/
     2056312E30302042
     455441
                      (      message.asm):00023                 
                      (      message.asm):00024                 IFGT DEVEL
E35C 2D646576656C     (      message.asm):00025                 FCC     /-devel/
                      (      message.asm):00026                 ENDC
                      (      message.asm):00027                 
E362 0D               (      message.asm):00028                 FCB     $0D
E363 00               (      message.asm):00029                 FCB     $00
E364                  (      message.asm):00030         CompileDate        
E364 434F4D50494C4544 (      message.asm):00031                 FCC     /COMPILED: /
     3A20
                      (      message.asm):00032                 use     datetime.asm
E36E 323032352D31312D (     datetime.asm):00001          FCC "2025-11-09 14:28:35"
     30392031343A3238
     3A3335
                      (      message.asm):00033                 
E381 0D               (      message.asm):00034                 FCB     $0D
E382 00               (      message.asm):00035                 FCB     $00
                      (      message.asm):00036         
E383                  (      message.asm):00037         RTCMess 
E383 5254433A20       (      message.asm):00038                 FCC     /RTC: /
E388 00               (      message.asm):00039                 FCB     $00
                      (      message.asm):00040                 
                      (      message.asm):00041         ;                01234567890123456789012345678901
                      (      message.asm):00042         ;               '1234 12 12 1234 1234 1234 12 12
E389                  (      message.asm):00043         IFVerMess
E389 5049434F20465720 (      message.asm):00044                 FCC     'PICO FW V' 
     56
E392 00               (      message.asm):00045                 FCB     $00
                      (      message.asm):00046         
                      (      message.asm):00047         ;BLVerMess       
                      (      message.asm):00048         ;       FCC     'BLD FW V'
                      (      message.asm):00049         ;       FCB     $00
                      (      message.asm):00050         
E393                  (      message.asm):00051         DeleteMess
E393 41524520594F5520 (      message.asm):00052                 FCC     'ARE YOU SURE (Y/N)'
     535552452028592F
     4E29
E3A5 00               (      message.asm):00053                 FCB     $00
                      (      message.asm):00054                         
E3A6                  (      message.asm):00055         MoreMess
E3A6 4D4F52453A       (      message.asm):00056                 FCC     'MORE:'
E3AB 00               (      message.asm):00057                 FCB     $00
                      (      message.asm):00058         ;                01234567890123456789012345678901
                      (      message.asm):00059         ;               '1234 12 12 1234 1234 1234 12 12
E3AC                  (      message.asm):00060         RegNames
E3AC 2050432020204120 (      message.asm):00061                 FCC     ' PC   A  B  X    Y    U   DP CC'
     2042202058202020
     2059202020205520
     20204450204343
E3CB 0D00             (      message.asm):00062                 FCB     $0D,$00
                      (      message.asm):00063         
                      (      message.asm):00064                 ifne    0
E3CD                  (      message.asm):00065         CROKMess
                      (      message.asm):00066                 FCB     $0D
E3CD                  (      message.asm):00067         OKMess
                      (      message.asm):00068                 FCC     'OK'
                      (      message.asm):00069                 FCB     $0D,$00
                      (      message.asm):00070                 endc
                      (      message.asm):00071                         
                      (      message.asm):00072                         
E3CD                  (      message.asm):00073         __message_end
                      (      message.asm):00074                 
                      (      message.asm):00075                 
                      (    DragonMMC.asm):00660                 
                      (    DragonMMC.asm):00661         ; Command includes
                      (    DragonMMC.asm):00662                         use             cmds_tape.asm
                      (    cmds_tape.asm):00001         ;
                      (    cmds_tape.asm):00002         ; cmds_tape.asm : Cassette emulation commands.
                      (    cmds_tape.asm):00003         ;
                      (    cmds_tape.asm):00004         
E3CD                  (    cmds_tape.asm):00005         __cmd_tape
                      (    cmds_tape.asm):00006         
                      (    cmds_tape.asm):00007         ;
                      (    cmds_tape.asm):00008         ; Note some routines make calls / returns into the Dragon and CoCo roms.
                      (    cmds_tape.asm):00009         ; Please remember to define them so they assemble correctly on *BOTH* 
                      (    cmds_tape.asm):00010         ; machines.
                      (    cmds_tape.asm):00011         ; 
                      (    cmds_tape.asm):00012                         ifdef   Dragon
E3CD                  (    cmds_tape.asm):00013         CloadMEntry             EQU             $A095
E3CD                  (    cmds_tape.asm):00014         CloadEntry              EQU             $B6E1
E3CD                  (    cmds_tape.asm):00015         ClearEntry              EQU             $8424
E3CD                  (    cmds_tape.asm):00016         CloseFilesEntry EQU             $B663
E3CD                  (    cmds_tape.asm):00017         BasicLoop               EQU             $849F
                      (    cmds_tape.asm):00018                         else
     A502             (    cmds_tape.asm):00019         CloadMEntry             EQU             $A502
     A4A3             (    cmds_tape.asm):00020         CloadEntry              EQU             $A4A3
     AE6F             (    cmds_tape.asm):00021         ClearEntry              EQU             $AE6F
     A42D             (    cmds_tape.asm):00022         CloseFilesEntry EQU             $A42D
     AD9E             (    cmds_tape.asm):00023         BasicLoop               EQU             $AD9E
                      (    cmds_tape.asm):00024                         endc
                      (    cmds_tape.asm):00025                 
     00A8             (    cmds_tape.asm):00026         ScannerExit     EQU     $00A8    
                      (    cmds_tape.asm):00027         
                      (    cmds_tape.asm):00028         
     0000             (    cmds_tape.asm):00029         FTBasic equ             0
     0002             (    cmds_tape.asm):00030         FTCode  equ             2
                      (    cmds_tape.asm):00031         
                      (    cmds_tape.asm):00032         
E3CD                  (    cmds_tape.asm):00033         CmdMMount
E3CD 1F89             (    cmds_tape.asm):00034                         tfr             a,b                                             ; keep current next char
E3CF 9D9F             (    cmds_tape.asm):00035                         jsr             <BasChrGet                              ; skip first char       
                      (    cmds_tape.asm):00036                 
E3D1 C152             (    cmds_tape.asm):00037                         cmpb    #'R'                                    ; MMountR ?
E3D3 270B             (    cmds_tape.asm):00038                         beq             CmdMRMount                              ; Yep insert, read only
                      (    cmds_tape.asm):00039                 
E3D5 C157             (    cmds_tape.asm):00040                         cmpb    #'W'                                    ; MMountW ?
E3D7 2711             (    cmds_tape.asm):00041                         beq             CmdMWMount                              ; Yep insert, write only
                      (    cmds_tape.asm):00042                 
E3D9 C143             (    cmds_tape.asm):00043                         cmpb    #'C'                                    ; MMountC ?
E3DB 2716             (    cmds_tape.asm):00044                         beq             CmdMUNMount                             ; Yep, unmount
                      (    cmds_tape.asm):00045                 
E3DD 7EB277           (    cmds_tape.asm):00046                         jmp             >BasSNError                             ; no : ?SN Error
                      (    cmds_tape.asm):00047                         
                      (    cmds_tape.asm):00048         ;
                      (    cmds_tape.asm):00049         ; Mount a cas file for input.
                      (    cmds_tape.asm):00050         ;
                      (    cmds_tape.asm):00051         ; syntax :
                      (    cmds_tape.asm):00052         ;       mrmount "filename"
                      (    cmds_tape.asm):00053         ;
                      (    cmds_tape.asm):00054         
E3E0                  (    cmds_tape.asm):00055         CmdMRMount
E3E0                  (    cmds_tape.asm):00056         CmdMRMountEntry 
E3E0 8600             (    cmds_tape.asm):00057                         lda             #CAS_FILE                               ; open default file
E3E2 17FC36           (    cmds_tape.asm):00058                         lbsr    MMC_WaitPutLatchRead    ; send file id to latch register
                      (    cmds_tape.asm):00059         
E3E5 8611             (    cmds_tape.asm):00060                         lda             #CMD_FILE_OPEN_READ             ; Open file
                      (    cmds_tape.asm):00061                         
E3E7                  (    cmds_tape.asm):00062         CmdMMountCommon
E3E7 16FEC9           (    cmds_tape.asm):00063                         lbra    CmdSendFilenameCmd
                      (    cmds_tape.asm):00064         
                      (    cmds_tape.asm):00065         ;
                      (    cmds_tape.asm):00066         ; Mount a cas file for output.
                      (    cmds_tape.asm):00067         ;
                      (    cmds_tape.asm):00068         ; syntax :
                      (    cmds_tape.asm):00069         ;       mwmount "filename"
                      (    cmds_tape.asm):00070         ;
                      (    cmds_tape.asm):00071         
E3EA                  (    cmds_tape.asm):00072         CmdMWMount
E3EA 8600             (    cmds_tape.asm):00073                         lda             #CAS_FILE                               ; open default file
E3EC 17FC2C           (    cmds_tape.asm):00074                         lbsr    MMC_WaitPutLatchRead    ; send file id to latch register
                      (    cmds_tape.asm):00075         
E3EF 8613             (    cmds_tape.asm):00076                         lda             #CMD_FILE_OPEN_WRITE    ; Open file
E3F1 20F4             (    cmds_tape.asm):00077                         bra             CmdMMountCommon                 ; rest same as rmount
                      (    cmds_tape.asm):00078         
                      (    cmds_tape.asm):00079         ;
                      (    cmds_tape.asm):00080         ; Unmount a cas file, closing it and flushing any output.
                      (    cmds_tape.asm):00081         ;
                      (    cmds_tape.asm):00082         
E3F3                  (    cmds_tape.asm):00083         CmdMUNMount
                      (    cmds_tape.asm):00084         ;               jsr             <BasChrGet                              ; skip first char               
E3F3 1708DA           (    cmds_tape.asm):00085                         lbsr    MMC_CloseFile                   ; Close tape file
E3F6 17FEDC           (    cmds_tape.asm):00086                         lbsr    CheckError                              ; Check for error
E3F9 4F               (    cmds_tape.asm):00087                         clra                                                    
E3FA 39               (    cmds_tape.asm):00088                         rts
                      (    cmds_tape.asm):00089         
                      (    cmds_tape.asm):00090         ;
                      (    cmds_tape.asm):00091         ; Get the filetype of the next file on (emulated) tape
                      (    cmds_tape.asm):00092         ; 
                      (    cmds_tape.asm):00093         ; Syntax :
                      (    cmds_tape.asm):00094         ;       X=CFTYPE
                      (    cmds_tape.asm):00095         
                      (    cmds_tape.asm):00096         
E3FB                  (    cmds_tape.asm):00097         FuncCFType
E3FB 8145             (    cmds_tape.asm):00098                 cmpa    #'E'                    ; Exec: get exec address
E3FD 271C             (    cmds_tape.asm):00099                 beq     GetCFExecD
                      (    cmds_tape.asm):00100                 
E3FF 814C             (    cmds_tape.asm):00101                 cmpa    #'L'                    ; Load, get load address
E401 271C             (    cmds_tape.asm):00102                 beq     GetCFLoadD
                      (    cmds_tape.asm):00103                 
E403 8D05             (    cmds_tape.asm):00104                         bsr             GetCFTypeA                              ; get cas filetype in A
                      (    cmds_tape.asm):00105         
E405 1F89             (    cmds_tape.asm):00106                         tfr             a,b                                             ; move to b     
E407 7EB4F3           (    cmds_tape.asm):00107                         jmp             VarAssign8Bit                   ; return it to basic
                      (    cmds_tape.asm):00108         
                      (    cmds_tape.asm):00109         
E40A                  (    cmds_tape.asm):00110         GetCFTypeA
E40A 8650             (    cmds_tape.asm):00111                         lda             #CMD_CAS_FTYPE                  ; Get file type
E40C 17FBFF           (    cmds_tape.asm):00112                         lbsr    MMC_SendCmd                             
E40F 17FEC3           (    cmds_tape.asm):00113                         lbsr    CheckError                              ; Bomb out on error
                      (    cmds_tape.asm):00114                         
E412 8620             (    cmds_tape.asm):00115                         lda             #CMD_INIT_READ                  ; init read
E414 17FC00           (    cmds_tape.asm):00116                         lbsr    MMC_SendCmdRaw
E417 1708B0           (    cmds_tape.asm):00117                         lbsr    MMC_WaitGetWritten              ; Wait for byte, and get it in a
E41A 39               (    cmds_tape.asm):00118                         rts
                      (    cmds_tape.asm):00119         
                      (    cmds_tape.asm):00120         ;CFTypeE
                      (    cmds_tape.asm):00121         ;        bsr     GetCFExecD                  ; Get exec address
                      (    cmds_tape.asm):00122         ;        jmp     VarAssign16Bit2             ; assign it and return
                      (    cmds_tape.asm):00123         ;        
                      (    cmds_tape.asm):00124         ;        
                      (    cmds_tape.asm):00125         ;CFTypeL      
                      (    cmds_tape.asm):00126         ;        bsr     GetCFLoadD                  ; get load address
                      (    cmds_tape.asm):00127                 
                      (    cmds_tape.asm):00128         ;
                      (    cmds_tape.asm):00129         ; Get exec address for next cassette file in D
                      (    cmds_tape.asm):00130         ;
E41B                  (    cmds_tape.asm):00131         GetCFExecD      
E41B C60E             (    cmds_tape.asm):00132                 ldb     #14                     ; Exec address offset
E41D 2002             (    cmds_tape.asm):00133                 bra     GetFC16
                      (    cmds_tape.asm):00134         ;
                      (    cmds_tape.asm):00135         ; Get load address for next cassette file in D
                      (    cmds_tape.asm):00136         ;
                      (    cmds_tape.asm):00137         
E41F                  (    cmds_tape.asm):00138         GetCFLoadD      
E41F C610             (    cmds_tape.asm):00139                 ldb     #16                     ; Load address is 15 bytes in
                      (    cmds_tape.asm):00140         
E421                  (    cmds_tape.asm):00141         GetFC16
E421 9D9F             (    cmds_tape.asm):00142                 jsr     <BasChrGet                              ; skip first char, B un affected        
E423 8DE5             (    cmds_tape.asm):00143                 bsr     GetCFTypeA              ; Get filetype, header block in AVR buffer
                      (    cmds_tape.asm):00144         
E425                  (    cmds_tape.asm):00145         GetCFLoadDLoop        
E425 1708A2           (    cmds_tape.asm):00146                 lbsr    MMC_WaitGetWritten      ; get a byte
E428 5A               (    cmds_tape.asm):00147                 decb                            ; decrement count
E429 26FA             (    cmds_tape.asm):00148                 bne     GetCFLoadDLoop          ; Keep going until at right place
                      (    cmds_tape.asm):00149                 
E42B 1F89             (    cmds_tape.asm):00150                 tfr     a,b                     ; get msb
E42D 17089A           (    cmds_tape.asm):00151                 lbsr    MMC_WaitGetWritten      ; get second byte of Load address
                      (    cmds_tape.asm):00152                 
E430 1E89             (    cmds_tape.asm):00153                 exg     a,b        
                      (    cmds_tape.asm):00154         
                      (    cmds_tape.asm):00155         ;
                      (    cmds_tape.asm):00156         ; Assign an unsigned 16 bit value from the D register
                      (    cmds_tape.asm):00157         ; call as you would VarAssign16Bit or VarAssign16Bit2
                      (    cmds_tape.asm):00158         ;
                      (    cmds_tape.asm):00159         
E432                  (    cmds_tape.asm):00160         DO_Assign16
E432 0F06             (    cmds_tape.asm):00161                         CLR     <BasVarType
E434 DD52             (    cmds_tape.asm):00162                 STD     <BasVarAssign16
E436 7E880E           (    cmds_tape.asm):00163                 JMP     >VarAssign16BitB
                      (    cmds_tape.asm):00164         ;
                      (    cmds_tape.asm):00165         ; Enable tape emulatiom, open, and load a tape using cload/cloadm as needed.
                      (    cmds_tape.asm):00166         ;
                      (    cmds_tape.asm):00167         
E439                  (    cmds_tape.asm):00168         CmdTapeRun
E439 17011C           (    cmds_tape.asm):00169                         lbsr    CmdMCasNormal                   ; boot into RAM mode
E43C 17FFA1           (    cmds_tape.asm):00170                         lbsr    CmdMRMountEntry                 ; Open the file
                      (    cmds_tape.asm):00171         
E43F BDF03E           (    cmds_tape.asm):00172                         jsr             >DO_ResetPoweron                ; reset memory map.
                      (    cmds_tape.asm):00173         
E442 8E0420           (    cmds_tape.asm):00174                 ldx     #(TextScreenBase+TextLineLen) ; point to screen, beginning of line 2
E445 9F88             (    cmds_tape.asm):00175                 stx     <TextVDUCursAddr        ; Set cursor address 
                      (    cmds_tape.asm):00176                         
E447 8DC1             (    cmds_tape.asm):00177                 bsr             GetCFTypeA                              ; get cas filetype in A
                      (    cmds_tape.asm):00178         
E449 8100             (    cmds_tape.asm):00179                         cmpa    #FTBasic                                ; Basic program ?
E44B 2707             (    cmds_tape.asm):00180                         beq             CmdTapeRunLBas                  ; yes load it
                      (    cmds_tape.asm):00181                         
E44D 8102             (    cmds_tape.asm):00182                         cmpa    #FTCode                                 ; Machine code ?
E44F 271B             (    cmds_tape.asm):00183                         beq             CmdTapeRunCode                  ; yes load it
                      (    cmds_tape.asm):00184                         
E451 7EB44A           (    cmds_tape.asm):00185                         jmp             BasFCError                              ; nope : error 
                      (    cmds_tape.asm):00186                         
E454                  (    cmds_tape.asm):00187         CmdTapeRunLBas          
E454 0F78             (    cmds_tape.asm):00188                         CLR     <CasStatus
E456 3262             (    cmds_tape.asm):00189                         leas    2,s
                      (    cmds_tape.asm):00190                         
E458 7EA4A3           (    cmds_tape.asm):00191                         jmp             CloadEntry                              ; cload the file, this never returns!
                      (    cmds_tape.asm):00192         
                      (    cmds_tape.asm):00193         ; Emulated CLOAD command patched to come back to here if loading ASCII Basic!
                      (    cmds_tape.asm):00194         
E45B                  (    cmds_tape.asm):00195         CLoadRunASCII
E45B 327E             (    cmds_tape.asm):00196                         leas    -2,s                                    ; drop return address
E45D BDA42D           (    cmds_tape.asm):00197                         jsr             CloseFilesEntry                 ; Close all files
E460 2006             (    cmds_tape.asm):00198                         bra             CLoadRunRun                             ; Go run it
                      (    cmds_tape.asm):00199                         
                      (    cmds_tape.asm):00200         ; Emulated CLOAD command patched to come back to here !
E462                  (    cmds_tape.asm):00201         CLoadRun
E462 BDAD21           (    cmds_tape.asm):00202                         jsr             >BasVect1                               ; Reset basic memory
E465 BDACEF           (    cmds_tape.asm):00203                         jsr             >BasVect2                               ; Reset basic memory
                      (    cmds_tape.asm):00204                 
E468                  (    cmds_tape.asm):00205         CLoadRunRun
E468 4F               (    cmds_tape.asm):00206                         clra
E469 7EAD9E           (    cmds_tape.asm):00207                         jmp             BasRun
                      (    cmds_tape.asm):00208                         
E46C                  (    cmds_tape.asm):00209         CmdTapeRunCode
E46C 8DB1             (    cmds_tape.asm):00210                 bsr     GetCFLoadD              ; get load address in d
E46E 3406             (    cmds_tape.asm):00211                 pshs    d                       ; save it
                      (    cmds_tape.asm):00212                         
E470 0F78             (    cmds_tape.asm):00213                         CLR     <CasStatus
E472 BDA502           (    cmds_tape.asm):00214                         jsr             CloadMEntry                             ; cloadm the file
                      (    cmds_tape.asm):00215                 
E475 3506             (    cmds_tape.asm):00216                 puls    d                       ; recover load address
                      (    cmds_tape.asm):00217         
                      (    cmds_tape.asm):00218         ;
                      (    cmds_tape.asm):00219         ; Check to see if the IRQ vector has been changed to point to the loaded area?
                      (    cmds_tape.asm):00220         ; Some software does this to auto-run, notably "Facemaker" by DragonData.
                      (    cmds_tape.asm):00221         ;
                      (    cmds_tape.asm):00222                 
E477 10B3010D         (    cmds_tape.asm):00223                 cmpd    SecVecIRQ+1             ; load > SecIRQ ?           
E47B 2207             (    cmds_tape.asm):00224                 bhi     CmdTapeRunCodeCheckExec ; lower, check exec address                  
                      (    cmds_tape.asm):00225                 
E47D BE010D           (    cmds_tape.asm):00226                 ldx     SecVecIRQ+1             ; get IRQ vector
                      (    cmds_tape.asm):00227                 
E480 9C7E             (    cmds_tape.asm):00228                 cmpx    <CasIOBuffAddr          ; Vector below end load address ?
E482 250F             (    cmds_tape.asm):00229                 blo     RunViaIRQ               ; yep it's in loaded area, just exit.
                      (    cmds_tape.asm):00230          
                      (    cmds_tape.asm):00231                 
                      (    cmds_tape.asm):00232         ;
                      (    cmds_tape.asm):00233         ; Check to see if EXEC address is within the loaded area, if so call it to run the code.
                      (    cmds_tape.asm):00234         ;
                      (    cmds_tape.asm):00235                 
E484                  (    cmds_tape.asm):00236         CmdTapeRunCodeCheckExec
E484 10939D           (    cmds_tape.asm):00237                 cmpd    <BasExecAddr            ; Load address below Exec address?
E487 2208             (    cmds_tape.asm):00238                 bhi     CmdTapeRunCodeExit      ; Exec < Load, invalid exit
                      (    cmds_tape.asm):00239                 
E489 9E9D             (    cmds_tape.asm):00240                 ldx     <BasExecAddr            ; get exec address
E48B 9C7E             (    cmds_tape.asm):00241                 cmpx    <CasIOBuffAddr          ; Exec address below end load address ?
E48D 2402             (    cmds_tape.asm):00242                 bhs     CmdTapeRunCodeExit      ; Exec > Last loaded, invalid exit
                      (    cmds_tape.asm):00243                   
E48F 6E84             (    cmds_tape.asm):00244                 jmp     ,x                      ; call it
                      (    cmds_tape.asm):00245         
                      (    cmds_tape.asm):00246         ;
                      (    cmds_tape.asm):00247         ; Some auto-runners catch the line scanner, call it to try and catch them.
                      (    cmds_tape.asm):00248         ; Notably "FlagonBird".
                      (    cmds_tape.asm):00249         ;
E491                  (    cmds_tape.asm):00250         CmdTapeRunCodeExit        
E491 9DA8             (    cmds_tape.asm):00251                 jsr     <ScannerExit            ; Jump to last line of scanner, catch some auto-runs
                      (    cmds_tape.asm):00252         
E493                  (    cmds_tape.asm):00253         RunViaIRQ
E493 7EAD9E           (    cmds_tape.asm):00254                         jmp             BasicLoop                               ; jump to interpreter.
                      (    cmds_tape.asm):00255         ;               rts
                      (    cmds_tape.asm):00256         
                      (    cmds_tape.asm):00257         ;
                      (    cmds_tape.asm):00258         ; Rewind the emulated tape
                      (    cmds_tape.asm):00259         ;
E496                  (    cmds_tape.asm):00260         CmdRewind
E496 8624             (    cmds_tape.asm):00261                         lda             #CMD_REWIND                             ; Rewind tape file back to 0
                      (    cmds_tape.asm):00262         
E498 17FB73           (    cmds_tape.asm):00263                         lbsr    MMC_SendCmd                             ; Send Command
E49B 17FE37           (    cmds_tape.asm):00264                         lbsr    CheckError                              ; Bomb out on error
                      (    cmds_tape.asm):00265         
E49E 4F               (    cmds_tape.asm):00266                         clra
E49F 39               (    cmds_tape.asm):00267                         rts
                      (    cmds_tape.asm):00268         
                      (    cmds_tape.asm):00269         ;
                      (    cmds_tape.asm):00270         ; Mirror incoming tape to MMC.
                      (    cmds_tape.asm):00271         ;               
                      (    cmds_tape.asm):00272         
                      (    cmds_tape.asm):00273         
E4A0                  (    cmds_tape.asm):00274         CmdMMirror
E4A0 8141             (    cmds_tape.asm):00275                 cmpa    #'A'                    ; Auto flag?
E4A2 2705             (    cmds_tape.asm):00276                 beq     CmdMMirrorA             ; yep deal with it
                      (    cmds_tape.asm):00277                 
E4A4 4F               (    cmds_tape.asm):00278                 clra    
E4A5 3402             (    cmds_tape.asm):00279                 pshs    a                       ; save auto flag
E4A7 2004             (    cmds_tape.asm):00280                         bra     CmdMMirrorCommon        ; Flag not auto
E4A9                  (    cmds_tape.asm):00281         CmdMMirrorA
E4A9 3402             (    cmds_tape.asm):00282                 pshs    a                       ; save auto flag
E4AB 9D9F             (    cmds_tape.asm):00283                         jsr             <BasChrGet                              ; skip first char       
E4AD                  (    cmds_tape.asm):00284         CmdMMirrorCommon
E4AD BDE50B           (    cmds_tape.asm):00285                 jsr             >CmdRamBoot                             ; Copy ROM into RAM.
                      (    cmds_tape.asm):00286         
E4B0 8611             (    cmds_tape.asm):00287                         lda             #D_RAM_ENABLE+D_RAM_WP  ; put us in ram mode, write protected.
E4B2 8EE4FC           (    cmds_tape.asm):00288                         ldx             #MirrorPatches                  ; Point to our patches.
E4B5 BDE55D           (    cmds_tape.asm):00289                         jsr             >CmdMcasGo2                             ; go copy rom and patch it.
                      (    cmds_tape.asm):00290         
E4B8 8600             (    cmds_tape.asm):00291                         lda             #CAS_FILE                               ; open default file
E4BA 17FB5E           (    cmds_tape.asm):00292                         lbsr    MMC_WaitPutLatchRead    ; send file id to latch register
                      (    cmds_tape.asm):00293         
E4BD 861C             (    cmds_tape.asm):00294                         lda             #CMD_FILE_OPEN_STREAMW  ; Open file for streaming to
E4BF BDE2B3           (    cmds_tape.asm):00295                         jsr             >CmdSendFilenameCmd             ; Send it and init streaming
E4C2 3502             (    cmds_tape.asm):00296                 puls    a                       ; recover auto flag
E4C4 8141             (    cmds_tape.asm):00297                 cmpa    #'A'                    ; Auto?
E4C6 2702             (    cmds_tape.asm):00298                 beq     CmdMMirrorAuto          ; yep : do it.
                      (    cmds_tape.asm):00299                 
E4C8 4F               (    cmds_tape.asm):00300                         clra
E4C9 39               (    cmds_tape.asm):00301                         rts
                      (    cmds_tape.asm):00302         
                      (    cmds_tape.asm):00303         ;
                      (    cmds_tape.asm):00304         ; Turn on motor and audio.
                      (    cmds_tape.asm):00305         ; Go into an endless loop that does block read to a constant buffer.
                      (    cmds_tape.asm):00306         ; this will of course then be mirrored to the cas file.
                      (    cmds_tape.asm):00307         ;        
E4CA                  (    cmds_tape.asm):00308         CmdMMirrorAuto
E4CA BDA7CA           (    cmds_tape.asm):00309                 jsr     >CasMotorOn             ; Turn on motor
E4CD 5F               (    cmds_tape.asm):00310                         clrb                                                    ; B must be zero !
E4CE BDA99D           (    cmds_tape.asm):00311                 jsr     >CasAudioOn             ; turn on audio
                      (    cmds_tape.asm):00312         
E4D1                  (    cmds_tape.asm):00313         CmdMMirrorAutoLoop        
E4D1 8E0600           (    cmds_tape.asm):00314                 ldx     #$600                   ; use graphics screen
E4D4 9F7E             (    cmds_tape.asm):00315                 stx     CasIOBuffAddr
                      (    cmds_tape.asm):00316         
E4D6 BDA70B           (    cmds_tape.asm):00317                 jsr     >CasBlockIn             ; Read block, ignore any error
E4D9 20F6             (    cmds_tape.asm):00318                 bra     CmdMMirrorAutoLoop      ; loop again!
                      (    cmds_tape.asm):00319                 
                      (    cmds_tape.asm):00320         ;
                      (    cmds_tape.asm):00321         ; This replaces the byte in routine in the Dragon / CoCo roms, it's exactly the same code
                      (    cmds_tape.asm):00322         ; with the addition of a save at the end to send the read byte to the MMC
                      (    cmds_tape.asm):00323         ;               
E4DB                  (    cmds_tape.asm):00324         NewByteIn
E4DB 8608             (    cmds_tape.asm):00325                         LDA     #$08                                    ; Read 8 bits
E4DD 9783             (    cmds_tape.asm):00326                 STA     <CasBitCount
E4DF                  (    cmds_tape.asm):00327         NewByteInLoop                                                   
E4DF BDA755           (    cmds_tape.asm):00328                         JSR     >CasBitIn                               ; read a bit
E4E2 46               (    cmds_tape.asm):00329                 RORA                                                    ; rotate it into A
E4E3 0A83             (    cmds_tape.asm):00330                 DEC     <CasBitCount                    ; decrement count
E4E5 26F8             (    cmds_tape.asm):00331                 BNE     NewByteInLoop                   ; keep going if not all done.
E4E7 B7FF52           (    cmds_tape.asm):00332                         sta             D_WRITE_DATA_REG                ; send it to the AVR, don't wait
E4EA 39               (    cmds_tape.asm):00333                 RTS
                      (    cmds_tape.asm):00334         
                      (    cmds_tape.asm):00335         ;
                      (    cmds_tape.asm):00336         ; Make sure beggining of block mark is copied to the output
                      (    cmds_tape.asm):00337         ;
E4EB                  (    cmds_tape.asm):00338         NewFoundBlkMark
E4EB 3402             (    cmds_tape.asm):00339                         pshs    a
E4ED 8655             (    cmds_tape.asm):00340                 lda     #'U
E4EF B7FF52           (    cmds_tape.asm):00341                 sta             D_WRITE_DATA_REG            ; send it to the AVR, don't wait
E4F2 3502             (    cmds_tape.asm):00342                         puls    a
E4F4 B7FF52           (    cmds_tape.asm):00343                 sta             D_WRITE_DATA_REG            ; send it to the AVR, don't wait
                      (    cmds_tape.asm):00344                         
                      (    cmds_tape.asm):00345                         ifdef   Dragon          
                      (    cmds_tape.asm):00346                         bra             NewByteIn                               ; get next byte
                      (    cmds_tape.asm):00347                         else
E4F7 8DE2             (    cmds_tape.asm):00348                         bsr             NewByteIn                               ; get next byte
E4F9 977C             (    cmds_tape.asm):00349                         sta             <CCasBlockType                  ; save it
E4FB 39               (    cmds_tape.asm):00350                         rts
                      (    cmds_tape.asm):00351                         endc
                      (    cmds_tape.asm):00352                         
                      (    cmds_tape.asm):00353                                 ifdef   Dragon
E4FC                  (    cmds_tape.asm):00354         CMP2Addr        EQU             $B94D
                      (    cmds_tape.asm):00355                                 else
     A719             (    cmds_tape.asm):00356         CMP2Addr        EQU             $A719
                      (    cmds_tape.asm):00357                                 endc
                      (    cmds_tape.asm):00358                         
                      (    cmds_tape.asm):00359                         
E4FC                  (    cmds_tape.asm):00360         MirrorPatches
                      (    cmds_tape.asm):00361         
E4FC A749             (    cmds_tape.asm):00362                         FDB             CasByteIn                               ; Byte in routine
E4FE 03               (    cmds_tape.asm):00363                         FCB             CasMP1E-CasMP1                  ; length
E4FF                  (    cmds_tape.asm):00364         CasMP1
E4FF 7EE4DB           (    cmds_tape.asm):00365                         JMP             >NewByteIn                              ; Jump to our copy of byte in
E502                  (    cmds_tape.asm):00366         CasMP1E
                      (    cmds_tape.asm):00367         
                      (    cmds_tape.asm):00368                         ifdef   Dragon
                      (    cmds_tape.asm):00369                         FDB             CMP2Addr
                      (    cmds_tape.asm):00370                         FCB             CasMP2E-CasMP2                  ; length
E502                  (    cmds_tape.asm):00371         CasMP2
                      (    cmds_tape.asm):00372                         JSR             >NewFoundBlkMark                ; Jump to our copy of byte in
E502                  (    cmds_tape.asm):00373         CasMP2E
                      (    cmds_tape.asm):00374                         
                      (    cmds_tape.asm):00375                         else
E502 A719             (    cmds_tape.asm):00376                         FDB             CMP2Addr
E504 04               (    cmds_tape.asm):00377                         FCB             CasMP2E-CasMP2                  ; length
E505                  (    cmds_tape.asm):00378         CasMP2
E505 BDE4EB           (    cmds_tape.asm):00379                         JSR             >NewFoundBlkMark                ; Jump to our copy of byte in
E508 12               (    cmds_tape.asm):00380                         NOP
E509                  (    cmds_tape.asm):00381         CasMP2E
                      (    cmds_tape.asm):00382                         
                      (    cmds_tape.asm):00383                         endc
                      (    cmds_tape.asm):00384         
                      (    cmds_tape.asm):00385         ;*****************************************************************
                      (    cmds_tape.asm):00386         ;******************[ End of Patches ]*****************************
                      (    cmds_tape.asm):00387         ;*****************************************************************
E509 0000             (    cmds_tape.asm):00388                         FDB     $0000                   ; end of patches
                      (    cmds_tape.asm):00389                         
E50B                  (    cmds_tape.asm):00390         __cmd_tape_end
                      (    cmds_tape.asm):00391         
                      (    DragonMMC.asm):00663                         use             cmds_ram.asm
                      (     cmds_ram.asm):00001         ;
                      (     cmds_ram.asm):00002         ; CmdsRam       : Ram copy related commands.
                      (     cmds_ram.asm):00003         ;
                      (     cmds_ram.asm):00004         
                      (     cmds_ram.asm):00005         ;
                      (     cmds_ram.asm):00006         ; Note some routines make calls / returns into the Dragon and CoCo roms.
                      (     cmds_ram.asm):00007         ; Please remember to define them so they assemble correctly on *BOTH* 
                      (     cmds_ram.asm):00008         ; machines.
                      (     cmds_ram.asm):00009         ; 
                      (     cmds_ram.asm):00010         
E50B                  (     cmds_ram.asm):00011         __cmd_ram
                      (     cmds_ram.asm):00012         
                      (     cmds_ram.asm):00013         ;
                      (     cmds_ram.asm):00014         ; Copy Dragon ROM from $8000-$FEFF to ram.
                      (     cmds_ram.asm):00015         ;
E50B                  (     cmds_ram.asm):00016         CmdRamBoot
E50B 3410             (     cmds_ram.asm):00017                         pshs    x                                               ; save x
                      (     cmds_ram.asm):00018         
                      (     cmds_ram.asm):00019                         ifndef  EMULATE
                      (     cmds_ram.asm):00020         ;; Code if on real hardware.
                      (     cmds_ram.asm):00021                 bsr     GoROMMode               ; make sure we are in ROM mode, RAM write enabled
                      (     cmds_ram.asm):00022                         ldx             #$8000                                  ; point at base of system ROM
E50D                  (     cmds_ram.asm):00023         RamBootLoop
                      (     cmds_ram.asm):00024                         ldd             ,X                                              ; get a word
                      (     cmds_ram.asm):00025                         std             ,x++                                    ; put it in ram, writes always go to ram
                      (     cmds_ram.asm):00026                         cmpx    #$FF00                                  ; done all
                      (     cmds_ram.asm):00027                         blo             RamBootLoop                             ; nope, do next
                      (     cmds_ram.asm):00028                         
                      (     cmds_ram.asm):00029                 bsr     GoRAMMode               ; Switch to RAM mode
                      (     cmds_ram.asm):00030                         
                      (     cmds_ram.asm):00031                         else
                      (     cmds_ram.asm):00032         ;; Code if emulated.
E50D 8EE51F           (     cmds_ram.asm):00033                         ldx             #RamBoot                                ; Copy to tape buffer
E510 CE01D1           (     cmds_ram.asm):00034                         ldu             #DCasFNameLen                   
E513                  (     cmds_ram.asm):00035         RamBootCopyLoop
E513 A680             (     cmds_ram.asm):00036                         lda             ,x+                                             ; get byte
E515 A7C0             (     cmds_ram.asm):00037                         sta             ,u+                                             ; save it
E517 8CE537           (     cmds_ram.asm):00038                         cmpx    #GoROMMode                              ; done all?
E51A 26F7             (     cmds_ram.asm):00039                         bne             RamBootCopyLoop
E51C 7E01D1           (     cmds_ram.asm):00040                         jmp             >DCasFNameLen                   ; call copied code
                      (     cmds_ram.asm):00041                         
E51F                  (     cmds_ram.asm):00042         RamBoot         
E51F 8E8000           (     cmds_ram.asm):00043                         ldx             #$8000                                  ; point at base of system ROM
E522                  (     cmds_ram.asm):00044         RamBootLoop
E522 7FFFDE           (     cmds_ram.asm):00045                         clr             SAMCTY                                  ; ROM mode
E525 EC84             (     cmds_ram.asm):00046                         ldd             ,X                                              ; get a word
E527 7FFFDF           (     cmds_ram.asm):00047                         clr             SAMSTY                                  ; RAM mode
E52A ED81             (     cmds_ram.asm):00048                         std             ,x++                                    ; put it in ram, writes always go to ram
E52C 8CFF00           (     cmds_ram.asm):00049                         cmpx    #$FF00                                  ; done all
E52F 25F1             (     cmds_ram.asm):00050                         blo             RamBootLoop                             ; nope, do next
E531 7EE534           (     cmds_ram.asm):00051                         jmp             >RamBootDone
                      (     cmds_ram.asm):00052         
E534                  (     cmds_ram.asm):00053         RamBootDone             
                      (     cmds_ram.asm):00054                         endc
                      (     cmds_ram.asm):00055                         
E534 4F               (     cmds_ram.asm):00056                         clra                                                    ; no error
E535 3590             (     cmds_ram.asm):00057                         puls    x,pc                                    ; restore and return
                      (     cmds_ram.asm):00058         
E537                  (     cmds_ram.asm):00059         GoROMMode
E537 3402             (     cmds_ram.asm):00060                 pshs    a                       ; save a
E539 BDE020           (     cmds_ram.asm):00061                         jsr             MMC_GetRAMCTRL                  ; Go get current value
E53C 84EE             (     cmds_ram.asm):00062                         anda    #~(D_RAM_ENABLE+D_RAM_WP)  
E53E BDE028           (     cmds_ram.asm):00063                         jsr             MMC_SetRAMCTRL                  ; and update
                      (     cmds_ram.asm):00064                         
E541 3582             (     cmds_ram.asm):00065                 puls    a,pc                    ; restore and return
                      (     cmds_ram.asm):00066                 
                      (     cmds_ram.asm):00067         
E543                  (     cmds_ram.asm):00068         GoRAMMode
E543 3402             (     cmds_ram.asm):00069                 pshs    a                       ; save a
E545 BDE020           (     cmds_ram.asm):00070                         jsr             MMC_GetRAMCTRL                  ; Go get current value
E548 8A01             (     cmds_ram.asm):00071                         ora         #D_RAM_ENABLE          
E54A BDE028           (     cmds_ram.asm):00072                         jsr             MMC_SetRAMCTRL                  ; and update
E54D 3582             (     cmds_ram.asm):00073                 puls    a,pc                    ; restore and return
                      (     cmds_ram.asm):00074         
                      (     cmds_ram.asm):00075         ;
                      (     cmds_ram.asm):00076         ; Copy Dragon rom to ram and patch for cassette emulation on mmc
                      (     cmds_ram.asm):00077         ;
                      (     cmds_ram.asm):00078         
E54F                  (     cmds_ram.asm):00079         CmdMCas
E54F 4D               (     cmds_ram.asm):00080                         tsta
E550 2706             (     cmds_ram.asm):00081                         beq             CmdMCasNormal
E552 9D9F             (     cmds_ram.asm):00082                         JSR     <BasChrGet                              ; skip the charcter
                      (     cmds_ram.asm):00083                         
E554 8601             (     cmds_ram.asm):00084                         lda             #D_RAM_ENABLE                   ; Leave it write enabled
E556 2002             (     cmds_ram.asm):00085                         bra             CmdMcasGo
                      (     cmds_ram.asm):00086                         
E558                  (     cmds_ram.asm):00087         CmdMCasNormal
E558 8611             (     cmds_ram.asm):00088                         lda             #D_RAM_ENABLE+D_RAM_WP  ; put us in ram mode, write protected.
E55A                  (     cmds_ram.asm):00089         CmdMcasGo       
E55A 8EE57A           (     cmds_ram.asm):00090                         ldx             #CasPatch                               ; point to patches
E55D                  (     cmds_ram.asm):00091         CmdMcasGo2
E55D 3402             (     cmds_ram.asm):00092                         pshs    a
                      (     cmds_ram.asm):00093                 
E55F 8DAA             (     cmds_ram.asm):00094                         bsr             CmdRamBoot                              ; Switch to all ram mode
E561                  (     cmds_ram.asm):00095         CmdMCasNext
E561 10AE81           (     cmds_ram.asm):00096                         ldy             ,x++                                    ; Get address to patch
E564 270B             (     cmds_ram.asm):00097                         beq             CmdMCasPatchDone                ; address=0, end
                      (     cmds_ram.asm):00098                 
E566 E680             (     cmds_ram.asm):00099                         ldb             ,x+                                             ; Byte count
E568                  (     cmds_ram.asm):00100         CmdMCasPLoop
E568 A680             (     cmds_ram.asm):00101                         lda             ,x+                                             ; Get a byte
E56A A7A0             (     cmds_ram.asm):00102                         sta             ,y+                                             ; Put in ram
E56C 5A               (     cmds_ram.asm):00103                         decb                                                    ; Decrement count
E56D 26F9             (     cmds_ram.asm):00104                         bne             CmdMCasPLoop
E56F 20F0             (     cmds_ram.asm):00105                         bra             CmdMCasNext                             ; Do next patch
                      (     cmds_ram.asm):00106                 
E571                  (     cmds_ram.asm):00107         CmdMCasPatchDone
E571 BDE020           (     cmds_ram.asm):00108                         jsr             MMC_GetRAMCTRL                  ; Go get current value
E574 AAE0             (     cmds_ram.asm):00109                 ora         ,s+                                         ; mask in flags
E576 BDE028           (     cmds_ram.asm):00110                         jsr             MMC_SetRAMCTRL                  ; and update
                      (     cmds_ram.asm):00111         
                      (     cmds_ram.asm):00112         ;               lda             D_RAM_CTRL              ; Get ram control register
                      (     cmds_ram.asm):00113         ;        ora        ,s+                                         ; mask in flags
                      (     cmds_ram.asm):00114         ;               sta             D_RAM_CTRL              ; Put back.
                      (     cmds_ram.asm):00115                         
E579 39               (     cmds_ram.asm):00116                         rts
                      (     cmds_ram.asm):00117         
                      (     cmds_ram.asm):00118                                 ifdef Dragon
E57A                  (     cmds_ram.asm):00119         CP1Addr         EQU             $BDED
E57A                  (     cmds_ram.asm):00120         CP3Addr         EQU             $B945
E57A                  (     cmds_ram.asm):00121         CP4Addr         EQU             $B961
E57A                  (     cmds_ram.asm):00122         CP6Addr         EQU             $b9c1
E57A                  (     cmds_ram.asm):00123         CloadExit       EQU             $B733
                      (     cmds_ram.asm):00124                                 else
     A782             (     cmds_ram.asm):00125         CP1Addr         EQU             $A782
     A712             (     cmds_ram.asm):00126         CP3Addr         EQU             $A712
     A72B             (     cmds_ram.asm):00127         CP4Addr         EQU             $A72B
     A81C             (     cmds_ram.asm):00128         CP6Addr         EQU             $A81C
     A4F5             (     cmds_ram.asm):00129         CloadExit       EQU             $A4F5   
                      (     cmds_ram.asm):00130                                 endc
                      (     cmds_ram.asm):00131         
                      (     cmds_ram.asm):00132         ;******************************
                      (     cmds_ram.asm):00133         ; Patches to rom for CmdMcas. *
                      (     cmds_ram.asm):00134         ;******************************
                      (     cmds_ram.asm):00135         
E57A                  (     cmds_ram.asm):00136         CasPatch
                      (     cmds_ram.asm):00137                         ifndef  EMULATE
                      (     cmds_ram.asm):00138                         
                      (     cmds_ram.asm):00139                         FDB     CP1Addr                         ; Address
                      (     cmds_ram.asm):00140                         FCB     CasP1E-CasP1            ; length
                      (     cmds_ram.asm):00141         
                      (     cmds_ram.asm):00142         ; Patch wait for leader to just return
E57A                  (     cmds_ram.asm):00143         CasP1
                      (     cmds_ram.asm):00144                         rts                                             ; Bytes to patch
E57A                  (     cmds_ram.asm):00145         CasP1E
                      (     cmds_ram.asm):00146         
                      (     cmds_ram.asm):00147         
                      (     cmds_ram.asm):00148                         FDB     CasByteIn                       ; Address
                      (     cmds_ram.asm):00149                         FCB     CasP2E-CasP2            ; length
                      (     cmds_ram.asm):00150         
                      (     cmds_ram.asm):00151         ; Patch byte in to read a byte from the MMC
E57A                  (     cmds_ram.asm):00152         CasP2
                      (     cmds_ram.asm):00153                         JMP     >MMC_ReadFByte  
E57A                  (     cmds_ram.asm):00154         CasP2E  
                      (     cmds_ram.asm):00155         
                      (     cmds_ram.asm):00156         
                      (     cmds_ram.asm):00157                         FDB     CP3Addr                         ; Address
                      (     cmds_ram.asm):00158                         FCB     CasP3E-CasP3            ; length
                      (     cmds_ram.asm):00159         
                      (     cmds_ram.asm):00160         ; Patch byte in to read a byte from MMC
E57A                  (     cmds_ram.asm):00161         CasP3
                      (     cmds_ram.asm):00162                         JSR             >MMC_ReadFByte  
                      (     cmds_ram.asm):00163                         ifdef   Dragon  
                      (     cmds_ram.asm):00164                         NOP
                      (     cmds_ram.asm):00165                         endc
E57A                  (     cmds_ram.asm):00166         CasP3E
                      (     cmds_ram.asm):00167         
                      (     cmds_ram.asm):00168                         FDB     CP4Addr                         ; Address
                      (     cmds_ram.asm):00169                         FCB     CasP4E-CasP4            ; length
                      (     cmds_ram.asm):00170         
                      (     cmds_ram.asm):00171         ; Patch byte in to read a block from the MMC
E57A                  (     cmds_ram.asm):00172         CasP4
                      (     cmds_ram.asm):00173                         nop
                      (     cmds_ram.asm):00174                         nop
                      (     cmds_ram.asm):00175                         jmp             >MMC_ReadFBlock ;Read block
E57A                  (     cmds_ram.asm):00176         CasP4E
                      (     cmds_ram.asm):00177         
                      (     cmds_ram.asm):00178         
                      (     cmds_ram.asm):00179                         FDB     CasByteOut                      ; Address
                      (     cmds_ram.asm):00180                         FCB     CasP5E-CasP5            ; length
                      (     cmds_ram.asm):00181         
                      (     cmds_ram.asm):00182         ; Patch write a byte to the MMC
E57A                  (     cmds_ram.asm):00183         CasP5
                      (     cmds_ram.asm):00184                         JMP             >MMC_WriteFByte 
E57A                  (     cmds_ram.asm):00185         CasP5E
                      (     cmds_ram.asm):00186         
                      (     cmds_ram.asm):00187         
                      (     cmds_ram.asm):00188         ;
                      (     cmds_ram.asm):00189         ; Patch the write byte loop in the CasBlockOut to use a multi-byte write file.
                      (     cmds_ram.asm):00190         ;
                      (     cmds_ram.asm):00191         
                      (     cmds_ram.asm):00192                         fdb     CP6Addr
                      (     cmds_ram.asm):00193                         FCB     CasP6E-CasP6            ; length
                      (     cmds_ram.asm):00194         
                      (     cmds_ram.asm):00195         ; Patch write a byte to the MMC
E57A                  (     cmds_ram.asm):00196         CasP6
                      (     cmds_ram.asm):00197                         JMP             >MMC_WriteFBlock
                      (     cmds_ram.asm):00198                         nop
E57A                  (     cmds_ram.asm):00199         CasP6E
                      (     cmds_ram.asm):00200         
                      (     cmds_ram.asm):00201         ;
                      (     cmds_ram.asm):00202         ; Patch the gap checking routine to not toggle the cassette relay.
                      (     cmds_ram.asm):00203         ;
                      (     cmds_ram.asm):00204         
                      (     cmds_ram.asm):00205         ;               fdb     $b906
                      (     cmds_ram.asm):00206         ;               fcb     CasP7E-CasP7            ; length
                      (     cmds_ram.asm):00207         ;
                      (     cmds_ram.asm):00208         ;CasP7
                      (     cmds_ram.asm):00209         ;               fcb     $21                                     ; code for BRN
                      (     cmds_ram.asm):00210         ;CasP7E
                      (     cmds_ram.asm):00211         
                      (     cmds_ram.asm):00212         ;
                      (     cmds_ram.asm):00213         ; Patch motor on to just return, without turning on motor.
                      (     cmds_ram.asm):00214         ;
                      (     cmds_ram.asm):00215         
                      (     cmds_ram.asm):00216         ;               fdb     CasMotorOn
                      (     cmds_ram.asm):00217         ;               fcb     CasP8E-CasP8            ; length
                      (     cmds_ram.asm):00218         ;
                      (     cmds_ram.asm):00219         ;CasP8
                      (     cmds_ram.asm):00220         ;               rts
                      (     cmds_ram.asm):00221         ;CasP8E
                      (     cmds_ram.asm):00222         
                      (     cmds_ram.asm):00223                         endc
                      (     cmds_ram.asm):00224         ;
                      (     cmds_ram.asm):00225         ; Patch Cload, to run loaded basic program (tokenized)
                      (     cmds_ram.asm):00226         ;
E57A A4F5             (     cmds_ram.asm):00227                         fdb     CloadExit
E57C 03               (     cmds_ram.asm):00228                         fcb     CasP9E-CasP9            ; length
                      (     cmds_ram.asm):00229         
E57D                  (     cmds_ram.asm):00230         CasP9
E57D 7EE462           (     cmds_ram.asm):00231                         JMP     CLoadRun                        ; Go run it!
E580                  (     cmds_ram.asm):00232         CasP9E
                      (     cmds_ram.asm):00233         
                      (     cmds_ram.asm):00234         ;
                      (     cmds_ram.asm):00235         ; Patch Cload, to run loaded basic program (ASCII)
                      (     cmds_ram.asm):00236         ;
E580 0185             (     cmds_ram.asm):00237                         fdb     VectCloseFileCmd
E582 03               (     cmds_ram.asm):00238                         fcb     CasP10E-CasP10          ; length
                      (     cmds_ram.asm):00239         
E583                  (     cmds_ram.asm):00240         CasP10
E583 7EE45B           (     cmds_ram.asm):00241                         JMP     CLoadRunASCII           ; Go run it!
E586                  (     cmds_ram.asm):00242         CasP10E
                      (     cmds_ram.asm):00243                 
                      (     cmds_ram.asm):00244         ;*****************************************************************
                      (     cmds_ram.asm):00245         ;******************[ End of Patches ]*****************************
                      (     cmds_ram.asm):00246         ;*****************************************************************
E586 0000             (     cmds_ram.asm):00247                         FDB     $0000                   ; end of patches
                      (     cmds_ram.asm):00248         
E588                  (     cmds_ram.asm):00249         __cmd_ram_end
                      (    DragonMMC.asm):00664                         use             cmd_cat.asm
                      (      cmd_cat.asm):00001         ;
                      (      cmd_cat.asm):00002         ;
                      (      cmd_cat.asm):00003         ; CmdCat.asm
                      (      cmd_cat.asm):00004         ;
                      (      cmd_cat.asm):00005         ; Catalog the MMC.
                      (      cmd_cat.asm):00006         ;
                      (      cmd_cat.asm):00007         
E588                  (      cmd_cat.asm):00008         __cmd_cat
                      (      cmd_cat.asm):00009         
                      (      cmd_cat.asm):00010                 ifdef           Dragon
E588                  (      cmd_cat.asm):00011         VarReturnStr    EQU     $8DE1
                      (      cmd_cat.asm):00012                 else
     B69B             (      cmd_cat.asm):00013         VarReturnStr    EQU     $B69B
                      (      cmd_cat.asm):00014                 endc
                      (      cmd_cat.asm):00015         
     000F             (      cmd_cat.asm):00016         LinesPerPage    equ     15                                      ; line per page
                      (      cmd_cat.asm):00017         
E588                  (      cmd_cat.asm):00018         CmdCat
E588 327E             (      cmd_cat.asm):00019                 leas    -2,s                                            ; make room on stack
E58A A761             (      cmd_cat.asm):00020                 sta             1,s                                                     ; save paged flag
E58C 8150             (      cmd_cat.asm):00021                 cmpa    #'P                                                     ; Paged ?
E58E 2608             (      cmd_cat.asm):00022                 bne             CmdCatNonPaged                          ; nope skip
E590 9D9F             (      cmd_cat.asm):00023                 JSR     <BasChrGet                                      ; skip the P
                      (      cmd_cat.asm):00024         
E592 8610             (      cmd_cat.asm):00025                 lda             #LinesPerPage+1                         ; set lines to next prompt
E594 A7E4             (      cmd_cat.asm):00026                 sta             ,s
E596 2004             (      cmd_cat.asm):00027                 bra             CmdCatGo
                      (      cmd_cat.asm):00028                 
E598                  (      cmd_cat.asm):00029         CmdCatNonPaged
E598 6FE4             (      cmd_cat.asm):00030                 clr             ,s                                                      ; flag not paged
E59A 6F61             (      cmd_cat.asm):00031                 clr             1,s
                      (      cmd_cat.asm):00032         
E59C                  (      cmd_cat.asm):00033         CmdCatGo
E59C 8D3C             (      cmd_cat.asm):00034                 bsr             InitDirRead                                     ; Shared by cat and findfirst
                      (      cmd_cat.asm):00035                 
E59E                  (      cmd_cat.asm):00036         CmdCatLoop
E59E 8601             (      cmd_cat.asm):00037                 lda             #CMD_DIR_READ                           ; get next entry
E5A0 17FA6B           (      cmd_cat.asm):00038                 lbsr    MMC_SendCmd
E5A3 17FD2F           (      cmd_cat.asm):00039                 lbsr    CheckError                                      ; check for errors, returns to basic on error
                      (      cmd_cat.asm):00040                 
E5A6 8141             (      cmd_cat.asm):00041                 cmpa    #STATUS_COMPLETE+STATUS_LAST    ; Listed all entries ?
E5A8 2604             (      cmd_cat.asm):00042                 bne             CmdCatPrintNext                         ; nope : print next entry
E5AA                  (      cmd_cat.asm):00043         CmdCatEnd
E5AA 3262             (      cmd_cat.asm):00044                 leas    2,s                                                     ; drop stack bytes
E5AC 4F               (      cmd_cat.asm):00045                 clra    
E5AD 39               (      cmd_cat.asm):00046                 rts             
                      (      cmd_cat.asm):00047         
E5AE                  (      cmd_cat.asm):00048         CmdCatPrintNext
E5AE 6D61             (      cmd_cat.asm):00049                 tst             1,s                                                     ; Paged mode ?
E5B0 2712             (      cmd_cat.asm):00050                 beq             CmdCatPrintNext1                        ; nope, just print
                      (      cmd_cat.asm):00051                 
E5B2 6AE4             (      cmd_cat.asm):00052                 dec             ,s                                                      ; decrement counter
E5B4 260E             (      cmd_cat.asm):00053                 bne             CmdCatPrintNext1                        ; If not done LinesPerPage lines keep printing 
                      (      cmd_cat.asm):00054                 
E5B6 860F             (      cmd_cat.asm):00055                 lda             #LinesPerPage                           ; re-initialize counter
E5B8 A7E4             (      cmd_cat.asm):00056                 sta             ,s
                      (      cmd_cat.asm):00057                 
E5BA 1709C0           (      cmd_cat.asm):00058                 lbsr    CON_PromptMore                          ; Display prompt and wait for key
E5BD 8151             (      cmd_cat.asm):00059                 cmpa    #'Q                                                     ; Quit?
E5BF 27E9             (      cmd_cat.asm):00060                 beq             CmdCatEnd                                       ; Yep : exit
                      (      cmd_cat.asm):00061                 
E5C1 170974           (      cmd_cat.asm):00062                 lbsr    CON_EOL                                         ; next line
                      (      cmd_cat.asm):00063                 
E5C4                  (      cmd_cat.asm):00064         CmdCatPrintNext1
E5C4 8620             (      cmd_cat.asm):00065                 lda             #CMD_INIT_READ                          ; Start reading filename 
E5C6 17FA4E           (      cmd_cat.asm):00066                 lbsr    MMC_SendCmdRaw
                      (      cmd_cat.asm):00067                 
E5C9                  (      cmd_cat.asm):00068         CmdCatPrintLoop
E5C9 1706FE           (      cmd_cat.asm):00069                 lbsr    MMC_WaitGetWritten                      ; Wait for byte, and get it in a
E5CC 8100             (      cmd_cat.asm):00070                 cmpa    #0                                                      ; end of filename ?
E5CE 2705             (      cmd_cat.asm):00071                 beq             CmdCatEOL                                       ; yes : process next name
                      (      cmd_cat.asm):00072                 
E5D0 BDA30A           (      cmd_cat.asm):00073                 jsr             BasicScreenOut                          ; nope print it
E5D3 20F4             (      cmd_cat.asm):00074                 bra             CmdCatPrintLoop
                      (      cmd_cat.asm):00075         
E5D5                  (      cmd_cat.asm):00076         CmdCatEOL
E5D5 170960           (      cmd_cat.asm):00077                 lbsr    CON_EOL                                         ; send eol
E5D8 20C4             (      cmd_cat.asm):00078                 bra             CmdCatLoop                                      ; do next entry
                      (      cmd_cat.asm):00079         
                      (      cmd_cat.asm):00080         
E5DA                  (      cmd_cat.asm):00081         InitDirRead
E5DA 9DA5             (      cmd_cat.asm):00082                 JSR     <BasChrGetCurr                          ; get current character from command
E5DC 2705             (      cmd_cat.asm):00083                 beq             InitNullDir
                      (      cmd_cat.asm):00084         
E5DE 17FCC6           (      cmd_cat.asm):00085                 lbsr    GetSendFileName                         ; Get path / wildcard 
E5E1 200D             (      cmd_cat.asm):00086                 bra             InitDirReadOpen                         ; open the directory
                      (      cmd_cat.asm):00087                 
                      (      cmd_cat.asm):00088         ; No filename supplied, set a null filename, which also reset wildcard to *
E5E3                  (      cmd_cat.asm):00089         InitNullDir
E5E3 8621             (      cmd_cat.asm):00090                 lda     #CMD_INIT_WRITE                         ; init write, clear dir name
E5E5 17FA26           (      cmd_cat.asm):00091                 lbsr    MMC_SendCmd
E5E8 17FCEA           (      cmd_cat.asm):00092                 lbsr    CheckError                                      ; check for errors, returns to basic on error
                      (      cmd_cat.asm):00093                 
E5EB 8600             (      cmd_cat.asm):00094                 lda             #0
E5ED B7FF52           (      cmd_cat.asm):00095                 sta             D_WRITE_DATA_REG                        ; Send null dirname for now
                      (      cmd_cat.asm):00096                 
E5F0                  (      cmd_cat.asm):00097         InitDirReadOpen
E5F0 8600             (      cmd_cat.asm):00098                 lda             #CMD_DIR_OPEN                           ; open dir
E5F2 17FA19           (      cmd_cat.asm):00099                 lbsr    MMC_SendCmd
E5F5 17FCDD           (      cmd_cat.asm):00100                 lbsr    CheckError                                      ; check for errors, returns to basic on error
E5F8 39               (      cmd_cat.asm):00101                 rts
                      (      cmd_cat.asm):00102                 
                      (      cmd_cat.asm):00103         ;
                      (      cmd_cat.asm):00104         ; CmdCWD, change current working directory, change current snapshot directory.
                      (      cmd_cat.asm):00105         ;
                      (      cmd_cat.asm):00106         
E5F9                  (      cmd_cat.asm):00107         CmdCWD
E5F9 8153             (      cmd_cat.asm):00108                 cmpa    #'S                                                     ; CWDS ? (change snapshot dir?)
E5FB 2606             (      cmd_cat.asm):00109                 bne             CmdDoCWD                                        ; nope do CWD
E5FD 9D9F             (      cmd_cat.asm):00110                 JSR     <BasChrGet                                      ; skip the S
                      (      cmd_cat.asm):00111         
E5FF 8606             (      cmd_cat.asm):00112                 lda             #CMD_DIR_SET_SNAPPATH           ; change the snapshot path
E601 2002             (      cmd_cat.asm):00113             bra     CmdWD
E603                  (      cmd_cat.asm):00114         CmdDoCWD
E603 8602             (      cmd_cat.asm):00115                 lda             #CMD_DIR_CWD                            ; change working directory
                      (      cmd_cat.asm):00116         
E605                  (      cmd_cat.asm):00117         CmdWD
E605 17FCAB           (      cmd_cat.asm):00118                 lbsr    CmdSendFilenameCmd                      ; Send directory name and command
E608 4F               (      cmd_cat.asm):00119                 clra    
E609 39               (      cmd_cat.asm):00120                 rts
                      (      cmd_cat.asm):00121         
                      (      cmd_cat.asm):00122         ;
                      (      cmd_cat.asm):00123         ; CmdMkdir Make a directory.
                      (      cmd_cat.asm):00124         ;
E60A                  (      cmd_cat.asm):00125         CmdMKDir
E60A 8604             (      cmd_cat.asm):00126                 lda             #CMD_DIR_MAKE                           ; Make directory
E60C 17FCA4           (      cmd_cat.asm):00127                 lbsr    CmdSendFilenameCmd                      ; Send directory name and command
E60F 17FCC3           (      cmd_cat.asm):00128                 lbsr    CheckError                                      ; check for errors, returns to basic on error
                      (      cmd_cat.asm):00129                 
E612 4F               (      cmd_cat.asm):00130                 clra
E613 39               (      cmd_cat.asm):00131                 rts
                      (      cmd_cat.asm):00132         
                      (      cmd_cat.asm):00133         ;
                      (      cmd_cat.asm):00134         ; FuncGetSnapDir, like CWD bugt get snapshot directory.
                      (      cmd_cat.asm):00135         ;
E614                  (      cmd_cat.asm):00136         FuncGetSnapDir
E614 8607             (      cmd_cat.asm):00137                 lda             #CMD_DIR_GET_SNAPPATH           ; get snapshot path
E616 2002             (      cmd_cat.asm):00138                 bra             FuncCWDC                                        ; Rest same as WD$
                      (      cmd_cat.asm):00139                 
                      (      cmd_cat.asm):00140         ;
                      (      cmd_cat.asm):00141         ; FuncCWD, return the current working directory as a string.
                      (      cmd_cat.asm):00142         ;
                      (      cmd_cat.asm):00143         
E618                  (      cmd_cat.asm):00144         FuncCWD
E618 8603             (      cmd_cat.asm):00145                 lda             #CMD_DIR_GETCWD                         ; Get current working directory
E61A                  (      cmd_cat.asm):00146         FuncCWDC
E61A BDE00E           (      cmd_cat.asm):00147                 jsr     >MMC_SendCmd
E61D BDE2D5           (      cmd_cat.asm):00148                 jsr     >CheckError                                     ; check for errors, returns to basic on error
                      (      cmd_cat.asm):00149         
E620 2009             (      cmd_cat.asm):00150             bra     FuncRetMMCString            ; Return it
                      (      cmd_cat.asm):00151         
E622                  (      cmd_cat.asm):00152         GetStrLenA
E622 8630             (      cmd_cat.asm):00153                 lda             #CMD_GET_STRLEN                         ; get length of returned path
E624 BDE017           (      cmd_cat.asm):00154                 jsr     >MMC_SendCmdRaw
E627 B6FF51           (      cmd_cat.asm):00155                 lda             D_LATCH_REG
                      (      cmd_cat.asm):00156         ;       jsr     >MMC_WaitGetWritten                     ; Wait for byte, and get it in a
E62A 39               (      cmd_cat.asm):00157             rts
                      (      cmd_cat.asm):00158             
E62B                  (      cmd_cat.asm):00159         FuncRetMMCString
E62B 8DF5             (      cmd_cat.asm):00160             bsr     GetStrLenA
                      (      cmd_cat.asm):00161             
E62D                  (      cmd_cat.asm):00162         FuncRetMMCStringLenA
E62D 1F89             (      cmd_cat.asm):00163                 tfr             a,b                                                     ; move length to b
E62F 3402             (      cmd_cat.asm):00164                 pshs    a
E631 BDB50F           (      cmd_cat.asm):00165                 JSR     >BasResStr                                      ; reserve string space, exits with OS error if no space
                      (      cmd_cat.asm):00166                                                                                         ; X points to string
E634 3504             (      cmd_cat.asm):00167                 puls    b                                                       ; recover length
E636 5D               (      cmd_cat.asm):00168                 tstb                                                            ; check for zero length string
E637 270D             (      cmd_cat.asm):00169                 beq             FuncRetMMCStringExit            ; yes don't copy anything
                      (      cmd_cat.asm):00170                 
E639 8620             (      cmd_cat.asm):00171                 lda             #CMD_INIT_READ                          ; Start reading filename 
E63B BDE017           (      cmd_cat.asm):00172                 jsr         >MMC_SendCmdRaw
                      (      cmd_cat.asm):00173         
E63E                  (      cmd_cat.asm):00174         FuncCWDLoop
E63E BDECCA           (      cmd_cat.asm):00175                 jsr         >MMC_WaitGetWritten                 ; Wait for byte, and get it in a
E641 A780             (      cmd_cat.asm):00176                 sta             ,x+
E643 5A               (      cmd_cat.asm):00177                 decb                                                            ; decrement count
E644 26F8             (      cmd_cat.asm):00178                 bne             FuncCWDLoop                                     ; more : keep going
                      (      cmd_cat.asm):00179                 
E646                  (      cmd_cat.asm):00180         FuncRetMMCStringExit
E646 7EB69B           (      cmd_cat.asm):00181                 JMP             >VarReturnStr                           ; return string to basic.
                      (      cmd_cat.asm):00182                 
                      (      cmd_cat.asm):00183         ;
                      (      cmd_cat.asm):00184         ; Find first file
                      (      cmd_cat.asm):00185         ;
                      (      cmd_cat.asm):00186         
E649                  (      cmd_cat.asm):00187         FuncFindFirst
E649 8D8F             (      cmd_cat.asm):00188                 bsr             InitDirRead                                     ; Shared by cat and findfirst
                      (      cmd_cat.asm):00189         
                      (      cmd_cat.asm):00190         ;
                      (      cmd_cat.asm):00191         ; Find next file.
                      (      cmd_cat.asm):00192         ;
                      (      cmd_cat.asm):00193         
E64B                  (      cmd_cat.asm):00194         FuncFindNext
E64B 8601             (      cmd_cat.asm):00195                 lda             #CMD_DIR_READ                           ; get next entry
E64D 17F9BE           (      cmd_cat.asm):00196                 lbsr    MMC_SendCmd
E650 17FC82           (      cmd_cat.asm):00197                 lbsr    CheckError                                      ; check for errors, returns to basic on error
                      (      cmd_cat.asm):00198                 
E653 8141             (      cmd_cat.asm):00199                 cmpa    #STATUS_COMPLETE+STATUS_LAST            ; Listed all entries ?
E655 2702             (      cmd_cat.asm):00200                 beq             FindEnd
E657 20D2             (      cmd_cat.asm):00201                 bra             FuncRetMMCString                        ; return filename to basic
                      (      cmd_cat.asm):00202                 
E659                  (      cmd_cat.asm):00203         FindEnd
E659 4F               (      cmd_cat.asm):00204                 clra                                                            ; return no bytes
E65A 20D1             (      cmd_cat.asm):00205                 bra             FuncRetMMCStringLenA
                      (      cmd_cat.asm):00206                 
E65C                  (      cmd_cat.asm):00207         __cmd_cat_end
                      (      cmd_cat.asm):00208         
                      (    DragonMMC.asm):00665                         use             cmd_delete.asm
                      (   cmd_delete.asm):00001         ;
                      (   cmd_delete.asm):00002         ; cmd_delete.asm : delete the specified file.
                      (   cmd_delete.asm):00003         ;
                      (   cmd_delete.asm):00004         
E65C                  (   cmd_delete.asm):00005         __cmd_delete
                      (   cmd_delete.asm):00006         
     0043             (   cmd_delete.asm):00007         MFileFlagCopy   equ     'C'
     0052             (   cmd_delete.asm):00008         MFileFlagRename equ     'R'
     0053             (   cmd_delete.asm):00009         MFileFlagSync   equ     'S'
                      (   cmd_delete.asm):00010         
E65C                  (   cmd_delete.asm):00011         CmdMDelete
E65C 17FC48           (   cmd_delete.asm):00012                         lbsr    GetSendFileName         ; Get filename send to MMC
E65F 308DFD2F         (   cmd_delete.asm):00013                         leax    DeleteMess-1,PCR        ; Prompt the user
E663 BDB99C           (   cmd_delete.asm):00014                         jsr     >TextOutString  
                      (   cmd_delete.asm):00015                         
                      (   cmd_delete.asm):00016                         
E666                  (   cmd_delete.asm):00017         CmdMDeleteLoop
E666 BDA1C1           (   cmd_delete.asm):00018                         jsr             >BasicKbdIn                     ; Poll keyboard
E669 27FB             (   cmd_delete.asm):00019                         beq             CmdMDeleteLoop          ; No key pressed loop again
                      (   cmd_delete.asm):00020                         
E66B 814E             (   cmd_delete.asm):00021                         cmpa    #'N'                                    ; No key pressed ?
E66D 270C             (   cmd_delete.asm):00022                         beq             CmdMDeleteExit          ; yes : exit
                      (   cmd_delete.asm):00023                         
E66F 8159             (   cmd_delete.asm):00024                         cmpa    #'Y'                                    ; Yes key pressed ?
E671 26F3             (   cmd_delete.asm):00025                         bne             CmdMDeleteLoop          ; no : keep waiting
                      (   cmd_delete.asm):00026                         
E673 8614             (   cmd_delete.asm):00027                         lda             #CMD_FILE_DELETE        ; Delete the file
E675 17F996           (   cmd_delete.asm):00028                         lbsr    MMC_SendCmd                     ; send it
E678 17FC5A           (   cmd_delete.asm):00029                         lbsr    CheckError                      ; and check for error
                      (   cmd_delete.asm):00030         
E67B                  (   cmd_delete.asm):00031         CmdMDeleteExit
E67B 4F               (   cmd_delete.asm):00032                         clra
E67C 39               (   cmd_delete.asm):00033                         rts
                      (   cmd_delete.asm):00034         ;
                      (   cmd_delete.asm):00035         ; MFile, copy or rename file.
                      (   cmd_delete.asm):00036         ;               
E67D                  (   cmd_delete.asm):00037         CmdMFile
E67D 8143             (   cmd_delete.asm):00038                         cmpa    #MFileFlagCopy          ; is it a copy?
E67F 270B             (   cmd_delete.asm):00039                         beq             CmdMFileValid           ; yep
E681 8152             (   cmd_delete.asm):00040                         cmpa    #MFileFlagRename        ; is it a copy?
E683 2707             (   cmd_delete.asm):00041                         beq             CmdMFileValid           ; yep
E685 8153             (   cmd_delete.asm):00042                         cmpa    #MFileFlagSync          ; is it a Sync?
E687 2724             (   cmd_delete.asm):00043                         beq             CmdMFileSync            ; do a sync
E689 7EB277           (   cmd_delete.asm):00044                         jmp             >BasSNError                     ; none, error
                      (   cmd_delete.asm):00045                         
E68C                  (   cmd_delete.asm):00046         CmdMFileValid
E68C 3402             (   cmd_delete.asm):00047                         pshs    a                                       ; save copy / rename flag
                      (   cmd_delete.asm):00048                         
E68E 9D9F             (   cmd_delete.asm):00049                         jsr     <BasChrGet                      ; skip op flag.
E690 BDE2A7           (   cmd_delete.asm):00050                 jsr             >GetSendFileName        ; get first filename, send it
E693 BDB26D           (   cmd_delete.asm):00051                         jsr             >VarCKComma                     ; check for comma, error if not
E696 BDE2AD           (   cmd_delete.asm):00052                         jsr             >GetSendFileName2       ; Send the second name
                      (   cmd_delete.asm):00053                         
E699 3502             (   cmd_delete.asm):00054                         puls    a                                       ; retrieve copy / rename flag
                      (   cmd_delete.asm):00055                         
E69B 8143             (   cmd_delete.asm):00056                         cmpa    #MFileFlagCopy          ; Copy ?
E69D 2604             (   cmd_delete.asm):00057                         bne             CmdMFileDoRename        ; nope skip
E69F 861D             (   cmd_delete.asm):00058                         lda             #CMD_FILE_COPY          ; do a copy
E6A1 2002             (   cmd_delete.asm):00059                         bra             CmdMfileDoCmd
                      (   cmd_delete.asm):00060                         
E6A3                  (   cmd_delete.asm):00061         CmdMFileDoRename
E6A3 861E             (   cmd_delete.asm):00062                         lda             #CMD_FILE_RENAME        ; do a rename
                      (   cmd_delete.asm):00063         
E6A5                  (   cmd_delete.asm):00064         CmdMfileDoCmd
E6A5 17F966           (   cmd_delete.asm):00065                         lbsr    MMC_SendCmd                     ; send it
E6A8 17FC2A           (   cmd_delete.asm):00066                         lbsr    CheckError                      ; and check for error
                      (   cmd_delete.asm):00067         
E6AB 4F               (   cmd_delete.asm):00068                         clra
E6AC 39               (   cmd_delete.asm):00069                         rts
                      (   cmd_delete.asm):00070         
E6AD                  (   cmd_delete.asm):00071         CmdMFileSync
E6AD 9D9F             (   cmd_delete.asm):00072                         jsr     <BasChrGet                      ; skip op flag.
E6AF 8692             (   cmd_delete.asm):00073                         lda             #CMD_SYNC                       ; Sync command
E6B1 20F2             (   cmd_delete.asm):00074                         bra             CmdMfileDoCmd           ; go do it!
                      (   cmd_delete.asm):00075                         
E6B3                  (   cmd_delete.asm):00076         __cmd_delete_end
                      (    DragonMMC.asm):00666                         use             cmds_direct.asm
                      (  cmds_direct.asm):00001         ;
                      (  cmds_direct.asm):00002         ; cmds_direct.asm : commands for loading and saving direct to the disk.
                      (  cmds_direct.asm):00003         ;
                      (  cmds_direct.asm):00004         ; 2019-04-01, added MLOADR / MSAVER for loading / saving raw files 
                      (  cmds_direct.asm):00005         ; (without a header) to / from  memory.
                      (  cmds_direct.asm):00006         ; 
                      (  cmds_direct.asm):00007         
E6B3                  (  cmds_direct.asm):00008         __cmd_direct
                      (  cmds_direct.asm):00009         
     0000             (  cmds_direct.asm):00010         DebugTest       equ     0
                      (  cmds_direct.asm):00011         
     004D             (  cmds_direct.asm):00012         MSaveFlagMCode  equ             'M'
     0041             (  cmds_direct.asm):00013         MLoadFlagAuto   equ             'A'
     0043             (  cmds_direct.asm):00014         MloadFlagClear  equ             'C'
     0053             (  cmds_direct.asm):00015         MloadFlagSnap   equ             'S'
     0052             (  cmds_direct.asm):00016         MloadFlagRaw    equ             'R'
                      (  cmds_direct.asm):00017         
                      (  cmds_direct.asm):00018         
     0032             (  cmds_direct.asm):00019         AutoWaitTime    equ     (1*50)          ; Wait time in IRQ periods 50Hz for PAL, 60Hz for NTSC.
                      (  cmds_direct.asm):00020         
                      (  cmds_direct.asm):00021         ;
                      (  cmds_direct.asm):00022         ; MSave, same format as DragonDos save, files format compatible.
                      (  cmds_direct.asm):00023         ;
                      (  cmds_direct.asm):00024         ; MSave  "filename"
                      (  cmds_direct.asm):00025         ; MSaveM "Filename",start,end,entry
                      (  cmds_direct.asm):00026         ;
                      (  cmds_direct.asm):00027         
E6B3                  (  cmds_direct.asm):00028         CmdMSave
E6B3 814D             (  cmds_direct.asm):00029                         cmpa    #MSaveFlagMCode                 ; check for 'M'
E6B5 3402             (  cmds_direct.asm):00030                         pshs    a                                               ; save next letter
E6B7 2602             (  cmds_direct.asm):00031                         bne             CmdMSaveFname                   ; nope, skip
E6B9 9D9F             (  cmds_direct.asm):00032                         JSR     <BasChrGet                              ; skip the M
                      (  cmds_direct.asm):00033         
E6BB                  (  cmds_direct.asm):00034         CmdMSaveFname
E6BB 17FBE9           (  cmds_direct.asm):00035                         lbsr    GetSendFileName                 ; Get filename send to MMC
E6BE 3502             (  cmds_direct.asm):00036                         puls    a
                      (  cmds_direct.asm):00037         
E6C0 3440             (  cmds_direct.asm):00038                         pshs    u                                               ; Make temp stack frame
E6C2 3277             (  cmds_direct.asm):00039                         leas    -FileHeadLen,s
                      (  cmds_direct.asm):00040         
                      (  cmds_direct.asm):00041         
E6C4 814D             (  cmds_direct.asm):00042                 cmpa    #MSaveFlagMCode                 ; is it MSAVEM  
E6C6 2623             (  cmds_direct.asm):00043                         bne             CmdSaveBasic                    ; nope : it's basic save as such
                      (  cmds_direct.asm):00044                         
E6C8 33E4             (  cmds_direct.asm):00045                         leau    ,s                                              ; U=S
                      (  cmds_direct.asm):00046                         
E6CA 8D53             (  cmds_direct.asm):00047                         bsr             GetCommaThen16                  ; Get start addr
E6CC AF42             (  cmds_direct.asm):00048                         stx             HdrLoad,u
                      (  cmds_direct.asm):00049                         
E6CE 8D4F             (  cmds_direct.asm):00050                         bsr             GetCommaThen16                  ; Get end addr
E6D0 1F10             (  cmds_direct.asm):00051                         tfr             x,d
E6D2 AC42             (  cmds_direct.asm):00052                         cmpx    HdrLoad,u               
E6D4 1025CD72         (  cmds_direct.asm):00053                         lbcs    BasFCError
                      (  cmds_direct.asm):00054                         
E6D8 A342             (  cmds_direct.asm):00055                         subd    HdrLoad,u                               ; Convert to length
E6DA 102BCD6C         (  cmds_direct.asm):00056                         lbmi    BasFCError                              ; ?FC error if -ve
E6DE C30001           (  cmds_direct.asm):00057                         addd    #1                                              ; fixup 
E6E1 ED44             (  cmds_direct.asm):00058                         std             HdrLen,u                                ; Save length
                      (  cmds_direct.asm):00059                         
E6E3 8D3A             (  cmds_direct.asm):00060                         bsr             GetCommaThen16                  ; Get entry address
E6E5 AF46             (  cmds_direct.asm):00061                         stx             HdrExec,u
                      (  cmds_direct.asm):00062                         
E6E7 8602             (  cmds_direct.asm):00063                         lda             #FTypeBin                               ; Set as binary
                      (  cmds_direct.asm):00064                         
E6E9 2013             (  cmds_direct.asm):00065                         bra             CmdSaveCommon                   ; Go save it
                      (  cmds_direct.asm):00066                         
E6EB                  (  cmds_direct.asm):00067         CmdSaveBasic
E6EB 33E4             (  cmds_direct.asm):00068                         leau    ,s                                              ; U=S
E6ED 9E19             (  cmds_direct.asm):00069                         ldx             <BasStartProg                   ; get start of program
E6EF AF42             (  cmds_direct.asm):00070                         stx             HdrLoad,u
                      (  cmds_direct.asm):00071                         
E6F1 DC1B             (  cmds_direct.asm):00072                         ldd             <BasVarSimpleAddr               ; get end of program
E6F3 9319             (  cmds_direct.asm):00073                         subd    <BasStartProg                   ; calculate length
E6F5 ED44             (  cmds_direct.asm):00074                         std             HdrLen,u
                      (  cmds_direct.asm):00075                         
E6F7 8EB44A           (  cmds_direct.asm):00076                         LDX     #BasFCError                             ; Exec address = FC Error
E6FA AF46             (  cmds_direct.asm):00077                         stx             HdrExec,u
                      (  cmds_direct.asm):00078         
E6FC 8601             (  cmds_direct.asm):00079                         lda             #FTypeBas                               ; Set as basic
                      (  cmds_direct.asm):00080                         
E6FE                  (  cmds_direct.asm):00081         CmdSaveCommon
E6FE A741             (  cmds_direct.asm):00082                         sta             HdrType,u               
                      (  cmds_direct.asm):00083         
E700 8655             (  cmds_direct.asm):00084                         lda             #$55                                    ; Save ID bytes
E702 A7C4             (  cmds_direct.asm):00085                         sta             HdrID55,u
E704 43               (  cmds_direct.asm):00086                         coma
E705 A748             (  cmds_direct.asm):00087                         sta             HdrIDAA,u
                      (  cmds_direct.asm):00088                         
E707 8600             (  cmds_direct.asm):00089                         lda             #CAS_FILE                               ; open default file
E709 17F90F           (  cmds_direct.asm):00090                         lbsr    MMC_WaitPutLatchRead    ; send file id to latch register
                      (  cmds_direct.asm):00091         
E70C 8613             (  cmds_direct.asm):00092                         lda             #CMD_FILE_OPEN_WRITE    ; Open file
E70E 17F8FD           (  cmds_direct.asm):00093                         lbsr    MMC_SendCmd                             ; Open file
E711 17FBC1           (  cmds_direct.asm):00094                         lbsr    CheckError                              ; Bomb out on error
                      (  cmds_direct.asm):00095                         
E714 170681           (  cmds_direct.asm):00096                         lbsr    MMC_SaveFile                    ; Save the file
                      (  cmds_direct.asm):00097                         
E717 1705B6           (  cmds_direct.asm):00098                         lbsr    MMC_CloseFile                   ; close the file
                      (  cmds_direct.asm):00099                         
E71A 4F               (  cmds_direct.asm):00100                         clra
E71B 3269             (  cmds_direct.asm):00101                         leas    FileHeadLen,s                   ; cleanup stack frame
E71D 35C0             (  cmds_direct.asm):00102                         puls    u,pc                                    ; restore / return
                      (  cmds_direct.asm):00103                 
E71F                  (  cmds_direct.asm):00104         GetCommaThen16
E71F 3440             (  cmds_direct.asm):00105                         pshs    u                                               ; save u as often clobbered !
E721 BDB26D           (  cmds_direct.asm):00106                         jsr     >VarCKComma                             ; Check for comma
E724 BDB73D           (  cmds_direct.asm):00107                 jsr     >VarGet16Bit                    ; returned in X, FCError if invalid
E727 35C0             (  cmds_direct.asm):00108                         puls    u,pc                                    ; restore / return
                      (  cmds_direct.asm):00109                         
                      (  cmds_direct.asm):00110         ;
                      (  cmds_direct.asm):00111         ; MLoad, load a DragonDos format compatible file.
                      (  cmds_direct.asm):00112         ;
                      (  cmds_direct.asm):00113         ; Syntax :
                      (  cmds_direct.asm):00114         ;       MLOAD filespec
                      (  cmds_direct.asm):00115         ;       MLOAD filespec,new_start_addr
                      (  cmds_direct.asm):00116         ;
                      (  cmds_direct.asm):00117         ; Auto-start:
                      (  cmds_direct.asm):00118         ;   MLOADA filespec
                      (  cmds_direct.asm):00119         ; Snapshot:
                      (  cmds_direct.asm):00120         ;   MLOADS filespec
                      (  cmds_direct.asm):00121         ; Clear back to machine power on state, then autorun 
                      (  cmds_direct.asm):00122         ;       MLOADC filespec
                      (  cmds_direct.asm):00123         ; Load a raw file :
                      (  cmds_direct.asm):00124         ;       MLOADR filespec,load_addr,length
                      (  cmds_direct.asm):00125         ;
                      (  cmds_direct.asm):00126         
E729                  (  cmds_direct.asm):00127         CmdMLoad
E729 8D07             (  cmds_direct.asm):00128                         bsr             DoCmdMLoad                              ; attempt to load
E72B 4D               (  cmds_direct.asm):00129                         tsta                                                    ; Error ?
E72C 2703             (  cmds_direct.asm):00130                         beq             CmdMLoadOK                              ; nope : just return
E72E 7EB44A           (  cmds_direct.asm):00131                         jmp             BasFCError                              ; Yep : error 
                      (  cmds_direct.asm):00132                         
E731                  (  cmds_direct.asm):00133         CmdMLoadOK
E731 39               (  cmds_direct.asm):00134                         rts
                      (  cmds_direct.asm):00135                         
E732                  (  cmds_direct.asm):00136         DoCmdMLoad
E732 3442             (  cmds_direct.asm):00137                         pshs    a,u                                             ; save next character
E734 8141             (  cmds_direct.asm):00138                         cmpa    #MLoadFlagAuto                  ; is it LOADA ?
E736 2714             (  cmds_direct.asm):00139                         beq             CmdMLoadAutoBoot                ; yep : do it
                      (  cmds_direct.asm):00140         
E738 8153             (  cmds_direct.asm):00141                 cmpa    #MloadFlagSnap          ; is is MLOADS ?
E73A 10270100         (  cmds_direct.asm):00142                 lbeq    CmdMLoadS               ; yep : do it
                      (  cmds_direct.asm):00143         
E73E 8143             (  cmds_direct.asm):00144                         cmpa    #MloadFlagClear                 ; is it MLOADC
E740 10270008         (  cmds_direct.asm):00145                         lbeq    CmdMLoadAutoBoot        ; yep : do it
                      (  cmds_direct.asm):00146         
E744 8152             (  cmds_direct.asm):00147                         cmpa    #MloadFlagRaw                   ; Is it MLOADR 
E746 1027006D         (  cmds_direct.asm):00148                         lbeq    CmdMloadRaw                             ; yep : do it
                      (  cmds_direct.asm):00149         
E74A 2002             (  cmds_direct.asm):00150                 bra     CmdMLoadNoSkip          ; don't skip first
                      (  cmds_direct.asm):00151                 
E74C                  (  cmds_direct.asm):00152         CmdMLoadAutoBoot
E74C 9D9F             (  cmds_direct.asm):00153                         JSR     <BasChrGet                              ; skip the A
E74E                  (  cmds_direct.asm):00154         CmdMLoadNoSkip
E74E BDE830           (  cmds_direct.asm):00155                         JSR             CmdMLoadSendFName               ; Get filename send to MMC, open file
E751 8180             (  cmds_direct.asm):00156                         cmpa    #STATUS_ERROR           ; Error ?
E753 102400B2         (  cmds_direct.asm):00157                         lbhs    CmdMLoadError2                  ; Yes : flag it
                      (  cmds_direct.asm):00158         
E757 A6E4             (  cmds_direct.asm):00159                         lda             ,s                                              ; Recover flag
E759 8143             (  cmds_direct.asm):00160                         cmpa    #MloadFlagClear                 ; MLOADC?
E75B 2609             (  cmds_direct.asm):00161                         bne             CmdMloadAutoexec                ; nope : skip
                      (  cmds_direct.asm):00162                         
E75D 3542             (  cmds_direct.asm):00163                         puls    a,u                                             ; get saved regs off stack as we will move it
                      (  cmds_direct.asm):00164                         
E75F BDF03E           (  cmds_direct.asm):00165                         jsr             >DO_ResetPoweron                ; reset memory map.
                      (  cmds_direct.asm):00166         
E762 8641             (  cmds_direct.asm):00167                         lda             #MLoadFlagAuto                  ; change to auto-run flag
E764 3442             (  cmds_direct.asm):00168                         pshs    a,u                                             ; re-save them
                      (  cmds_direct.asm):00169         
E766                  (  cmds_direct.asm):00170         CmdMloadAutoexec
E766 3277             (  cmds_direct.asm):00171                         leas    -FileHeadLen,s                  ; Make temp stack frame
E768 33E4             (  cmds_direct.asm):00172                         leau    ,s                                              ; U=S
                      (  cmds_direct.asm):00173         
E76A 30C4             (  cmds_direct.asm):00174                         leax    ,u                                              ; Get address for file header
E76C C609             (  cmds_direct.asm):00175                         ldb             #FileHeadLen                    ; Read file header bytes
E76E 17058C           (  cmds_direct.asm):00176                         lbsr    MMC_ReadFileBlock               ; go read it
                      (  cmds_direct.asm):00177                         
E771 8655             (  cmds_direct.asm):00178                         lda             #$55                                    ; Check marker bytes
E773 A1C4             (  cmds_direct.asm):00179                         cmpa    HdrID55,u               
E775 1026008E         (  cmds_direct.asm):00180                         lbne    CmdMLoadError           
                      (  cmds_direct.asm):00181                         
E779 43               (  cmds_direct.asm):00182                         coma
E77A A148             (  cmds_direct.asm):00183                         cmpa    HdrIDAA,u
E77C 10260087         (  cmds_direct.asm):00184                         lbne    CmdMLoadError           
                      (  cmds_direct.asm):00185                         
E780 A641             (  cmds_direct.asm):00186                         lda             HdrType,u                               ; Get filetype
E782 8101             (  cmds_direct.asm):00187                         cmpa    #FTypeBas                               ; Basic file ?
E784 275A             (  cmds_direct.asm):00188                         beq             CmdMLoadBas                             ; yep : load it
                      (  cmds_direct.asm):00189                         
E786 8102             (  cmds_direct.asm):00190                         cmpa    #FTypeBin                               ; Binary file ?
E788 1026007B         (  cmds_direct.asm):00191                         lbne    CmdMLoadError                   ; nope, error
                      (  cmds_direct.asm):00192         
E78C AE46             (  cmds_direct.asm):00193                         ldx             HdrExec,u                               ; Get exec address
E78E 9F9D             (  cmds_direct.asm):00194                         stx             BasExecAddr                             ; set exec address
                      (  cmds_direct.asm):00195                 
E790 17FB2E           (  cmds_direct.asm):00196                         lbsr    CkComma                                 ; Comma ?
E793 260E             (  cmds_direct.asm):00197                         bne             CmdMLoadBinDef                  ; no : use default addresses
                      (  cmds_direct.asm):00198                         
E795 8D88             (  cmds_direct.asm):00199                         bsr             GetCommaThen16                  ; get new load address
E797 33E4             (  cmds_direct.asm):00200                         leau    ,s                                              ; U=S
                      (  cmds_direct.asm):00201                         
E799 EC46             (  cmds_direct.asm):00202                         ldd             HdrExec,u                               ; get exec address
E79B A342             (  cmds_direct.asm):00203                         subd    HdrLoad,u                               ; subtract start address, calculate exec offset from start
E79D AF42             (  cmds_direct.asm):00204                         stx             HdrLoad,u                               ; save new load address in header
E79F E342             (  cmds_direct.asm):00205                         addd    HdrLoad,u                               ; calculate new exec address
E7A1 DD9D             (  cmds_direct.asm):00206                         std             BasExecAddr                             ; set exec address
                      (  cmds_direct.asm):00207         
E7A3                  (  cmds_direct.asm):00208         CmdMLoadBinDef          
E7A3 170613           (  cmds_direct.asm):00209                         lbsr    MMC_LoadFile                    ; load the file
E7A6 170527           (  cmds_direct.asm):00210                         lbsr    MMC_CloseFile                   ; close the file
                      (  cmds_direct.asm):00211         
E7A9 3269             (  cmds_direct.asm):00212                         leas    FileHeadLen,s                   ; cleanup stack frame
E7AB 3542             (  cmds_direct.asm):00213                         puls    a,u                                             ; recover auto flag
E7AD 8141             (  cmds_direct.asm):00214                         cmpa    #MLoadFlagAuto                  ; auto-run ?
E7AF 2604             (  cmds_direct.asm):00215                         bne             CmdMLoadBinExit                 ; nope : return
                      (  cmds_direct.asm):00216         
E7B1 6E9F009D         (  cmds_direct.asm):00217                         jmp             [BasExecAddr]                   ; Run the loaded code
                      (  cmds_direct.asm):00218         
E7B5                  (  cmds_direct.asm):00219         CmdMLoadBinExit         
E7B5 4F               (  cmds_direct.asm):00220                         clra
E7B6 39               (  cmds_direct.asm):00221                         rts                                                             ; restore / return
                      (  cmds_direct.asm):00222         
E7B7                  (  cmds_direct.asm):00223         CmdMloadRaw
E7B7 BDE82E           (  cmds_direct.asm):00224                         JSR             CmdMLoadSkipSendFName   ; skicp character, send filename
                      (  cmds_direct.asm):00225                         
E7BA 8180             (  cmds_direct.asm):00226                         cmpa    #STATUS_ERROR           ; Error ?
E7BC 10240049         (  cmds_direct.asm):00227                         lbhs    CmdMLoadError2                  ; Yes : flag it
                      (  cmds_direct.asm):00228         
E7C0 17FAFE           (  cmds_direct.asm):00229                         lbsr    CkComma                                 ; Is there a comma and load address?
E7C3 2644             (  cmds_direct.asm):00230                         bne             CmdMLoadError2
E7C5 17FF57           (  cmds_direct.asm):00231                         lbsr    GetCommaThen16                  ; get new load address
                      (  cmds_direct.asm):00232                         
E7C8 3410             (  cmds_direct.asm):00233                         pshs    x                                               ; save load address
                      (  cmds_direct.asm):00234                         
E7CA 17FAF4           (  cmds_direct.asm):00235                         lbsr    CkComma                                 ; Is there a comma and byte count?
E7CD 263A             (  cmds_direct.asm):00236                         bne             CmdMLoadError2
E7CF 17FF4D           (  cmds_direct.asm):00237                         lbsr    GetCommaThen16                  ; get byte count
                      (  cmds_direct.asm):00238                         
E7D2 1F13             (  cmds_direct.asm):00239                         tfr             x,u                                             ; byte count to u
E7D4 3510             (  cmds_direct.asm):00240                         puls    x                                               ; recover load address
                      (  cmds_direct.asm):00241                         
E7D6 1705E8           (  cmds_direct.asm):00242                         lbsr    MMC_LoadFile2                   ; Go load into memory
E7D9 1704F4           (  cmds_direct.asm):00243                         lbsr    MMC_CloseFile                   ; close the file
                      (  cmds_direct.asm):00244         
E7DC 3542             (  cmds_direct.asm):00245                         puls    a,u                                             ; clean up stack
E7DE 4F               (  cmds_direct.asm):00246                         clra
E7DF 39               (  cmds_direct.asm):00247                         rts                                                             ; restore / return      
                      (  cmds_direct.asm):00248         
E7E0                  (  cmds_direct.asm):00249         CmdMLoadBas
E7E0 8D2F             (  cmds_direct.asm):00250                         bsr             LoadBasic                               ; load basic prog into memory
                      (  cmds_direct.asm):00251                                 
E7E2 9E19             (  cmds_direct.asm):00252                         ldx             <BasStartProg                   ; get base of loaded prog
E7E4 BDAEBB           (  cmds_direct.asm):00253                         jsr             >BasSetProgPtrX                 ; setup
                      (  cmds_direct.asm):00254                         
E7E7 9E27             (  cmds_direct.asm):00255                 ldx             <AddrFWareRamTop                ; get ramtop
E7E9 9F23             (  cmds_direct.asm):00256                         stx             <BasVarStrTop                   ; set top of string area
E7EB 9E1B             (  cmds_direct.asm):00257                         ldx             <BasVarSimpleAddr               ; get simple vars addr
E7ED 9F1D             (  cmds_direct.asm):00258                         stx             <BasVarArrayAddr                ; set array vars to be the same
E7EF 9F1F             (  cmds_direct.asm):00259                         stx             <BasVarEnd                              ; set end of basic vars
                      (  cmds_direct.asm):00260                         
E7F1 BDADE4           (  cmds_direct.asm):00261                         jsr             >CmdRestore                             ; do a restore
                      (  cmds_direct.asm):00262                 
E7F4 3269             (  cmds_direct.asm):00263                         leas    FileHeadLen,s                   ; cleanup stack frame
E7F6 3542             (  cmds_direct.asm):00264                         puls    a,u                                             ; recover auto flag (a)
                      (  cmds_direct.asm):00265         
E7F8 BDAD33           (  cmds_direct.asm):00266                         jsr             >BasResetStack                  ; reset the stack a preserved
                      (  cmds_direct.asm):00267                         
E7FB 8141             (  cmds_direct.asm):00268                         cmpa    #MLoadFlagAuto                  ; Auto run ?
E7FD 2604             (  cmds_direct.asm):00269                         bne             CmdMLoadBasExit                 ; nope : return to command mode
                      (  cmds_direct.asm):00270                         
E7FF 4F               (  cmds_direct.asm):00271                         clra    
E800 7EAD9E           (  cmds_direct.asm):00272                         jmp             BasRun                                  ; run it
                      (  cmds_direct.asm):00273         
E803                  (  cmds_direct.asm):00274         CmdMLoadBasExit
E803 4F               (  cmds_direct.asm):00275                         CLRA
E804 7EAC73           (  cmds_direct.asm):00276                 JMP     >BasCmdMode
                      (  cmds_direct.asm):00277         
E807                  (  cmds_direct.asm):00278         CmdMLoadError
E807 3269             (  cmds_direct.asm):00279                         leas    FileHeadLen,s                   ; cleanup stack frame
E809                  (  cmds_direct.asm):00280         CmdMLoadError2
E809 BDECD0           (  cmds_direct.asm):00281                         jsr             >MMC_CloseFile                  ; close the file
                      (  cmds_direct.asm):00282         
E80C 3542             (  cmds_direct.asm):00283                         puls    a,u                                             ; recover auto flag (a)
                      (  cmds_direct.asm):00284         
E80E 4F               (  cmds_direct.asm):00285                         clra                                                    ; flag error
E80F 43               (  cmds_direct.asm):00286                         coma
E810 39               (  cmds_direct.asm):00287                         rts
                      (  cmds_direct.asm):00288                         
E811                  (  cmds_direct.asm):00289         LoadBasic
E811 EC44             (  cmds_direct.asm):00290                         ldd             HdrLen,u                                ; get file length
E813 D319             (  cmds_direct.asm):00291                         addd    <BasStartProg                   ; add start of basic text
E815 DD1F             (  cmds_direct.asm):00292                         std             <BasVarEnd                              ; set end of storage
                      (  cmds_direct.asm):00293                         
E817 C640             (  cmds_direct.asm):00294                         ldb             #$40                                    ; check to see there's enough memory
E819 BDAC33           (  cmds_direct.asm):00295                         jsr             >BasChkB2Free
                      (  cmds_direct.asm):00296                 
E81C 9E19             (  cmds_direct.asm):00297                         ldx             <BasStartProg                   ; get load address
E81E AF42             (  cmds_direct.asm):00298                         stx             HdrLoad,u                               ; save in header
                      (  cmds_direct.asm):00299                 
E820 170596           (  cmds_direct.asm):00300                         lbsr    MMC_LoadFile                    ; load the file
E823 BDACEF           (  cmds_direct.asm):00301                         jsr             >BasVect2                               ; setup basic program 
                      (  cmds_direct.asm):00302                 
E826 3002             (  cmds_direct.asm):00303                         leax    2,x                                             ; setup vars
E828 9F1B             (  cmds_direct.asm):00304                         stx             <BasVarSimpleAddr
E82A 1704A3           (  cmds_direct.asm):00305                         lbsr    MMC_CloseFile                   ; close the file
E82D 39               (  cmds_direct.asm):00306                         rts
                      (  cmds_direct.asm):00307         
                      (  cmds_direct.asm):00308         ;
                      (  cmds_direct.asm):00309         ; Skip first character send filename....
                      (  cmds_direct.asm):00310         ;
                      (  cmds_direct.asm):00311         
E82E                  (  cmds_direct.asm):00312         CmdMLoadSkipSendFName
E82E 9D9F             (  cmds_direct.asm):00313                         JSR     <BasChrGet                          ; skip the fist char
E830                  (  cmds_direct.asm):00314         CmdMLoadSendFName
E830 BDE2A7           (  cmds_direct.asm):00315                         JSR         >GetSendFileName            ; Get filename send to MMC
                      (  cmds_direct.asm):00316         
E833 8600             (  cmds_direct.asm):00317                         lda             #CAS_FILE                               ; open default file
E835 17F7E3           (  cmds_direct.asm):00318                         lbsr    MMC_WaitPutLatchRead    ; send file id to latch register
                      (  cmds_direct.asm):00319                 
E838 8611             (  cmds_direct.asm):00320                         lda             #CMD_FILE_OPEN_READ         ; Open file
E83A 17F7D1           (  cmds_direct.asm):00321                         lbsr    MMC_SendCmd                     ; Open file
                      (  cmds_direct.asm):00322                 
E83D 39               (  cmds_direct.asm):00323                 rts
                      (  cmds_direct.asm):00324                 
E83E                  (  cmds_direct.asm):00325         CmdMLoadS
E83E BDE82E           (  cmds_direct.asm):00326                 jsr     CmdMLoadSkipSendFName   ; get send filename
E841 2B05             (  cmds_direct.asm):00327                 bmi     CmdMLoadSError          ; error :exit
                      (  cmds_direct.asm):00328                         
E843 1A50             (  cmds_direct.asm):00329                 orcc    #(FlagFIRQ+FlagIRQ)             ; Make sure ints disabled
                      (  cmds_direct.asm):00330                 
E845 160955           (  cmds_direct.asm):00331                 lbra    NMILoadEntry            ; file open, jump into snapshot load.
                      (  cmds_direct.asm):00332                 
E848                  (  cmds_direct.asm):00333         CmdMLoadSError
E848 3263             (  cmds_direct.asm):00334                 leas    3,s                     ; drop saved registers
E84A 39               (  cmds_direct.asm):00335                 rts
                      (  cmds_direct.asm):00336                         
                      (  cmds_direct.asm):00337         ;
                      (  cmds_direct.asm):00338         ; TestAutoBoot, test if auto-booting is enabled, and try to boot if it is.
                      (  cmds_direct.asm):00339         ;
                      (  cmds_direct.asm):00340         
E84B                  (  cmds_direct.asm):00341         TestAutoBoot
E84B 9676             (  cmds_direct.asm):00342                         lda             <CFGByte                                ; Get config byte
                      (  cmds_direct.asm):00343                         
E84D 8440             (  cmds_direct.asm):00344                         anda    #CFG_ENABLE_AUTOBOOT    ; auto-boot enabled ?
E84F 2723             (  cmds_direct.asm):00345                         beq             NoAutoBoot                              ; nope return
                      (  cmds_direct.asm):00346         
E851 308D0034         (  cmds_direct.asm):00347                         leax    AttemptBootMess,pcr             ; point at message
E855 BDEF46           (  cmds_direct.asm):00348                         jsr             >CON_WriteString                ; print it
                      (  cmds_direct.asm):00349         
E858 8D1C             (  cmds_direct.asm):00350                 bsr     AutoScanKbd             ; scan keyboard
E85A 8120             (  cmds_direct.asm):00351                         cmpa    #$20                                    ; space ?
E85C 270F             (  cmds_direct.asm):00352                         beq             AutoBootAbort                   ; yep skip auto boot
                      (  cmds_direct.asm):00353         
E85E BDEF38           (  cmds_direct.asm):00354                         jsr             >CON_EOL
                      (  cmds_direct.asm):00355                         
                      (  cmds_direct.asm):00356                         ifdef   Dragon
                      (  cmds_direct.asm):00357                 lda     #CMD_FILE_OPENAUTOD     ; Change to root & Open AUTOEXEC, Dragon
                      (  cmds_direct.asm):00358                         else
E861 8617             (  cmds_direct.asm):00359                         lda             #CMD_FILE_OPENAUTOC     ; Change to root & Open AUTOEXEC, CoCo
                      (  cmds_direct.asm):00360                         endc
                      (  cmds_direct.asm):00361                         
E863 17F7A8           (  cmds_direct.asm):00362                         lbsr    MMC_SendCmd
                      (  cmds_direct.asm):00363                 
E866 8641             (  cmds_direct.asm):00364                         lda             #MLoadFlagAuto                  ; Auto boot 'flag'
E868 3442             (  cmds_direct.asm):00365                         pshs    u,a                                             ; stack them
                      (  cmds_direct.asm):00366                         
E86A 16FEF9           (  cmds_direct.asm):00367                         lbra    CmdMloadAutoexec        ; Attempt to open / load
                      (  cmds_direct.asm):00368         
E86D                  (  cmds_direct.asm):00369         AutoBootAbort
E86D 308D0025         (  cmds_direct.asm):00370                         leax    AbortBootMess,pcr               ; point at message
E871 BDEF46           (  cmds_direct.asm):00371                         jsr             >CON_WriteString                ; print it
                      (  cmds_direct.asm):00372                         
E874                  (  cmds_direct.asm):00373         NoAutoBoot
E874 4F               (  cmds_direct.asm):00374                         clra    
E875 39               (  cmds_direct.asm):00375                         rts
                      (  cmds_direct.asm):00376         
E876                  (  cmds_direct.asm):00377         AutoScanKbd
E876 BE0112           (  cmds_direct.asm):00378                         ldx             SysTimeVal                              ; Get current timer
E879 308832           (  cmds_direct.asm):00379                         leax    AutoWaitTime,x                  ; Time to wait
                      (  cmds_direct.asm):00380                 
E87C                  (  cmds_direct.asm):00381         PollAgain
E87C 13               (  cmds_direct.asm):00382                 sync
E87D BDA1C1           (  cmds_direct.asm):00383                         jsr             >BasicKbdIn                             ; check keyboard
E880 2605             (  cmds_direct.asm):00384                         bne             AutoScanKbdExit                 ; key pressed, exit loop        
E882 BC0112           (  cmds_direct.asm):00385                 cmpx    SysTimeVal                              ; time reached value yet?
E885 24F5             (  cmds_direct.asm):00386                         bhs             PollAgain                               ; nope keep going       
                      (  cmds_direct.asm):00387         
E887                  (  cmds_direct.asm):00388         AutoScanKbdExit
E887 4D               (  cmds_direct.asm):00389                 tsta
E888 39               (  cmds_direct.asm):00390                 rts
                      (  cmds_direct.asm):00391                 
E889                  (  cmds_direct.asm):00392         AttemptBootMess 
E889 4155544F424F4F54 (  cmds_direct.asm):00393                         FCC             "AUTOBOOT...."
     2E2E2E2E
E895 00               (  cmds_direct.asm):00394                         FCB             $00
                      (  cmds_direct.asm):00395         
E896                  (  cmds_direct.asm):00396         AbortBootMess
E896 41424F525445442E (  cmds_direct.asm):00397                         FCC             "ABORTED."
E89E 0D00             (  cmds_direct.asm):00398                         FCB             $0d,$00
                      (  cmds_direct.asm):00399         
E8A0                  (  cmds_direct.asm):00400         __cmd_direct_end
                      (    DragonMMC.asm):00667                         use             cmds_cart.asm
                      (    cmds_cart.asm):00001         ;
                      (    cmds_cart.asm):00002         ; cmds_cart, commands for loading carts.
                      (    cmds_cart.asm):00003         ; 
                      (    cmds_cart.asm):00004         
E8A0                  (    cmds_cart.asm):00005         __cmd_cart
                      (    cmds_cart.asm):00006         
E8A0                  (    cmds_cart.asm):00007         CmdCartLoad:
E8A0 8141             (    cmds_cart.asm):00008                         cmpa    #'A                                             ; is this a McartloadA ?
E8A2 2606             (    cmds_cart.asm):00009                         bne             CmdCartLoadNoAuto
E8A4 3402             (    cmds_cart.asm):00010                         pshs    a                                               ; save auto flag for later
E8A6 9D9F             (    cmds_cart.asm):00011                         JSR     <BasChrGet                              ; skip the A
                      (    cmds_cart.asm):00012                         
E8A8 2003             (    cmds_cart.asm):00013                         bra             CmdCartLoadOpen                 ; open the file
E8AA                  (    cmds_cart.asm):00014         CmdCartLoadNoAuto
E8AA 4F               (    cmds_cart.asm):00015                         clra                                                    ; flag not auto
E8AB 3402             (    cmds_cart.asm):00016                         pshs    a                                               ; save for later
                      (    cmds_cart.asm):00017         
E8AD                  (    cmds_cart.asm):00018         CmdCartLoadOpen
E8AD 17FB30           (    cmds_cart.asm):00019                         lbsr    CmdMRMountEntry                 ; Get filename and open for reading
E8B0 17FC58           (    cmds_cart.asm):00020                         lbsr    CmdRamBoot                              ; Copy Basic / Cart rom to ram
                      (    cmds_cart.asm):00021                         
E8B3 17FC81           (    cmds_cart.asm):00022                 lbsr    GoROMMode               ; make sure we are in ROM, ram write enabled
                      (    cmds_cart.asm):00023                         
E8B6 8EC000           (    cmds_cart.asm):00024                         ldx             #$c000                                  ; point at cart rom base
                      (    cmds_cart.asm):00025         
E8B9                  (    cmds_cart.asm):00026         CmdCartLoadNext:
E8B9 4F               (    cmds_cart.asm):00027                         clra                                                    ; read 256 bytes
                      (    cmds_cart.asm):00028                         
E8BA 170424           (    cmds_cart.asm):00029                         lbsr    MMC_ReadFCommon                 ; Tell AVR we want to read bytes
E8BD 5F               (    cmds_cart.asm):00030                         clrb
                      (    cmds_cart.asm):00031                                                 
E8BE                  (    cmds_cart.asm):00032         CmdCartLoadBlkLoop:
E8BE 170409           (    cmds_cart.asm):00033                         lbsr    MMC_WaitGetWritten              ; get the byte, returned in a
E8C1 A780             (    cmds_cart.asm):00034                         sta             ,x+                                             ; save in buffer
E8C3 5C               (    cmds_cart.asm):00035                         incb                                                    ; inc counter
E8C4 26F8             (    cmds_cart.asm):00036                         bne             CmdCartLoadBlkLoop              ; Get next byte
                      (    cmds_cart.asm):00037                         
E8C6 8CFF00           (    cmds_cart.asm):00038                         cmpx    #$ff00                                  ; end of cart area ?
E8C9 26EE             (    cmds_cart.asm):00039                         bne             CmdCartLoadNext                 ; nope do next block
                      (    cmds_cart.asm):00040                                 
E8CB 0F71             (    cmds_cart.asm):00041                         clr             WarmStartFlag                   ; make sure it's a cold boot
                      (    cmds_cart.asm):00042                         
E8CD 1A50             (    cmds_cart.asm):00043                         orcc    #FlagIRQ+FlagFIRQ               ; disable ints
                      (    cmds_cart.asm):00044                         
E8CF CE01DA           (    cmds_cart.asm):00045                         ldu             #CasIOBuff                              ; Copy code to cas buffer
E8D2 308D0008         (    cmds_cart.asm):00046                         leax    CmdCartRAMCode,pcr              ; point to ram code
E8D6 C61E             (    cmds_cart.asm):00047                         ldb             #CmdCartRAMCodeLen              ; bytes to copy
E8D8 BDA59A           (    cmds_cart.asm):00048                         jsr             UtilCopyBXtoU                   ; copy them
E8DB 7E01DA           (    cmds_cart.asm):00049                         jmp             CasIOBuff                               ; jump to called code
                      (    cmds_cart.asm):00050                         
                      (    cmds_cart.asm):00051                         
                      (    cmds_cart.asm):00052         ; This code has to be executed from outside the cart space as it pages
                      (    cmds_cart.asm):00053         ; the rom out. Though until the call is made to set the RAM_CTRL reg,
                      (    cmds_cart.asm):00054         ; we can still call ROM routines.
                      (    cmds_cart.asm):00055         
E8DE                  (    cmds_cart.asm):00056         CmdCartRAMCode:
                      (    cmds_cart.asm):00057         ;               lda     D_RAM_CTRL              ; get current control register
                      (    cmds_cart.asm):00058         
E8DE BDE020           (    cmds_cart.asm):00059                         jsr             MMC_GetRAMCTRL          ; get current control register
E8E1 84BD             (    cmds_cart.asm):00060                 anda    #~(D_RAM_VEC+D_NMI_ENABLE)  ; Turn off NMI button as almost certainly will be wrong!
E8E3 8A11             (    cmds_cart.asm):00061                         ora             #D_RAM_ENABLE+D_RAM_WP  ; put us in ram mode, write protected.
E8E5 6DE4             (    cmds_cart.asm):00062                 tst             ,s                                              ; test auto flag
E8E7 2702             (    cmds_cart.asm):00063                         beq             CmdCartRAMNoAuto
E8E9 8A04             (    cmds_cart.asm):00064                         ora             #D_FIRQ_ENABLE                  ; turn on FIRQ enable for auto-boot
E8EB                  (    cmds_cart.asm):00065         CmdCartRAMNoAuto:
E8EB BDE01B           (    cmds_cart.asm):00066                         jsr             MMC_WaitPutLatchRead    ; Put the new D_RAM_CTRL in the latch
                      (    cmds_cart.asm):00067                         
E8EE 86E9             (    cmds_cart.asm):00068                         lda             #CMD_SET_RAM_CTRL               ; Set it.
E8F0 B7FF50           (    cmds_cart.asm):00069                         sta             D_CMD_REG                               
E8F3                  (    cmds_cart.asm):00070         CmdCartWait             
E8F3 B6FF53           (    cmds_cart.asm):00071                         lda             D_STATUS_REG                    ; Wait for command to exec
E8F6 2BFB             (    cmds_cart.asm):00072                         bmi             CmdCartWait
                      (    cmds_cart.asm):00073                                         
                      (    cmds_cart.asm):00074         ;               sta             D_RAM_CTRL                              ; set flags
E8F8 6E9FFFFE         (    cmds_cart.asm):00075                         jmp             [HWVecReset]                    ; Reset machine !
E8FC                  (    cmds_cart.asm):00076         CmdCartRAMCodeEnd:
                      (    cmds_cart.asm):00077         
     001E             (    cmds_cart.asm):00078         CmdCartRAMCodeLen       equ             CmdCartRAMCodeEnd-CmdCartRAMCode
                      (    cmds_cart.asm):00079         
E8FC                  (    cmds_cart.asm):00080         __cmd_cart_end
                      (    DragonMMC.asm):00668                         use             cmds_retok.asm
                      (   cmds_retok.asm):00001         ;
                      (   cmds_retok.asm):00002         ; Retokenize basic between Dragon and CoCo
                      (   cmds_retok.asm):00003         ;
                      (   cmds_retok.asm):00004         ; Majority of code borrowed from MultiCartBoot.
                      (   cmds_retok.asm):00005         ;
                      (   cmds_retok.asm):00006         
E8FC                  (   cmds_retok.asm):00007         __cmd_retok
                      (   cmds_retok.asm):00008         
                      (   cmds_retok.asm):00009                 use     tokens.asm
                      (       tokens.asm):00001         ;
                      (       tokens.asm):00002         ; Dragon BASIC tokens.
                      (       tokens.asm):00003         ; 
                      (       tokens.asm):00004         
     0080             (       tokens.asm):00005         DgnFOR          equ     $80     
     0081             (       tokens.asm):00006         DgnGO           equ     $81     
     0082             (       tokens.asm):00007         DgnREM          equ     $82     
     0083             (       tokens.asm):00008         DgnREM2         equ     $83     
     0084             (       tokens.asm):00009         DgnELSE         equ     $84     
     0085             (       tokens.asm):00010         DgnIF           equ     $85     
     0086             (       tokens.asm):00011         DgnDATA         equ     $86     
     0087             (       tokens.asm):00012         DgnPRINT        equ     $87     
     0088             (       tokens.asm):00013         DgnON           equ     $88     
     0089             (       tokens.asm):00014         DgnINPUT        equ     $89     
     008A             (       tokens.asm):00015         DgnEND          equ     $8a     
     008B             (       tokens.asm):00016         DgnNEXT         equ     $8b     
     008C             (       tokens.asm):00017         DgnDIM          equ     $8c     
     008D             (       tokens.asm):00018         DgnREAD         equ     $8d     
     008E             (       tokens.asm):00019         DgnLET          equ     $8e     
     008F             (       tokens.asm):00020         DgnRUN          equ     $8f     
     0090             (       tokens.asm):00021         DgnRESTORE      equ     $90     
     0091             (       tokens.asm):00022         DgnRETURN       equ     $91     
     0092             (       tokens.asm):00023         DgnSTOP         equ     $92     
     0093             (       tokens.asm):00024         DgnPOKE         equ     $93     
     0094             (       tokens.asm):00025         DgnCONT         equ     $94     
     0095             (       tokens.asm):00026         DgnLIST         equ     $95     
     0096             (       tokens.asm):00027         DgnCLEAR        equ     $96     
     0097             (       tokens.asm):00028         DgnNEW          equ     $97     
     0098             (       tokens.asm):00029         DgnDEF          equ     $98     
     0099             (       tokens.asm):00030         DgnCLOAD        equ     $99     
     009A             (       tokens.asm):00031         DgnCSAVE        equ     $9a     
     009B             (       tokens.asm):00032         DgnOPEN         equ     $9b     
     009C             (       tokens.asm):00033         DgnCLOSE        equ     $9c     
     009D             (       tokens.asm):00034         DgnLLIST        equ     $9d     
     009E             (       tokens.asm):00035         DgnSET          equ     $9e     
     009F             (       tokens.asm):00036         DgnRESET        equ     $9f     
     00A0             (       tokens.asm):00037         DgnCLS          equ     $a0     
     00A1             (       tokens.asm):00038         DgnMOTOR        equ     $a1     
     00A2             (       tokens.asm):00039         DgnSOUND        equ     $a2     
     00A3             (       tokens.asm):00040         DgnAUDIO        equ     $a3     
     00A4             (       tokens.asm):00041         DgnEXEC         equ     $a4     
     00A5             (       tokens.asm):00042         DgnSKIPF        equ     $a5     
     00A6             (       tokens.asm):00043         DgnDEL          equ     $a6     
     00A7             (       tokens.asm):00044         DgnEDIT         equ     $a7     
     00A8             (       tokens.asm):00045         DgnTRON         equ     $a8     
     00A9             (       tokens.asm):00046         DgnTROFF        equ     $a9     
     00AA             (       tokens.asm):00047         DgnLINE         equ     $aa     
     00AB             (       tokens.asm):00048         DgnPCLS         equ     $ab     
     00AC             (       tokens.asm):00049         DgnPSET         equ     $ac     
     00AD             (       tokens.asm):00050         DgnPRESET       equ     $ad     
     00AE             (       tokens.asm):00051         DgnSCREEN       equ     $ae     
     00AF             (       tokens.asm):00052         DgnPCLEAR       equ     $af     
     00B0             (       tokens.asm):00053         DgnCOLOR        equ     $b0     
     00B1             (       tokens.asm):00054         DgnCIRCLE       equ     $b1     
     00B2             (       tokens.asm):00055         DgnPAINT        equ     $b2     
     00B3             (       tokens.asm):00056         DgnGET          equ     $b3     
     00B4             (       tokens.asm):00057         DgnPUT          equ     $b4     
     00B5             (       tokens.asm):00058         DgnDRAW         equ     $b5     
     00B6             (       tokens.asm):00059         DgnPCOPY        equ     $b6     
     00B7             (       tokens.asm):00060         DgnPMODE        equ     $b7     
     00B8             (       tokens.asm):00061         DgnPLAY         equ     $b8     
     00B9             (       tokens.asm):00062         DgnDLOAD        equ     $b9     
     00BA             (       tokens.asm):00063         DgnRENUM        equ     $ba     
     00BB             (       tokens.asm):00064         DgnTAB          equ     $bb     
     00BC             (       tokens.asm):00065         DgnTO           equ     $bc     
     00BD             (       tokens.asm):00066         DgnSUB          equ     $bd     
     00BE             (       tokens.asm):00067         DgnFN           equ     $be     
     00BF             (       tokens.asm):00068         DgnTHEN         equ     $bf     
     00C0             (       tokens.asm):00069         DgnNOT          equ     $c0     
     00C1             (       tokens.asm):00070         DgnSTEP         equ     $c1     
     00C2             (       tokens.asm):00071         DgnOFF          equ     $c2     
     00C3             (       tokens.asm):00072         DgnPlus         equ     $c3     
     00C4             (       tokens.asm):00073         DgnMinus        equ     $c4     
     00C5             (       tokens.asm):00074         DgnTimes        equ     $c5     
     00C6             (       tokens.asm):00075         DgnDivide       equ     $c6     
     00C7             (       tokens.asm):00076         DgnPower        equ     $c7     
     00C8             (       tokens.asm):00077         DgnAND          equ     $c8     
     00C9             (       tokens.asm):00078         DgnOR           equ     $c9     
     00CA             (       tokens.asm):00079         DgnGt           equ     $ca     
     00CB             (       tokens.asm):00080         DgnEq           equ     $cb     
     00CC             (       tokens.asm):00081         DgnLt           equ     $cc     
     00CD             (       tokens.asm):00082         DgnUSING        equ     $cd     
                      (       tokens.asm):00083         
                      (       tokens.asm):00084         ; DragonDOS command tokens
     00CE             (       tokens.asm):00085         DgnAUTO         equ     $ce     
     00CF             (       tokens.asm):00086         DgnBACKUP       equ     $cf     
     00D0             (       tokens.asm):00087         DgnBEEP         equ     $d0     
     00D1             (       tokens.asm):00088         DgnBOOT         equ     $d1     
     00D2             (       tokens.asm):00089         DgnCHAIN        equ     $d2     
     00D3             (       tokens.asm):00090         DgnCOPY         equ     $d3     
     00D4             (       tokens.asm):00091         DgnCREATE       equ     $d4     
     00D5             (       tokens.asm):00092         DgnDIR          equ     $d5     
     00D6             (       tokens.asm):00093         DgnDRIVE        equ     $d6     
     00D7             (       tokens.asm):00094         DgnDSKINIT      equ     $d7     
     00D8             (       tokens.asm):00095         DgnFREAD        equ     $d8     
     00D9             (       tokens.asm):00096         DgnFWRITE       equ     $d9     
     00DA             (       tokens.asm):00097         DgnERROR        equ     $da     
     00DB             (       tokens.asm):00098         DgnKILL         equ     $db     
     00DC             (       tokens.asm):00099         DgnLOAD         equ     $dc     
     00DD             (       tokens.asm):00100         DgnMERGE        equ     $dd     
     00DE             (       tokens.asm):00101         DgnPROTECT      equ     $de     
     00DF             (       tokens.asm):00102         DgnWAIT         equ     $df     
     00E0             (       tokens.asm):00103         DgnRENAME       equ     $e0     
     00E1             (       tokens.asm):00104         DgnSAVE         equ     $e1     
     00E2             (       tokens.asm):00105         DgnSREAD        equ     $e2     
     00E3             (       tokens.asm):00106         DgnSWRITE       equ     $e3     
     00E4             (       tokens.asm):00107         DgnVERIFY       equ     $e4     
     00E5             (       tokens.asm):00108         DgnFROM         equ     $e5     
     00E6             (       tokens.asm):00109         DgnFLREAD       equ     $e6     
     00E7             (       tokens.asm):00110         DgnSWAP         equ     $e7     
                      (       tokens.asm):00111         
                      (       tokens.asm):00112         ; Dragon DragonMMC Command tokens
                      (       tokens.asm):00113         
     00E8             (       tokens.asm):00114         DgnMCAS         equ     $e8
     00E9             (       tokens.asm):00115         DgnMMIRROR      equ     $e9
     00EA             (       tokens.asm):00116         DgnMMOUNT       equ     $ea
     00EB             (       tokens.asm):00117         DgnHELP         equ     $eb
     00EC             (       tokens.asm):00118         DgnRAMBOOT      equ     $ec
     00ED             (       tokens.asm):00119         DgnCAT          equ     $ed
     00EE             (       tokens.asm):00120         DgnMDELETE      equ     $ee
     00EF             (       tokens.asm):00121         DgnMSAVE        equ     $ef
     00F0             (       tokens.asm):00122         DgnMLOAD        equ     $f0
     00F1             (       tokens.asm):00123         DgnMCARTLOAD    equ     $f1
     00F2             (       tokens.asm):00124         DgnMTAPERUN     equ     $f2
     00F3             (       tokens.asm):00125         DgnCWD          equ     $f3
     00F4             (       tokens.asm):00126         DgnMSETCFG      equ     $f4
     00F5             (       tokens.asm):00127         DgnRETOK        equ     $f5
     00F6             (       tokens.asm):00128         DgnMDISK        equ     $f6
     00F7             (       tokens.asm):00129         DgnREWIND       equ     $f7
     00F8             (       tokens.asm):00130         DgnMSETDT       equ     $f8
     00F9             (       tokens.asm):00131         DgnMKDIR        equ     $f9
                      (       tokens.asm):00132                         
                      (       tokens.asm):00133         ;Dragon BASIC Function tokens - all proceeded by equ    $ff to differentiate from operators
     0080             (       tokens.asm):00134         DgnSGN          equ     $80     
     0081             (       tokens.asm):00135         DgnINT          equ     $81     
     0082             (       tokens.asm):00136         DgnABS          equ     $82     
     0083             (       tokens.asm):00137         DgnPOS          equ     $83     
     0084             (       tokens.asm):00138         DgnRND          equ     $84     
     0085             (       tokens.asm):00139         DgnSQR          equ     $85     
     0086             (       tokens.asm):00140         DgnLOG          equ     $86     
     0087             (       tokens.asm):00141         DgnEXP          equ     $87     
     0088             (       tokens.asm):00142         DgnSIN          equ     $88     
     0089             (       tokens.asm):00143         DgnCOS          equ     $89     
     008A             (       tokens.asm):00144         DgnTAN          equ     $8a     
     008B             (       tokens.asm):00145         DgnATN          equ     $8b     
     008C             (       tokens.asm):00146         DgnPEEK         equ     $8c     
     008D             (       tokens.asm):00147         DgnLEN          equ     $8d     
     008E             (       tokens.asm):00148         DgnSTRS         equ     $8e     
     008F             (       tokens.asm):00149         DgnVAL          equ     $8f     
     0090             (       tokens.asm):00150         DgnASC          equ     $90     
     0091             (       tokens.asm):00151         DgnCHRS         equ     $91     
     0092             (       tokens.asm):00152         DgnEOF          equ     $92     
     0093             (       tokens.asm):00153         DgnJOYSTK       equ     $93     
     0094             (       tokens.asm):00154         DgnFIX          equ     $94     
     0095             (       tokens.asm):00155         DgnHEXS         equ     $95     
     0096             (       tokens.asm):00156         DgnLEFTS        equ     $96     
     0097             (       tokens.asm):00157         DgnRIGHTS       equ     $97     
     0098             (       tokens.asm):00158         DgnMIDS         equ     $98     
     0099             (       tokens.asm):00159         DgnPOINT        equ     $99     
     009A             (       tokens.asm):00160         DgnINKEYS       equ     $9a     
     009B             (       tokens.asm):00161         DgnMEM          equ     $9b     
     009C             (       tokens.asm):00162         DgnVARPTR       equ     $9c     
     009D             (       tokens.asm):00163         DgnINSTR        equ     $9d     
     009E             (       tokens.asm):00164         DgnTIMER        equ     $9e     
     009F             (       tokens.asm):00165         DgnPPOINT       equ     $9f     
     00A0             (       tokens.asm):00166         DgnSTRINGS      equ     $a0     
     00A1             (       tokens.asm):00167         DgnUSR          equ     $a1     
                      (       tokens.asm):00168         
                      (       tokens.asm):00169         ; DragonDOS function tokens
     00A2             (       tokens.asm):00170         DgnLOF          equ     $a2     
     00A3             (       tokens.asm):00171         DgnFREE         equ     $a3     
     00A4             (       tokens.asm):00172         DgnERL          equ     $a4     
     00A5             (       tokens.asm):00173         DgnERR          equ     $a5     
     00A6             (       tokens.asm):00174         DgnHIMEM        equ     $a6     
     00A7             (       tokens.asm):00175         DgnLOC          equ     $a7     
     00A8             (       tokens.asm):00176         DgnFRES         equ     $a8     
                      (       tokens.asm):00177         
                      (       tokens.asm):00178         ;Dragon DragonMMC function tokens
                      (       tokens.asm):00179         
     00A9             (       tokens.asm):00180         DgnVER          equ     $a9
     00AA             (       tokens.asm):00181         DgnWDS          equ     $aa
     00AB             (       tokens.asm):00182         DgnFINDFIRSTS   equ     $ab
     00AC             (       tokens.asm):00183         DgnFINDNEXTS    equ     $ac
     00AD             (       tokens.asm):00184         DgnCFTYPE       equ     $ad
     00AE             (       tokens.asm):00185         DgnMGETCFG      equ     $ae
     00AF             (       tokens.asm):00186         DgnMGETDTS      equ     $af
     00B0             (       tokens.asm):00187         DgnMGETINAMES   equ     $b0
     00B1             (       tokens.asm):00188         DgnSDS          equ     $b1
                      (       tokens.asm):00189         
                      (       tokens.asm):00190         ; CoCo BASIC command tokens
                      (       tokens.asm):00191         
     0080             (       tokens.asm):00192         CoFOR           equ     $80
     0081             (       tokens.asm):00193         CoGO            equ     $81
     0082             (       tokens.asm):00194         CoREM           equ     $82
     0083             (       tokens.asm):00195         CoREM2          equ     $83
     0084             (       tokens.asm):00196         CoELSE          equ     $84
     0085             (       tokens.asm):00197         CoIF            equ     $85
     0086             (       tokens.asm):00198         CoDATA          equ     $86
     0087             (       tokens.asm):00199         CoPRINT         equ     $87
     0088             (       tokens.asm):00200         CoON            equ     $88
     0089             (       tokens.asm):00201         CoINPUT         equ     $89
     008A             (       tokens.asm):00202         CoEND           equ     $8a
     008B             (       tokens.asm):00203         CoNEXT          equ     $8b
     008C             (       tokens.asm):00204         CoDIM           equ     $8c
     008D             (       tokens.asm):00205         CoREAD          equ     $8d
     008E             (       tokens.asm):00206         CoRUN           equ     $8e
     008F             (       tokens.asm):00207         CoRESTORE       equ     $8f
     0090             (       tokens.asm):00208         CoRETURN        equ     $90
     0091             (       tokens.asm):00209         CoSTOP          equ     $91
     0092             (       tokens.asm):00210         CoPOKE          equ     $92
     0093             (       tokens.asm):00211         CoCONT          equ     $93
     0094             (       tokens.asm):00212         CoLIST          equ     $94
     0095             (       tokens.asm):00213         CoCLEAR         equ     $95
     0096             (       tokens.asm):00214         CoNEW           equ     $96
     0097             (       tokens.asm):00215         CoCLOAD         equ     $97
     0098             (       tokens.asm):00216         CoCSAVE         equ     $98
     0099             (       tokens.asm):00217         CoOPEN          equ     $99
     009A             (       tokens.asm):00218         CoCLOSE         equ     $9a
     009B             (       tokens.asm):00219         CoLLIST         equ     $9b
     009C             (       tokens.asm):00220         CoSET           equ     $9c
     009D             (       tokens.asm):00221         CoRESET         equ     $9d
     009E             (       tokens.asm):00222         CoCLS           equ     $9e
     009F             (       tokens.asm):00223         CoMOTOR         equ     $9f
     00A0             (       tokens.asm):00224         CoSOUND         equ     $a0
     00A1             (       tokens.asm):00225         CoAUDIO         equ     $a1
     00A2             (       tokens.asm):00226         CoEXEC          equ     $a2
     00A3             (       tokens.asm):00227         CoSKIPF         equ     $a3
     00A4             (       tokens.asm):00228         CoTAB           equ     $a4
     00A5             (       tokens.asm):00229         CoTO            equ     $a5
     00A6             (       tokens.asm):00230         CoSUB           equ     $a6
     00A7             (       tokens.asm):00231         CoTHEN          equ     $a7
     00A8             (       tokens.asm):00232         CoNOT           equ     $a8
     00A9             (       tokens.asm):00233         CoSTEP          equ     $a9
     00AA             (       tokens.asm):00234         CoOFF           equ     $aa
     00AB             (       tokens.asm):00235         CoPlus          equ     $ab
     00AC             (       tokens.asm):00236         CoMinus         equ     $ac
     00AD             (       tokens.asm):00237         CoTimes         equ     $ad
     00AE             (       tokens.asm):00238         CoDivide        equ     $ae
     00AF             (       tokens.asm):00239         CoPower         equ     $af
     00B0             (       tokens.asm):00240         CoAND           equ     $b0
     00B1             (       tokens.asm):00241         CoOR            equ     $b1
     00B2             (       tokens.asm):00242         CoGt            equ     $b2
     00B3             (       tokens.asm):00243         CoEq            equ     $b3
     00B4             (       tokens.asm):00244         CoLt            equ     $b4
     00B5             (       tokens.asm):00245         CoDEL           equ     $b5
     00B6             (       tokens.asm):00246         CoEDIT          equ     $b6
     00B7             (       tokens.asm):00247         CoTRON          equ     $b7
     00B8             (       tokens.asm):00248         CoTROFF         equ     $b8
     00B9             (       tokens.asm):00249         CoDEF           equ     $b9
     00BA             (       tokens.asm):00250         CoLET           equ     $ba
     00BB             (       tokens.asm):00251         CoLINE          equ     $bb
     00BC             (       tokens.asm):00252         CoPCLS          equ     $bc
     00BD             (       tokens.asm):00253         CoPSET          equ     $bd
     00BE             (       tokens.asm):00254         CoPRESET        equ     $be
     00BF             (       tokens.asm):00255         CoSCREEN        equ     $bf
     00C0             (       tokens.asm):00256         CoPCLEAR        equ     $c0
     00C1             (       tokens.asm):00257         CoCOLOR         equ     $c1
     00C2             (       tokens.asm):00258         CoCIRCLE        equ     $c2
     00C3             (       tokens.asm):00259         CoPAINT         equ     $c3
     00C4             (       tokens.asm):00260         CoGET           equ     $c4
     00C5             (       tokens.asm):00261         CoPUT           equ     $c5
     00C6             (       tokens.asm):00262         CoDRAW          equ     $c6
     00C7             (       tokens.asm):00263         CoPCOPY         equ     $c7
     00C8             (       tokens.asm):00264         CoPMODE         equ     $c8
     00C9             (       tokens.asm):00265         CoPLAY          equ     $c9
     00CA             (       tokens.asm):00266         CoDLOAD         equ     $ca
     00CB             (       tokens.asm):00267         CoRENUM         equ     $cb
     00CC             (       tokens.asm):00268         CoFN            equ     $cc
     00CD             (       tokens.asm):00269         CoUSING         equ     $cd
                      (       tokens.asm):00270         
                      (       tokens.asm):00271         ; RSDOS adds these .. (from Dragon User 12/84)
     00CE             (       tokens.asm):00272         CoDIR           equ     $ce
     00CF             (       tokens.asm):00273         CoDRIVE         equ     $cf
     00D0             (       tokens.asm):00274         CoFIELD         equ     $d0
     00D1             (       tokens.asm):00275         CoFILES         equ     $d1
     00D2             (       tokens.asm):00276         CoKILL          equ     $d2
     00D3             (       tokens.asm):00277         CoLOAD          equ     $d3
     00D4             (       tokens.asm):00278         CoLSET          equ     $d4
     00D5             (       tokens.asm):00279         CoMERGE         equ     $d5
     00D6             (       tokens.asm):00280         CoRENAME        equ     $d6
     00D7             (       tokens.asm):00281         CoRSET          equ     $d7
     00D8             (       tokens.asm):00282         CoSAVE          equ     $d8
     00D9             (       tokens.asm):00283         CoWRITE         equ     $d9
     00DA             (       tokens.asm):00284         CoVERIFY        equ     $da
     00DB             (       tokens.asm):00285         CoUNLOAD        equ     $db
     00DC             (       tokens.asm):00286         CoDSKINI        equ     $dc
     00DD             (       tokens.asm):00287         CoBACKUP        equ     $dd
     00DE             (       tokens.asm):00288         CoCOPY          equ     $de
     00DF             (       tokens.asm):00289         CoDSKIS         equ     $df
     00E0             (       tokens.asm):00290         CoDSKOS         equ     $e0
     00E1             (       tokens.asm):00291         CoDOS       equ $e1
                      (       tokens.asm):00292         
                      (       tokens.asm):00293         ; Dragon DragonMMC Command tokens
                      (       tokens.asm):00294         
     00E2             (       tokens.asm):00295         CoMCAS          equ     $e2
     00E3             (       tokens.asm):00296         CoMMIRROR       equ     $e3
     00E4             (       tokens.asm):00297         CoMMOUNT        equ     $e4
     00E5             (       tokens.asm):00298         CoHELP          equ     $e5
     00E6             (       tokens.asm):00299         CoRAMBOOT       equ     $e6
     00E7             (       tokens.asm):00300         CoCAT           equ     $e7
     00E8             (       tokens.asm):00301         CoMDELETE       equ     $e8
     00E9             (       tokens.asm):00302         CoMSAVE         equ     $e9
     00EA             (       tokens.asm):00303         CoMLOAD         equ     $ea
     00EB             (       tokens.asm):00304         CoMCARTLOAD     equ     $eb
     00EC             (       tokens.asm):00305         CoMTAPERUN      equ     $ec
     00ED             (       tokens.asm):00306         CoCWD           equ     $ed
     00EE             (       tokens.asm):00307         CoMSETCFG       equ     $ee
     00EF             (       tokens.asm):00308         CoRETOK         equ     $ef
     00F0             (       tokens.asm):00309         CoMDISK         equ     $f0
     00F1             (       tokens.asm):00310         CoREWIND        equ     $f1
     00F2             (       tokens.asm):00311         CoMSETDT        equ     $f2
     00F3             (       tokens.asm):00312         CoMKDIR         equ     $f3
                      (       tokens.asm):00313         
                      (       tokens.asm):00314         
                      (       tokens.asm):00315         ;Function tokens - all proceeded by $ff to differentiate from operators
                      (       tokens.asm):00316         ;Token  Keyword
     0080             (       tokens.asm):00317         CoSGN           equ     $80
     0081             (       tokens.asm):00318         CoINT           equ     $81
     0082             (       tokens.asm):00319         CoABS           equ     $82
     0083             (       tokens.asm):00320         CoUSR           equ     $83
     0084             (       tokens.asm):00321         CoRND           equ     $84
     0085             (       tokens.asm):00322         CoSIN           equ     $85
     0086             (       tokens.asm):00323         CoPEEK          equ     $86
     0087             (       tokens.asm):00324         CoLEN           equ     $87
     0088             (       tokens.asm):00325         CoSTRS          equ     $88
     0089             (       tokens.asm):00326         CoVAL           equ     $89
     008A             (       tokens.asm):00327         CoASC           equ     $8a
     008B             (       tokens.asm):00328         CoCHRS          equ     $8b
     008C             (       tokens.asm):00329         CoEOF           equ     $8c
     008D             (       tokens.asm):00330         CoJOYSTK        equ     $8d
     008E             (       tokens.asm):00331         CoLEFTS         equ     $8e
     008F             (       tokens.asm):00332         CoRIGHTS        equ     $8f
     0090             (       tokens.asm):00333         CoMIDS          equ     $90
     0091             (       tokens.asm):00334         CoPOINT         equ     $91
     0092             (       tokens.asm):00335         CoINKEYS        equ     $92
     0093             (       tokens.asm):00336         CoMEM           equ     $93
     0094             (       tokens.asm):00337         CoATN           equ     $94
     0095             (       tokens.asm):00338         CoCOS           equ     $95
     0096             (       tokens.asm):00339         CoTAN           equ     $96
     0097             (       tokens.asm):00340         CoEXP           equ     $97
     0098             (       tokens.asm):00341         CoFIX           equ     $98
     0099             (       tokens.asm):00342         CoLOG           equ     $99
     009A             (       tokens.asm):00343         CoPOS           equ     $9a
     009B             (       tokens.asm):00344         CoSQR           equ     $9b
     009C             (       tokens.asm):00345         CoHEXS          equ     $9c
     009D             (       tokens.asm):00346         CoVARPTR        equ     $9d
     009E             (       tokens.asm):00347         CoINSTR         equ     $9e
     009F             (       tokens.asm):00348         CoTIMER         equ     $9f
     00A0             (       tokens.asm):00349         CoPPOINT        equ     $a0
     00A1             (       tokens.asm):00350         CoSTRINGS       equ     $a1
                      (       tokens.asm):00351         
                      (       tokens.asm):00352         ; RSDOS adds these .. (from Dragon User 12/84)
     00A2             (       tokens.asm):00353         CoCVN           equ     $a2
     00A3             (       tokens.asm):00354         CoFREE          equ     $a3
     00A4             (       tokens.asm):00355         CoLOC           equ     $a4
     00A5             (       tokens.asm):00356         CoLOF           equ     $a5
     00A6             (       tokens.asm):00357         CoMKNS          equ     $a6
     00A7             (       tokens.asm):00358         CoAS            equ     $a7
                      (       tokens.asm):00359         
                      (       tokens.asm):00360         ; CoCo DragonMMC function tokens
                      (       tokens.asm):00361         
     00A8             (       tokens.asm):00362         CoVER           equ     $a8
     00A9             (       tokens.asm):00363         CoWDS           equ     $a9
     00AA             (       tokens.asm):00364         CoFINDFIRSTS    equ     $aa
     00AB             (       tokens.asm):00365         CoFINDNEXTS     equ     $ab
     00AC             (       tokens.asm):00366         CoCFTYPE        equ     $ac
     00AD             (       tokens.asm):00367         CoMGETCFG       equ     $ad
     00AE             (       tokens.asm):00368         CoMGETDTS       equ     $ae
     00AF             (       tokens.asm):00369         CoMGETINAMES    equ     $af
     00B0             (       tokens.asm):00370         CoSDS           equ     $b0
                      (   cmds_retok.asm):00010         
E8FC                  (   cmds_retok.asm):00011         CmdReTok:
E8FC 1F89             (   cmds_retok.asm):00012                         tfr             a,b                                     ; save next char
E8FE 9D9F             (   cmds_retok.asm):00013                         jsr             <BasChrGet                      ; skip the D or C
                      (   cmds_retok.asm):00014                         
E900 C144             (   cmds_retok.asm):00015                         cmpb    #'D                                     ; RetokD CoCo->Dragon ?
E902 2706             (   cmds_retok.asm):00016                         beq             CmdRetokToDragon        ; yep, do it
E904 C143             (   cmds_retok.asm):00017                         cmpb    #'C                                     ; RetokC Dragon->CoCo ?
E906 2708             (   cmds_retok.asm):00018                         beq             CmdRetokToCoCo          ; yep, do it
E908 4F               (   cmds_retok.asm):00019                         clra                                            ; no error
E909 39               (   cmds_retok.asm):00020                         rts
                      (   cmds_retok.asm):00021         
                      (   cmds_retok.asm):00022         ; retokenize CoCo to Dragon.
E90A                  (   cmds_retok.asm):00023         CmdRetokToDragon:
E90A 308D004C         (   cmds_retok.asm):00024                         leax    TokCoCoToDragon,pcr     ; point at token tables
E90E 2006             (   cmds_retok.asm):00025                         bra             DoRetok                         ; Retokenize
                      (   cmds_retok.asm):00026         
                      (   cmds_retok.asm):00027         ; retokenize Dragon to CoCo.
E910                  (   cmds_retok.asm):00028         CmdRetokToCoCo:
E910 308D0040         (   cmds_retok.asm):00029                         leax    TokDragonToCoCo,pcr     ; point at token tables
E914 2000             (   cmds_retok.asm):00030                         bra             DoRetok                         ; Retokenize
                      (   cmds_retok.asm):00031         
E916                  (   cmds_retok.asm):00032         DoRetok
E916 3410             (   cmds_retok.asm):00033                         pshs    x
E918 DE19             (   cmds_retok.asm):00034                         ldu             BasStartProg            ; Get start of basic 
                      (   cmds_retok.asm):00035                 
E91A                  (   cmds_retok.asm):00036         DoRetokNewLine
E91A 3344             (   cmds_retok.asm):00037                         leau    4,u                                     ; skip link & lineno
E91C                  (   cmds_retok.asm):00038         RetokLoop
E91C A6C4             (   cmds_retok.asm):00039                         lda             ,u                                      ; get a byte
                      (   cmds_retok.asm):00040                 
E91E 4D               (   cmds_retok.asm):00041                         tsta                                            ; Test a and set flags
E91F 272A             (   cmds_retok.asm):00042                         beq             DoRetokEol                      ; end of line, check for end of code
                      (   cmds_retok.asm):00043                 
E921 2B04             (   cmds_retok.asm):00044                         bmi             LookupToken                     ; Token, yes process it
                      (   cmds_retok.asm):00045         
E923                  (   cmds_retok.asm):00046         RetokNextByte
E923 3341             (   cmds_retok.asm):00047                         leau    1,u                                     ; increment pointer
E925 20F5             (   cmds_retok.asm):00048                         bra             RetokLoop                       ; do next
                      (   cmds_retok.asm):00049                 
E927                  (   cmds_retok.asm):00050         LookupToken
E927 81FF             (   cmds_retok.asm):00051                         cmpa    #$FF                            ; Check extended token flag
E929 27F8             (   cmds_retok.asm):00052                         beq             RetokNextByte           ; yes : do next
                      (   cmds_retok.asm):00053                 
E92B 847F             (   cmds_retok.asm):00054                         anda    #$7f                            ; Make token zero based
                      (   cmds_retok.asm):00055         
E92D AEE4             (   cmds_retok.asm):00056                 ldx             ,s                                      ; Pointer to pointer table
                      (   cmds_retok.asm):00057         
E92F E65F             (   cmds_retok.asm):00058                         ldb             -1,u                            ; Get previous byte
E931 C1FF             (   cmds_retok.asm):00059                         cmpb    #$FF                            ; Extended token flag ?
E933 2708             (   cmds_retok.asm):00060                         beq             DoExtended                      ; Yes do it
                      (   cmds_retok.asm):00061            
E935 A102             (   cmds_retok.asm):00062                         cmpa    2,x                 ; Token not one of ours?
E937 24EA             (   cmds_retok.asm):00063                         bhs             RetokNextByte           ; if so ignore it
                      (   cmds_retok.asm):00064                 
E939 AE84             (   cmds_retok.asm):00065                         ldx             ,x                                      ; get normal function pointer
E93B 2008             (   cmds_retok.asm):00066                         bra             DoTranslate                     ; skip
                      (   cmds_retok.asm):00067         
E93D                  (   cmds_retok.asm):00068         DoExtended
E93D 3003             (   cmds_retok.asm):00069                         leax    3,x                                     ; Point at extended token table
E93F A102             (   cmds_retok.asm):00070                         cmpa    2,x                 ; Token not one of ours?
E941 24E0             (   cmds_retok.asm):00071                         bhs             RetokNextByte           ; if so ignore it
E943 AE84             (   cmds_retok.asm):00072                 ldx     ,x                  ; Get function pointer 
                      (   cmds_retok.asm):00073                 
E945                  (   cmds_retok.asm):00074         DoTranslate
E945 E686             (   cmds_retok.asm):00075                         ldb             a,x                                     ; get new token
E947 E7C4             (   cmds_retok.asm):00076                         stb             ,u                                      ; replace it
E949 20D8             (   cmds_retok.asm):00077                         bra             RetokNextByte           ; do next
                      (   cmds_retok.asm):00078                 
E94B                  (   cmds_retok.asm):00079         DoRetokEol
E94B 3341             (   cmds_retok.asm):00080                         leau    1,u                                     ; increment pointer
E94D 6DC4             (   cmds_retok.asm):00081                         tst             ,u                                      ; check for a second zero, marking end of program
E94F 26C9             (   cmds_retok.asm):00082                         bne             DoRetokNewLine          ; no : do next line
E951 4F               (   cmds_retok.asm):00083                         clra                                            ; no error
E952 3590             (   cmds_retok.asm):00084                         puls    x,pc
                      (   cmds_retok.asm):00085         
                      (   cmds_retok.asm):00086         
                      (   cmds_retok.asm):00087         ;***********************************************
                      (   cmds_retok.asm):00088         ; Token translation tables for basic programs. *
                      (   cmds_retok.asm):00089         ;***********************************************
                      (   cmds_retok.asm):00090         
E954                  (   cmds_retok.asm):00091         TokDragonToCoCo
E954 E960             (   cmds_retok.asm):00092                 FDB     DragonCoCoCmd
E956 7A               (   cmds_retok.asm):00093             FCB NoCommandsDgn
E957 E9DA             (   cmds_retok.asm):00094                 FDB     DragonCoCoFunc
E959 32               (   cmds_retok.asm):00095             FCB NoFuncsDgn
                      (   cmds_retok.asm):00096                 
E95A                  (   cmds_retok.asm):00097         TokCoCoToDragon
E95A EA0C             (   cmds_retok.asm):00098                 FDB     CoCoDragonCmd
E95C 74               (   cmds_retok.asm):00099                 FCB NoCommandsCoCo
E95D EA80             (   cmds_retok.asm):00100                 FDB     CoCoDragonFunc
E95F 31               (   cmds_retok.asm):00101             FCB NoFuncsCoCo
                      (   cmds_retok.asm):00102         
                      (   cmds_retok.asm):00103         ;*****************
                      (   cmds_retok.asm):00104         ; Dragon to CoCo *
                      (   cmds_retok.asm):00105         ;*****************
                      (   cmds_retok.asm):00106         
E960                  (   cmds_retok.asm):00107         DragonCoCoCmd
E960 80               (   cmds_retok.asm):00108                 FCB     CoFOR
E961 81               (   cmds_retok.asm):00109                 FCB     CoGO
E962 82               (   cmds_retok.asm):00110                 FCB     CoREM
E963 83               (   cmds_retok.asm):00111                 FCB     CoREM2
E964 84               (   cmds_retok.asm):00112                 FCB     CoELSE
E965 85               (   cmds_retok.asm):00113                 FCB     CoIF
E966 86               (   cmds_retok.asm):00114                 FCB     CoDATA
E967 87               (   cmds_retok.asm):00115                 FCB     CoPRINT
E968 88               (   cmds_retok.asm):00116                 FCB     CoON
E969 89               (   cmds_retok.asm):00117                 FCB     CoINPUT
E96A 8A               (   cmds_retok.asm):00118                 FCB     CoEND
E96B 8B               (   cmds_retok.asm):00119                 FCB     CoNEXT
E96C 8C               (   cmds_retok.asm):00120                 FCB     CoDIM
E96D 8D               (   cmds_retok.asm):00121                 FCB     CoREAD
E96E BA               (   cmds_retok.asm):00122                 FCB     CoLET
E96F 8E               (   cmds_retok.asm):00123                 FCB     CoRUN
E970 8F               (   cmds_retok.asm):00124                 FCB     CoRESTORE
E971 90               (   cmds_retok.asm):00125                 FCB     CoRETURN
E972 91               (   cmds_retok.asm):00126                 FCB     CoSTOP
E973 92               (   cmds_retok.asm):00127                 FCB     CoPOKE
E974 93               (   cmds_retok.asm):00128                 FCB     CoCONT
E975 94               (   cmds_retok.asm):00129                 FCB     CoLIST
E976 95               (   cmds_retok.asm):00130                 FCB     CoCLEAR
E977 96               (   cmds_retok.asm):00131                 FCB     CoNEW
E978 B9               (   cmds_retok.asm):00132                 FCB     CoDEF
E979 97               (   cmds_retok.asm):00133                 FCB     CoCLOAD
E97A 98               (   cmds_retok.asm):00134                 FCB     CoCSAVE
E97B 99               (   cmds_retok.asm):00135                 FCB     CoOPEN
E97C 9A               (   cmds_retok.asm):00136                 FCB     CoCLOSE
E97D 9B               (   cmds_retok.asm):00137                 FCB     CoLLIST
E97E 9C               (   cmds_retok.asm):00138                 FCB     CoSET
E97F 9D               (   cmds_retok.asm):00139                 FCB     CoRESET
E980 9E               (   cmds_retok.asm):00140                 FCB     CoCLS
E981 9F               (   cmds_retok.asm):00141                 FCB     CoMOTOR
E982 A0               (   cmds_retok.asm):00142                 FCB     CoSOUND
E983 A1               (   cmds_retok.asm):00143                 FCB     CoAUDIO
E984 A2               (   cmds_retok.asm):00144                 FCB     CoEXEC
E985 A3               (   cmds_retok.asm):00145                 FCB     CoSKIPF
E986 B5               (   cmds_retok.asm):00146                 FCB     CoDEL
E987 B6               (   cmds_retok.asm):00147                 FCB     CoEDIT
E988 B7               (   cmds_retok.asm):00148                 FCB     CoTRON
E989 B8               (   cmds_retok.asm):00149                 FCB     CoTROFF
E98A BB               (   cmds_retok.asm):00150                 FCB     CoLINE
E98B BC               (   cmds_retok.asm):00151                 FCB     CoPCLS
E98C BD               (   cmds_retok.asm):00152                 FCB     CoPSET
E98D BE               (   cmds_retok.asm):00153                 FCB     CoPRESET
E98E BF               (   cmds_retok.asm):00154                 FCB     CoSCREEN
E98F C0               (   cmds_retok.asm):00155                 FCB     CoPCLEAR
E990 C1               (   cmds_retok.asm):00156                 FCB     CoCOLOR
E991 C2               (   cmds_retok.asm):00157                 FCB     CoCIRCLE
E992 C3               (   cmds_retok.asm):00158                 FCB     CoPAINT
E993 C4               (   cmds_retok.asm):00159                 FCB     CoGET
E994 C5               (   cmds_retok.asm):00160                 FCB     CoPUT
E995 C6               (   cmds_retok.asm):00161                 FCB     CoDRAW
E996 C7               (   cmds_retok.asm):00162                 FCB     CoPCOPY
E997 C8               (   cmds_retok.asm):00163                 FCB     CoPMODE
E998 C9               (   cmds_retok.asm):00164                 FCB     CoPLAY
E999 CA               (   cmds_retok.asm):00165                 FCB     CoDLOAD
E99A CB               (   cmds_retok.asm):00166                 FCB     CoRENUM
E99B A4               (   cmds_retok.asm):00167                 FCB     CoTAB
E99C A5               (   cmds_retok.asm):00168                 FCB     CoTO
E99D A6               (   cmds_retok.asm):00169                 FCB     CoSUB
E99E CC               (   cmds_retok.asm):00170                 FCB     CoFN
E99F A7               (   cmds_retok.asm):00171                 FCB     CoTHEN
E9A0 A8               (   cmds_retok.asm):00172                 FCB     CoNOT
E9A1 A9               (   cmds_retok.asm):00173                 FCB     CoSTEP
E9A2 AA               (   cmds_retok.asm):00174                 FCB     CoOFF
E9A3 AB               (   cmds_retok.asm):00175                 FCB     CoPlus
E9A4 AC               (   cmds_retok.asm):00176                 FCB     CoMinus
E9A5 AD               (   cmds_retok.asm):00177                 FCB     CoTimes
E9A6 AE               (   cmds_retok.asm):00178                 FCB     CoDivide
E9A7 AF               (   cmds_retok.asm):00179                 FCB     CoPower
E9A8 B0               (   cmds_retok.asm):00180                 FCB     CoAND
E9A9 B1               (   cmds_retok.asm):00181                 FCB     CoOR
E9AA B2               (   cmds_retok.asm):00182                 FCB     CoGt
E9AB B3               (   cmds_retok.asm):00183                 FCB     CoEq
E9AC B4               (   cmds_retok.asm):00184                 FCB     CoLt
E9AD CD               (   cmds_retok.asm):00185                 FCB     CoUSING
                      (   cmds_retok.asm):00186         
                      (   cmds_retok.asm):00187         ; DOS
                      (   cmds_retok.asm):00188                 
E9AE 82               (   cmds_retok.asm):00189                 FCB     CoREM
E9AF DD               (   cmds_retok.asm):00190                 FCB     CoBACKUP
E9B0 82               (   cmds_retok.asm):00191                 FCB     CoREM
E9B1 E1               (   cmds_retok.asm):00192                 FCB     CoDOS
E9B2 82               (   cmds_retok.asm):00193                 FCB     CoREM
E9B3 DE               (   cmds_retok.asm):00194                 FCB     CoCOPY
E9B4 82               (   cmds_retok.asm):00195                 FCB     CoREM
E9B5 CE               (   cmds_retok.asm):00196                 FCB     CoDIR
E9B6 CF               (   cmds_retok.asm):00197                 FCB     CoDRIVE
E9B7 DC               (   cmds_retok.asm):00198                 FCB     CoDSKINI
E9B8 82               (   cmds_retok.asm):00199                 FCB     CoREM
E9B9 82               (   cmds_retok.asm):00200                 FCB     CoREM
E9BA 82               (   cmds_retok.asm):00201                 FCB     CoREM
E9BB D2               (   cmds_retok.asm):00202                 FCB     CoKILL
E9BC D3               (   cmds_retok.asm):00203                 FCB     CoLOAD
E9BD D5               (   cmds_retok.asm):00204                 FCB     CoMERGE
E9BE 82               (   cmds_retok.asm):00205                 FCB     CoREM
E9BF 82               (   cmds_retok.asm):00206                 FCB     CoREM
E9C0 D6               (   cmds_retok.asm):00207                 FCB     CoRENAME
E9C1 D8               (   cmds_retok.asm):00208                 FCB     CoSAVE
E9C2 DF               (   cmds_retok.asm):00209                 FCB     CoDSKIS 
E9C3 E0               (   cmds_retok.asm):00210                 FCB     CoDSKOS         
E9C4 DA               (   cmds_retok.asm):00211                 FCB     CoVERIFY
E9C5 82               (   cmds_retok.asm):00212                 FCB     CoREM 
E9C6 82               (   cmds_retok.asm):00213                 FCB     CoREM 
E9C7 82               (   cmds_retok.asm):00214                 FCB     CoREM 
                      (   cmds_retok.asm):00215                 
                      (   cmds_retok.asm):00216         ; MMC
                      (   cmds_retok.asm):00217                 
E9C8 E2               (   cmds_retok.asm):00218                 FCB     CoMCAS
E9C9 E3               (   cmds_retok.asm):00219                 FCB     CoMMIRROR
E9CA E4               (   cmds_retok.asm):00220                 FCB     CoMMOUNT
E9CB E5               (   cmds_retok.asm):00221                 FCB     CoHELP  
E9CC E6               (   cmds_retok.asm):00222                 FCB     CoRAMBOOT
E9CD E7               (   cmds_retok.asm):00223                 FCB     CoCAT   
E9CE E8               (   cmds_retok.asm):00224                 FCB     CoMDELETE
E9CF E9               (   cmds_retok.asm):00225                 FCB     CoMSAVE 
E9D0 EA               (   cmds_retok.asm):00226                 FCB     CoMLOAD 
E9D1 EB               (   cmds_retok.asm):00227                 FCB     CoMCARTLOAD
E9D2 EC               (   cmds_retok.asm):00228                 FCB     CoMTAPERUN
E9D3 ED               (   cmds_retok.asm):00229                 FCB     CoCWD   
E9D4 EE               (   cmds_retok.asm):00230                 FCB     CoMSETCFG
E9D5 EF               (   cmds_retok.asm):00231                 FCB     CoRETOK 
E9D6 F0               (   cmds_retok.asm):00232                 FCB     CoMDISK 
E9D7 F1               (   cmds_retok.asm):00233                 FCB     CoREWIND
E9D8 F2               (   cmds_retok.asm):00234                 FCB     CoMSETDT
E9D9 F3               (   cmds_retok.asm):00235                 FCB     CoMKDIR
E9DA                  (   cmds_retok.asm):00236         DragonCoCoCmdEnd
                      (   cmds_retok.asm):00237         
E9DA                  (   cmds_retok.asm):00238         DragonCoCoFunc
E9DA 80               (   cmds_retok.asm):00239                 FCB     CoSGN
E9DB 81               (   cmds_retok.asm):00240                 FCB     CoINT
E9DC 82               (   cmds_retok.asm):00241                 FCB     CoABS
E9DD 9A               (   cmds_retok.asm):00242                 FCB     CoPOS
E9DE 84               (   cmds_retok.asm):00243                 FCB     CoRND
E9DF 9B               (   cmds_retok.asm):00244                 FCB     CoSQR
E9E0 99               (   cmds_retok.asm):00245                 FCB     CoLOG
E9E1 97               (   cmds_retok.asm):00246                 FCB     CoEXP
E9E2 85               (   cmds_retok.asm):00247                 FCB     CoSIN
E9E3 95               (   cmds_retok.asm):00248                 FCB     CoCOS
E9E4 96               (   cmds_retok.asm):00249                 FCB     CoTAN
E9E5 94               (   cmds_retok.asm):00250                 FCB     CoATN
E9E6 86               (   cmds_retok.asm):00251                 FCB     CoPEEK
E9E7 87               (   cmds_retok.asm):00252                 FCB     CoLEN
E9E8 88               (   cmds_retok.asm):00253                 FCB     CoSTRS
E9E9 89               (   cmds_retok.asm):00254                 FCB     CoVAL
E9EA 8A               (   cmds_retok.asm):00255                 FCB     CoASC
E9EB 8B               (   cmds_retok.asm):00256                 FCB     CoCHRS
E9EC 8C               (   cmds_retok.asm):00257                 FCB     CoEOF
E9ED 8D               (   cmds_retok.asm):00258                 FCB     CoJOYSTK
E9EE 98               (   cmds_retok.asm):00259                 FCB     CoFIX
E9EF 9C               (   cmds_retok.asm):00260                 FCB     CoHEXS
E9F0 8E               (   cmds_retok.asm):00261                 FCB     CoLEFTS
E9F1 8F               (   cmds_retok.asm):00262                 FCB     CoRIGHTS
E9F2 90               (   cmds_retok.asm):00263                 FCB     CoMIDS
E9F3 91               (   cmds_retok.asm):00264                 FCB     CoPOINT
E9F4 92               (   cmds_retok.asm):00265                 FCB     CoINKEYS
E9F5 93               (   cmds_retok.asm):00266                 FCB     CoMEM
E9F6 9D               (   cmds_retok.asm):00267                 FCB     CoVARPTR
E9F7 9E               (   cmds_retok.asm):00268                 FCB     CoINSTR
E9F8 9F               (   cmds_retok.asm):00269                 FCB     CoTIMER
E9F9 A0               (   cmds_retok.asm):00270                 FCB     CoPPOINT
E9FA A1               (   cmds_retok.asm):00271                 FCB     CoSTRINGS
E9FB 83               (   cmds_retok.asm):00272                 FCB     CoUSR
                      (   cmds_retok.asm):00273         
                      (   cmds_retok.asm):00274         ; DOS
                      (   cmds_retok.asm):00275         
E9FC A5               (   cmds_retok.asm):00276                 FCB     CoLOF                   
E9FD A3               (   cmds_retok.asm):00277                 FCB     CoFREE                  
E9FE 82               (   cmds_retok.asm):00278                 FCB     CoREM           ; DgnERL                        
E9FF 82               (   cmds_retok.asm):00279                 FCB     CoREM           ; DgnERR                        
EA00 82               (   cmds_retok.asm):00280                 FCB     CoREM           ; DgnHIMEM              
EA01 A4               (   cmds_retok.asm):00281                 FCB     CoLOC                   
EA02 82               (   cmds_retok.asm):00282                 FCB     CoREM           ; DgnFRES                       
                      (   cmds_retok.asm):00283         
                      (   cmds_retok.asm):00284         ; MMC
                      (   cmds_retok.asm):00285         
EA03 A8               (   cmds_retok.asm):00286                 FCB     CoVER           
EA04 A9               (   cmds_retok.asm):00287                 FCB     CoWDS           
EA05 AA               (   cmds_retok.asm):00288                 FCB     CoFINDFIRSTS    
EA06 AB               (   cmds_retok.asm):00289                 FCB     CoFINDNEXTS     
EA07 AC               (   cmds_retok.asm):00290                 FCB     CoCFTYPE        
EA08 AD               (   cmds_retok.asm):00291                 FCB     CoMGETCFG       
EA09 AE               (   cmds_retok.asm):00292                 FCB     CoMGETDTS       
EA0A AF               (   cmds_retok.asm):00293                 FCB     CoMGETINAMES    
EA0B B0               (   cmds_retok.asm):00294                 FCB     CoSDS           
EA0C                  (   cmds_retok.asm):00295         DragonCoCoFuncEnd
                      (   cmds_retok.asm):00296         
     007A             (   cmds_retok.asm):00297         NoCommandsDgn   EQU             DragonCoCoCmdEnd-DragonCoCoCmd
     0032             (   cmds_retok.asm):00298         NoFuncsDgn          EQU         DragonCoCoFuncEnd-DragonCoCoFunc
                      (   cmds_retok.asm):00299         
     007A             (   cmds_retok.asm):00300         NoCommands      EQU     NoCommandsDgn
     0032             (   cmds_retok.asm):00301         NoFuncs         EQU     NoFuncsDgn
                      (   cmds_retok.asm):00302         
                      (   cmds_retok.asm):00303         ;*****************
                      (   cmds_retok.asm):00304         ; CoCo to Dragon *
                      (   cmds_retok.asm):00305         ;*****************
                      (   cmds_retok.asm):00306         
EA0C                  (   cmds_retok.asm):00307         CoCoDragonCmd
EA0C 80               (   cmds_retok.asm):00308                 FCB     DgnFOR
EA0D 81               (   cmds_retok.asm):00309                 FCB     DgnGO
EA0E 82               (   cmds_retok.asm):00310                 FCB     DgnREM
EA0F 83               (   cmds_retok.asm):00311                 FCB     DgnREM2
EA10 84               (   cmds_retok.asm):00312                 FCB     DgnELSE
EA11 85               (   cmds_retok.asm):00313                 FCB     DgnIF
EA12 86               (   cmds_retok.asm):00314                 FCB     DgnDATA
EA13 87               (   cmds_retok.asm):00315                 FCB     DgnPRINT
EA14 88               (   cmds_retok.asm):00316                 FCB     DgnON
EA15 89               (   cmds_retok.asm):00317                 FCB     DgnINPUT
EA16 8A               (   cmds_retok.asm):00318                 FCB     DgnEND
EA17 8B               (   cmds_retok.asm):00319                 FCB     DgnNEXT
EA18 8C               (   cmds_retok.asm):00320                 FCB     DgnDIM
EA19 8D               (   cmds_retok.asm):00321                 FCB     DgnREAD
EA1A 8F               (   cmds_retok.asm):00322                 FCB     DgnRUN
EA1B 90               (   cmds_retok.asm):00323                 FCB     DgnRESTORE
EA1C 91               (   cmds_retok.asm):00324                 FCB     DgnRETURN
EA1D 92               (   cmds_retok.asm):00325                 FCB     DgnSTOP
EA1E 93               (   cmds_retok.asm):00326                 FCB     DgnPOKE
EA1F 94               (   cmds_retok.asm):00327                 FCB     DgnCONT
EA20 95               (   cmds_retok.asm):00328                 FCB     DgnLIST
EA21 96               (   cmds_retok.asm):00329                 FCB     DgnCLEAR
EA22 97               (   cmds_retok.asm):00330                 FCB     DgnNEW
EA23 99               (   cmds_retok.asm):00331                 FCB     DgnCLOAD
EA24 9A               (   cmds_retok.asm):00332                 FCB     DgnCSAVE
EA25 9B               (   cmds_retok.asm):00333                 FCB     DgnOPEN
EA26 9C               (   cmds_retok.asm):00334                 FCB     DgnCLOSE
EA27 9D               (   cmds_retok.asm):00335                 FCB     DgnLLIST
EA28 9E               (   cmds_retok.asm):00336                 FCB     DgnSET
EA29 9F               (   cmds_retok.asm):00337                 FCB     DgnRESET
EA2A A0               (   cmds_retok.asm):00338                 FCB     DgnCLS
EA2B A1               (   cmds_retok.asm):00339                 FCB     DgnMOTOR
EA2C A2               (   cmds_retok.asm):00340                 FCB     DgnSOUND
EA2D A3               (   cmds_retok.asm):00341                 FCB     DgnAUDIO
EA2E A4               (   cmds_retok.asm):00342                 FCB     DgnEXEC
EA2F A5               (   cmds_retok.asm):00343                 FCB     DgnSKIPF
EA30 BB               (   cmds_retok.asm):00344                 FCB     DgnTAB
EA31 BC               (   cmds_retok.asm):00345                 FCB     DgnTO
EA32 BD               (   cmds_retok.asm):00346                 FCB     DgnSUB
EA33 BF               (   cmds_retok.asm):00347                 FCB     DgnTHEN
EA34 C0               (   cmds_retok.asm):00348                 FCB     DgnNOT
EA35 C1               (   cmds_retok.asm):00349                 FCB     DgnSTEP
EA36 C2               (   cmds_retok.asm):00350                 FCB     DgnOFF
EA37 C3               (   cmds_retok.asm):00351                 FCB     DgnPlus
EA38 C4               (   cmds_retok.asm):00352                 FCB     DgnMinus
EA39 C5               (   cmds_retok.asm):00353                 FCB     DgnTimes
EA3A C6               (   cmds_retok.asm):00354                 FCB     DgnDivide
EA3B C7               (   cmds_retok.asm):00355                 FCB     DgnPower
EA3C C8               (   cmds_retok.asm):00356                 FCB     DgnAND
EA3D C9               (   cmds_retok.asm):00357                 FCB     DgnOR
EA3E CA               (   cmds_retok.asm):00358                 FCB     DgnGt
EA3F CB               (   cmds_retok.asm):00359                 FCB     DgnEq
EA40 CC               (   cmds_retok.asm):00360                 FCB     DgnLt
EA41 A6               (   cmds_retok.asm):00361                 FCB     DgnDEL
EA42 A7               (   cmds_retok.asm):00362                 FCB     DgnEDIT
EA43 A8               (   cmds_retok.asm):00363                 FCB     DgnTRON
EA44 A9               (   cmds_retok.asm):00364                 FCB     DgnTROFF
EA45 98               (   cmds_retok.asm):00365                 FCB     DgnDEF
EA46 8E               (   cmds_retok.asm):00366                 FCB     DgnLET
EA47 AA               (   cmds_retok.asm):00367                 FCB     DgnLINE
EA48 AB               (   cmds_retok.asm):00368                 FCB     DgnPCLS
EA49 AC               (   cmds_retok.asm):00369                 FCB     DgnPSET
EA4A AD               (   cmds_retok.asm):00370                 FCB     DgnPRESET
EA4B AE               (   cmds_retok.asm):00371                 FCB     DgnSCREEN
EA4C AF               (   cmds_retok.asm):00372                 FCB     DgnPCLEAR
EA4D B0               (   cmds_retok.asm):00373                 FCB     DgnCOLOR
EA4E B1               (   cmds_retok.asm):00374                 FCB     DgnCIRCLE
EA4F B2               (   cmds_retok.asm):00375                 FCB     DgnPAINT
EA50 B3               (   cmds_retok.asm):00376                 FCB     DgnGET
EA51 B4               (   cmds_retok.asm):00377                 FCB     DgnPUT
EA52 B5               (   cmds_retok.asm):00378                 FCB     DgnDRAW
EA53 B6               (   cmds_retok.asm):00379                 FCB     DgnPCOPY
EA54 B7               (   cmds_retok.asm):00380                 FCB     DgnPMODE
EA55 B8               (   cmds_retok.asm):00381                 FCB     DgnPLAY
EA56 B9               (   cmds_retok.asm):00382                 FCB     DgnDLOAD
EA57 BA               (   cmds_retok.asm):00383                 FCB     DgnRENUM
EA58 BE               (   cmds_retok.asm):00384                 FCB     DgnFN
EA59 CD               (   cmds_retok.asm):00385                 FCB     DgnUSING
                      (   cmds_retok.asm):00386         
                      (   cmds_retok.asm):00387         ;DOS
EA5A D5               (   cmds_retok.asm):00388                 FCB     DgnDIR
EA5B D6               (   cmds_retok.asm):00389                 FCB     DgnDRIVE
EA5C 82               (   cmds_retok.asm):00390                 FCB     DgnREM          ; CoFIELD
EA5D 82               (   cmds_retok.asm):00391                 FCB     DgnREM          ; CoFILES
EA5E DB               (   cmds_retok.asm):00392                 FCB     DgnKILL
EA5F DC               (   cmds_retok.asm):00393                 FCB     DgnLOAD
EA60 82               (   cmds_retok.asm):00394                 FCB     DgnREM          ; CoLSET
EA61 DD               (   cmds_retok.asm):00395                 FCB     DgnMERGE
EA62 E0               (   cmds_retok.asm):00396                 FCB     DgnRENAME
EA63 82               (   cmds_retok.asm):00397                 FCB     DgnREM          ; CoRSET
EA64 E1               (   cmds_retok.asm):00398                 FCB     DgnSAVE
EA65 82               (   cmds_retok.asm):00399                 FCB     DgnREM          ; CoWRITE
EA66 E4               (   cmds_retok.asm):00400                 FCB     DgnVERIFY
EA67 82               (   cmds_retok.asm):00401                 FCB     DgnREM          ; CoUNLOAD
EA68 D7               (   cmds_retok.asm):00402                 FCB     DgnDSKINIT
EA69 CF               (   cmds_retok.asm):00403                 FCB     DgnBACKUP
EA6A D3               (   cmds_retok.asm):00404                 FCB     DgnCOPY
EA6B E2               (   cmds_retok.asm):00405                 FCB     DgnSREAD        ; CoDSKIS
EA6C E3               (   cmds_retok.asm):00406                 FCB     DgnSWRITE       ; CoDSKOS
EA6D D1               (   cmds_retok.asm):00407                 FCB DgnBOOT     ; CoDOS
                      (   cmds_retok.asm):00408             
                      (   cmds_retok.asm):00409         ; MMC
EA6E E8               (   cmds_retok.asm):00410                 FCB     DgnMCAS         
EA6F E9               (   cmds_retok.asm):00411                 FCB     DgnMMIRROR      
EA70 EA               (   cmds_retok.asm):00412                 FCB     DgnMMOUNT       
EA71 EB               (   cmds_retok.asm):00413                 FCB     DgnHELP         
EA72 EC               (   cmds_retok.asm):00414                 FCB     DgnRAMBOOT      
EA73 ED               (   cmds_retok.asm):00415                 FCB     DgnCAT          
EA74 EE               (   cmds_retok.asm):00416                 FCB     DgnMDELETE      
EA75 EF               (   cmds_retok.asm):00417                 FCB     DgnMSAVE        
EA76 F0               (   cmds_retok.asm):00418                 FCB     DgnMLOAD        
EA77 F1               (   cmds_retok.asm):00419                 FCB     DgnMCARTLOAD    
EA78 F2               (   cmds_retok.asm):00420                 FCB     DgnMTAPERUN     
EA79 F3               (   cmds_retok.asm):00421                 FCB     DgnCWD          
EA7A F4               (   cmds_retok.asm):00422                 FCB     DgnMSETCFG      
EA7B F5               (   cmds_retok.asm):00423                 FCB     DgnRETOK        
EA7C F6               (   cmds_retok.asm):00424                 FCB     DgnMDISK        
EA7D F7               (   cmds_retok.asm):00425                 FCB     DgnREWIND       
EA7E F8               (   cmds_retok.asm):00426                 FCB     DgnMSETDT       
EA7F F9               (   cmds_retok.asm):00427                 FCB     DgnMKDIR        
EA80                  (   cmds_retok.asm):00428         CoCoDragonCmdEnd
                      (   cmds_retok.asm):00429         
                      (   cmds_retok.asm):00430         ;       FILL    DgnREM,(NoCommandsDgn-NoCommandsCoCo)
                      (   cmds_retok.asm):00431         
                      (   cmds_retok.asm):00432                 
EA80                  (   cmds_retok.asm):00433         CoCoDragonFunc
EA80 80               (   cmds_retok.asm):00434                 FCB     DgnSGN
EA81 81               (   cmds_retok.asm):00435                 FCB     DgnINT
EA82 82               (   cmds_retok.asm):00436                 FCB     DgnABS
EA83 A1               (   cmds_retok.asm):00437                 FCB     DgnUSR
EA84 84               (   cmds_retok.asm):00438                 FCB     DgnRND
EA85 88               (   cmds_retok.asm):00439                 FCB     DgnSIN
EA86 8C               (   cmds_retok.asm):00440                 FCB     DgnPEEK
EA87 8D               (   cmds_retok.asm):00441                 FCB     DgnLEN
EA88 8E               (   cmds_retok.asm):00442                 FCB     DgnSTRS
EA89 8F               (   cmds_retok.asm):00443                 FCB     DgnVAL
EA8A 90               (   cmds_retok.asm):00444                 FCB     DgnASC
EA8B 91               (   cmds_retok.asm):00445                 FCB     DgnCHRS
EA8C 92               (   cmds_retok.asm):00446                 FCB     DgnEOF
EA8D 93               (   cmds_retok.asm):00447                 FCB     DgnJOYSTK
EA8E 96               (   cmds_retok.asm):00448                 FCB     DgnLEFTS
EA8F 97               (   cmds_retok.asm):00449                 FCB     DgnRIGHTS
EA90 98               (   cmds_retok.asm):00450                 FCB     DgnMIDS
EA91 99               (   cmds_retok.asm):00451                 FCB     DgnPOINT
EA92 9A               (   cmds_retok.asm):00452                 FCB     DgnINKEYS
EA93 9B               (   cmds_retok.asm):00453                 FCB     DgnMEM
EA94 8B               (   cmds_retok.asm):00454                 FCB     DgnATN
EA95 89               (   cmds_retok.asm):00455                 FCB     DgnCOS
EA96 8A               (   cmds_retok.asm):00456                 FCB     DgnTAN
EA97 87               (   cmds_retok.asm):00457                 FCB     DgnEXP
EA98 94               (   cmds_retok.asm):00458                 FCB     DgnFIX
EA99 86               (   cmds_retok.asm):00459                 FCB     DgnLOG
EA9A 83               (   cmds_retok.asm):00460                 FCB     DgnPOS
EA9B 85               (   cmds_retok.asm):00461                 FCB     DgnSQR
EA9C 95               (   cmds_retok.asm):00462                 FCB     DgnHEXS
EA9D 9C               (   cmds_retok.asm):00463                 FCB     DgnVARPTR
EA9E 9D               (   cmds_retok.asm):00464                 FCB     DgnINSTR
EA9F 9E               (   cmds_retok.asm):00465                 FCB     DgnTIMER
EAA0 9F               (   cmds_retok.asm):00466                 FCB     DgnPPOINT
EAA1 A0               (   cmds_retok.asm):00467                 FCB     DgnSTRINGS
                      (   cmds_retok.asm):00468         
                      (   cmds_retok.asm):00469         ; DOS
EAA2 82               (   cmds_retok.asm):00470                 FCB     DgnREM          ; CoCVN
EAA3 A3               (   cmds_retok.asm):00471                 FCB     DgnFREE
EAA4 A7               (   cmds_retok.asm):00472                 FCB     DgnLOC
EAA5 A2               (   cmds_retok.asm):00473                 FCB     DgnLOF
EAA6 82               (   cmds_retok.asm):00474                 FCB     DgnREM          ; CoMKNS
EAA7 82               (   cmds_retok.asm):00475                 FCB     DgnREM          ; CoAS
                      (   cmds_retok.asm):00476         
                      (   cmds_retok.asm):00477         ; MMC
EAA8 A9               (   cmds_retok.asm):00478                 FCB     DgnVER          
EAA9 AA               (   cmds_retok.asm):00479                 FCB     DgnWDS          
EAAA AB               (   cmds_retok.asm):00480                 FCB     DgnFINDFIRSTS   
EAAB AC               (   cmds_retok.asm):00481                 FCB     DgnFINDNEXTS    
EAAC AD               (   cmds_retok.asm):00482                 FCB     DgnCFTYPE       
EAAD AE               (   cmds_retok.asm):00483                 FCB     DgnMGETCFG      
EAAE AF               (   cmds_retok.asm):00484                 FCB     DgnMGETDTS      
EAAF B0               (   cmds_retok.asm):00485                 FCB     DgnMGETINAMES   
EAB0 B1               (   cmds_retok.asm):00486                 FCB     DgnSDS          
                      (   cmds_retok.asm):00487                 
EAB1                  (   cmds_retok.asm):00488         CoCoDragonFuncEnd
                      (   cmds_retok.asm):00489                 
                      (   cmds_retok.asm):00490         ;    FILL       DgnREM,(NoFuncsDgn-NoFuncsCoCo)
                      (   cmds_retok.asm):00491         
     0074             (   cmds_retok.asm):00492         NoCommandsCoCo  EQU     CoCoDragonCmdEnd-CoCoDragonCmd
     0031             (   cmds_retok.asm):00493         NoFuncsCoCo         EQU CoCoDragonFuncEnd-CoCoDragonFunc
                      (   cmds_retok.asm):00494         
                      (   cmds_retok.asm):00495         
                      (   cmds_retok.asm):00496             ifne    0
EAB1                  (   cmds_retok.asm):00497         DragonCoCoCmd
                      (   cmds_retok.asm):00498                 FCB     $80
                      (   cmds_retok.asm):00499                 FCB     $81
                      (   cmds_retok.asm):00500                 FCB     $82
                      (   cmds_retok.asm):00501                 FCB     $83
                      (   cmds_retok.asm):00502                 FCB     $84
                      (   cmds_retok.asm):00503                 FCB     $85
                      (   cmds_retok.asm):00504                 FCB     $86
                      (   cmds_retok.asm):00505                 FCB     $87
                      (   cmds_retok.asm):00506                 FCB     $88
                      (   cmds_retok.asm):00507                 FCB     $89
                      (   cmds_retok.asm):00508                 FCB     $8a
                      (   cmds_retok.asm):00509                 FCB     $8b
                      (   cmds_retok.asm):00510                 FCB     $8c
                      (   cmds_retok.asm):00511                 FCB     $8d
                      (   cmds_retok.asm):00512                 FCB     $ba
                      (   cmds_retok.asm):00513                 FCB     $8e
                      (   cmds_retok.asm):00514                 FCB     $8f
                      (   cmds_retok.asm):00515                 FCB     $90
                      (   cmds_retok.asm):00516                 FCB     $91
                      (   cmds_retok.asm):00517                 FCB     $92
                      (   cmds_retok.asm):00518                 FCB     $93
                      (   cmds_retok.asm):00519                 FCB     $94
                      (   cmds_retok.asm):00520                 FCB     $95
                      (   cmds_retok.asm):00521                 FCB     $96
                      (   cmds_retok.asm):00522                 FCB     $b9
                      (   cmds_retok.asm):00523                 FCB     $97
                      (   cmds_retok.asm):00524                 FCB     $98
                      (   cmds_retok.asm):00525                 FCB     $99
                      (   cmds_retok.asm):00526                 FCB     $9a
                      (   cmds_retok.asm):00527                 FCB     $9b
                      (   cmds_retok.asm):00528                 FCB     $9c
                      (   cmds_retok.asm):00529                 FCB     $9d
                      (   cmds_retok.asm):00530                 FCB     $9e
                      (   cmds_retok.asm):00531                 FCB     $9f
                      (   cmds_retok.asm):00532                 FCB     $a0
                      (   cmds_retok.asm):00533                 FCB     $a1
                      (   cmds_retok.asm):00534                 FCB     $a2
                      (   cmds_retok.asm):00535                 FCB     $a3
                      (   cmds_retok.asm):00536                 FCB     $b5
                      (   cmds_retok.asm):00537                 FCB     $b6
                      (   cmds_retok.asm):00538                 FCB     $b7
                      (   cmds_retok.asm):00539                 FCB     $b8
                      (   cmds_retok.asm):00540                 FCB     $bb
                      (   cmds_retok.asm):00541                 FCB     $bc
                      (   cmds_retok.asm):00542                 FCB     $bd
                      (   cmds_retok.asm):00543                 FCB     $be
                      (   cmds_retok.asm):00544                 FCB     $bf
                      (   cmds_retok.asm):00545                 FCB     $c0
                      (   cmds_retok.asm):00546                 FCB     $c1
                      (   cmds_retok.asm):00547                 FCB     $c2
                      (   cmds_retok.asm):00548                 FCB     $c3
                      (   cmds_retok.asm):00549                 FCB     $c4
                      (   cmds_retok.asm):00550                 FCB     $c5
                      (   cmds_retok.asm):00551                 FCB     $c6
                      (   cmds_retok.asm):00552                 FCB     $c7
                      (   cmds_retok.asm):00553                 FCB     $c8
                      (   cmds_retok.asm):00554                 FCB     $c9
                      (   cmds_retok.asm):00555                 FCB     $ca
                      (   cmds_retok.asm):00556                 FCB     $cb
                      (   cmds_retok.asm):00557                 FCB     $a4
                      (   cmds_retok.asm):00558                 FCB     $a5
                      (   cmds_retok.asm):00559                 FCB     $a6
                      (   cmds_retok.asm):00560                 FCB     $cc
                      (   cmds_retok.asm):00561                 FCB     $a7
                      (   cmds_retok.asm):00562                 FCB     $a8
                      (   cmds_retok.asm):00563                 FCB     $a9
                      (   cmds_retok.asm):00564                 FCB     $aa
                      (   cmds_retok.asm):00565                 FCB     $ab
                      (   cmds_retok.asm):00566                 FCB     $ac
                      (   cmds_retok.asm):00567                 FCB     $ad
                      (   cmds_retok.asm):00568                 FCB     $ae
                      (   cmds_retok.asm):00569                 FCB     $af
                      (   cmds_retok.asm):00570                 FCB     $b0
                      (   cmds_retok.asm):00571                 FCB     $b1
                      (   cmds_retok.asm):00572                 FCB     $b2
                      (   cmds_retok.asm):00573                 FCB     $b3
                      (   cmds_retok.asm):00574                 FCB     $b4
                      (   cmds_retok.asm):00575                 FCB     $cd
EAB1                  (   cmds_retok.asm):00576         DragonCoCoCmdEnd
                      (   cmds_retok.asm):00577         
EAB1                  (   cmds_retok.asm):00578         DragonCoCoFunc
                      (   cmds_retok.asm):00579                 FCB     $80
                      (   cmds_retok.asm):00580                 FCB     $81
                      (   cmds_retok.asm):00581                 FCB     $82
                      (   cmds_retok.asm):00582                 FCB     $9a
                      (   cmds_retok.asm):00583                 FCB     $84
                      (   cmds_retok.asm):00584                 FCB     $9b
                      (   cmds_retok.asm):00585                 FCB     $99
                      (   cmds_retok.asm):00586                 FCB     $97
                      (   cmds_retok.asm):00587                 FCB     $85
                      (   cmds_retok.asm):00588                 FCB     $95
                      (   cmds_retok.asm):00589                 FCB     $96
                      (   cmds_retok.asm):00590                 FCB     $94
                      (   cmds_retok.asm):00591                 FCB     $86
                      (   cmds_retok.asm):00592                 FCB     $87
                      (   cmds_retok.asm):00593                 FCB     $88
                      (   cmds_retok.asm):00594                 FCB     $89
                      (   cmds_retok.asm):00595                 FCB     $8a
                      (   cmds_retok.asm):00596                 FCB     $8b
                      (   cmds_retok.asm):00597                 FCB     $8c
                      (   cmds_retok.asm):00598                 FCB     $8d
                      (   cmds_retok.asm):00599                 FCB     $98
                      (   cmds_retok.asm):00600                 FCB     $9c
                      (   cmds_retok.asm):00601                 FCB     $8e
                      (   cmds_retok.asm):00602                 FCB     $8f
                      (   cmds_retok.asm):00603                 FCB     $90
                      (   cmds_retok.asm):00604                 FCB     $91
                      (   cmds_retok.asm):00605                 FCB     $92
                      (   cmds_retok.asm):00606                 FCB     $93
                      (   cmds_retok.asm):00607                 FCB     $9d
                      (   cmds_retok.asm):00608                 FCB     $9e
                      (   cmds_retok.asm):00609                 FCB     $9f
                      (   cmds_retok.asm):00610                 FCB     $a0
                      (   cmds_retok.asm):00611                 FCB     $a1
                      (   cmds_retok.asm):00612                 FCB     $83
EAB1                  (   cmds_retok.asm):00613         DragonCoCoFuncEnd
                      (   cmds_retok.asm):00614         
EAB1                  (   cmds_retok.asm):00615         NoCommands      EQU             DragonCoCoCmdEnd-DragonCoCoCmd
EAB1                  (   cmds_retok.asm):00616         NoFuncs         EQU             DragonCoCoFuncEnd-DragonCoCoFunc
                      (   cmds_retok.asm):00617         
                      (   cmds_retok.asm):00618         ;*****************
                      (   cmds_retok.asm):00619         ; CoCo to Dragon *
                      (   cmds_retok.asm):00620         ;*****************
                      (   cmds_retok.asm):00621         
EAB1                  (   cmds_retok.asm):00622         CoCoDragonCmd
                      (   cmds_retok.asm):00623                 FCB     $80
                      (   cmds_retok.asm):00624                 FCB     $81
                      (   cmds_retok.asm):00625                 FCB     $82
                      (   cmds_retok.asm):00626                 FCB     $83
                      (   cmds_retok.asm):00627                 FCB     $84
                      (   cmds_retok.asm):00628                 FCB     $85
                      (   cmds_retok.asm):00629                 FCB     $86
                      (   cmds_retok.asm):00630                 FCB     $87
                      (   cmds_retok.asm):00631                 FCB     $88
                      (   cmds_retok.asm):00632                 FCB     $89
                      (   cmds_retok.asm):00633                 FCB     $8a
                      (   cmds_retok.asm):00634                 FCB     $8b
                      (   cmds_retok.asm):00635                 FCB     $8c
                      (   cmds_retok.asm):00636                 FCB     $8d
                      (   cmds_retok.asm):00637                 FCB     $8f
                      (   cmds_retok.asm):00638                 FCB     $90
                      (   cmds_retok.asm):00639                 FCB     $91
                      (   cmds_retok.asm):00640                 FCB     $92
                      (   cmds_retok.asm):00641                 FCB     $93
                      (   cmds_retok.asm):00642                 FCB     $94
                      (   cmds_retok.asm):00643                 FCB     $95
                      (   cmds_retok.asm):00644                 FCB     $96
                      (   cmds_retok.asm):00645                 FCB     $97
                      (   cmds_retok.asm):00646                 FCB     $99
                      (   cmds_retok.asm):00647                 FCB     $9a
                      (   cmds_retok.asm):00648                 FCB     $9b
                      (   cmds_retok.asm):00649                 FCB     $9c
                      (   cmds_retok.asm):00650                 FCB     $9d
                      (   cmds_retok.asm):00651                 FCB     $9e
                      (   cmds_retok.asm):00652                 FCB     $9f
                      (   cmds_retok.asm):00653                 FCB     $a0
                      (   cmds_retok.asm):00654                 FCB     $a1
                      (   cmds_retok.asm):00655                 FCB     $a2
                      (   cmds_retok.asm):00656                 FCB     $a3
                      (   cmds_retok.asm):00657                 FCB     $a4
                      (   cmds_retok.asm):00658                 FCB     $a5
                      (   cmds_retok.asm):00659                 FCB     $bb
                      (   cmds_retok.asm):00660                 FCB     $bc
                      (   cmds_retok.asm):00661                 FCB     $bd
                      (   cmds_retok.asm):00662                 FCB     $bf
                      (   cmds_retok.asm):00663                 FCB     $c0
                      (   cmds_retok.asm):00664                 FCB     $c1
                      (   cmds_retok.asm):00665                 FCB     $c2
                      (   cmds_retok.asm):00666                 FCB     $c3
                      (   cmds_retok.asm):00667                 FCB     $c4
                      (   cmds_retok.asm):00668                 FCB     $c5
                      (   cmds_retok.asm):00669                 FCB     $c6
                      (   cmds_retok.asm):00670                 FCB     $c7
                      (   cmds_retok.asm):00671                 FCB     $c8
                      (   cmds_retok.asm):00672                 FCB     $c9
                      (   cmds_retok.asm):00673                 FCB     $ca
                      (   cmds_retok.asm):00674                 FCB     $cb
                      (   cmds_retok.asm):00675                 FCB     $cc
                      (   cmds_retok.asm):00676                 FCB     $a6
                      (   cmds_retok.asm):00677                 FCB     $a7
                      (   cmds_retok.asm):00678                 FCB     $a8
                      (   cmds_retok.asm):00679                 FCB     $a9
                      (   cmds_retok.asm):00680                 FCB     $98
                      (   cmds_retok.asm):00681                 FCB     $8e
                      (   cmds_retok.asm):00682                 FCB     $aa
                      (   cmds_retok.asm):00683                 FCB     $ab
                      (   cmds_retok.asm):00684                 FCB     $ac
                      (   cmds_retok.asm):00685                 FCB     $ad
                      (   cmds_retok.asm):00686                 FCB     $ae
                      (   cmds_retok.asm):00687                 FCB     $af
                      (   cmds_retok.asm):00688                 FCB     $b0
                      (   cmds_retok.asm):00689                 FCB     $b1
                      (   cmds_retok.asm):00690                 FCB     $b2
                      (   cmds_retok.asm):00691                 FCB     $b3
                      (   cmds_retok.asm):00692                 FCB     $b4
                      (   cmds_retok.asm):00693                 FCB     $b5
                      (   cmds_retok.asm):00694                 FCB     $b6
                      (   cmds_retok.asm):00695                 FCB     $b7
                      (   cmds_retok.asm):00696                 FCB     $b8
                      (   cmds_retok.asm):00697                 FCB     $b9
                      (   cmds_retok.asm):00698                 FCB     $ba
                      (   cmds_retok.asm):00699                 FCB     $be
                      (   cmds_retok.asm):00700                 FCB     $cd
                      (   cmds_retok.asm):00701         
EAB1                  (   cmds_retok.asm):00702         CoCoDragonFunc
                      (   cmds_retok.asm):00703                 FCB     $80
                      (   cmds_retok.asm):00704                 FCB     $81
                      (   cmds_retok.asm):00705                 FCB     $82
                      (   cmds_retok.asm):00706                 FCB     $a1
                      (   cmds_retok.asm):00707                 FCB     $84
                      (   cmds_retok.asm):00708                 FCB     $88
                      (   cmds_retok.asm):00709                 FCB     $8c
                      (   cmds_retok.asm):00710                 FCB     $8d
                      (   cmds_retok.asm):00711                 FCB     $8e
                      (   cmds_retok.asm):00712                 FCB     $8f
                      (   cmds_retok.asm):00713                 FCB     $90
                      (   cmds_retok.asm):00714                 FCB     $91
                      (   cmds_retok.asm):00715                 FCB     $92
                      (   cmds_retok.asm):00716                 FCB     $93
                      (   cmds_retok.asm):00717                 FCB     $96
                      (   cmds_retok.asm):00718                 FCB     $97
                      (   cmds_retok.asm):00719                 FCB     $98
                      (   cmds_retok.asm):00720                 FCB     $99
                      (   cmds_retok.asm):00721                 FCB     $9a
                      (   cmds_retok.asm):00722                 FCB     $9b
                      (   cmds_retok.asm):00723                 FCB     $8b
                      (   cmds_retok.asm):00724                 FCB     $89
                      (   cmds_retok.asm):00725                 FCB     $8a
                      (   cmds_retok.asm):00726                 FCB     $87
                      (   cmds_retok.asm):00727                 FCB     $94
                      (   cmds_retok.asm):00728                 FCB     $86
                      (   cmds_retok.asm):00729                 FCB     $83
                      (   cmds_retok.asm):00730                 FCB     $85
                      (   cmds_retok.asm):00731                 FCB     $95
                      (   cmds_retok.asm):00732                 FCB     $9c
                      (   cmds_retok.asm):00733                 FCB     $9d
                      (   cmds_retok.asm):00734                 FCB     $9e
                      (   cmds_retok.asm):00735                 FCB     $9f
                      (   cmds_retok.asm):00736                 FCB     $a0
                      (   cmds_retok.asm):00737         
                      (   cmds_retok.asm):00738             endc
                      (   cmds_retok.asm):00739                 
EAB1                  (   cmds_retok.asm):00740         __cmd_retok_end
                      (   cmds_retok.asm):00741         
                      (    DragonMMC.asm):00669                         use             cmds_diskimg.asm
                      ( cmds_diskimg.asm):00001         ;
                      ( cmds_diskimg.asm):00002         ; cmds_diskimg.asm
                      ( cmds_diskimg.asm):00003         ;
                      ( cmds_diskimg.asm):00004         ; Disk image manipulation.
                      ( cmds_diskimg.asm):00005         ;
                      ( cmds_diskimg.asm):00006         
EAB1                  ( cmds_diskimg.asm):00007         __cmd_diskimg
                      ( cmds_diskimg.asm):00008         
                      ( cmds_diskimg.asm):00009                 ifdef   Dragon
EAB1                  ( cmds_diskimg.asm):00010         TokOn   equ     DTokON
EAB1                  ( cmds_diskimg.asm):00011         TokOff  equ     DTokOFF
                      ( cmds_diskimg.asm):00012                 else
     0088             ( cmds_diskimg.asm):00013         TokOn   equ     CTokON
     00AA             ( cmds_diskimg.asm):00014         TokOff  equ     CTokOFF
                      ( cmds_diskimg.asm):00015                 endc
                      ( cmds_diskimg.asm):00016         
EAB1                  ( cmds_diskimg.asm):00017         CmdMDisk
EAB1 1F89             ( cmds_diskimg.asm):00018                 tfr     a,b
EAB3 9D9F             ( cmds_diskimg.asm):00019                 jsr     <BasChrGet              ; skip first char               
                      ( cmds_diskimg.asm):00020         
EAB5 C149             ( cmds_diskimg.asm):00021                 cmpb    #'I                     ; MDiskI ?
EAB7 2721             ( cmds_diskimg.asm):00022                 beq     CmdMDiskIC              ; Yep insert
                      ( cmds_diskimg.asm):00023                 
EAB9 C143             ( cmds_diskimg.asm):00024                 cmpb    #'C                     ; MDiskC ?
EABB 271D             ( cmds_diskimg.asm):00025                 beq     CmdMDiskIC              ; Yep insert
                      ( cmds_diskimg.asm):00026                 
EABD C14F             ( cmds_diskimg.asm):00027                 cmpb    #'O                     ; MDiskO ?
EABF 274E             ( cmds_diskimg.asm):00028                 beq     CmdMdiskO               ; Yep, eject
                      ( cmds_diskimg.asm):00029                 
EAC1 C14C             ( cmds_diskimg.asm):00030                 cmpb    #'L                     ; MDiskL ?
EAC3 2753             ( cmds_diskimg.asm):00031                 beq     CmdMDiskL               ; Yep, list
                      ( cmds_diskimg.asm):00032                 
EAC5 C188             ( cmds_diskimg.asm):00033                 cmpb    #TokOn                  ; MDisk ON ?
EAC7 10270087         ( cmds_diskimg.asm):00034                 lbeq    CmdMdiskOn
                      ( cmds_diskimg.asm):00035                 
EACB C1AA             ( cmds_diskimg.asm):00036                 cmpb    #TokOff                 ; MDisk OFF ?
EACD 1027008E         ( cmds_diskimg.asm):00037                 lbeq    CmdMDiskOff
                      ( cmds_diskimg.asm):00038                 
EAD1 C142             ( cmds_diskimg.asm):00039                 cmpb    #'B                     ; MdiskB ?
EAD3 102700A0         ( cmds_diskimg.asm):00040                 lbeq    CmdMdiskB               ; Yep, boot
                      ( cmds_diskimg.asm):00041             
EAD7 7EB277           ( cmds_diskimg.asm):00042                 jmp     >BasSNError             ; no : ?SN Error
                      ( cmds_diskimg.asm):00043         
                      ( cmds_diskimg.asm):00044         ;
                      ( cmds_diskimg.asm):00045         ; Insert a disk image into a virtual drive.
                      ( cmds_diskimg.asm):00046         ;
                      ( cmds_diskimg.asm):00047         
EADA                  ( cmds_diskimg.asm):00048         CmdMDiskIC
EADA 3404             ( cmds_diskimg.asm):00049                 pshs    b                       ; Save 'I' or 'C'
EADC 8D18             ( cmds_diskimg.asm):00050                 bsr     CmdDiskIOCommon         ; get drive number and send it
EADE BDB26D           ( cmds_diskimg.asm):00051                 jsr     >VarCKComma             ; Check for comma, error if not
                      ( cmds_diskimg.asm):00052                 
EAE1 BDE2AD           ( cmds_diskimg.asm):00053                 jsr     >GetSendFileName2       ; get filename and send to AVR
                      ( cmds_diskimg.asm):00054                 
EAE4 8612             ( cmds_diskimg.asm):00055                 lda     #CMD_FILE_OPEN_IMG      ; Open disk image
EAE6 3504             ( cmds_diskimg.asm):00056                 puls    b                       ; revover version code
EAE8 C143             ( cmds_diskimg.asm):00057                 cmpb    #'C                     ; Open/Create?
EAEA 2602             ( cmds_diskimg.asm):00058                 bne     CmdMDiskICSend
EAEC 861F             ( cmds_diskimg.asm):00059                 lda     #CMD_FILE_OPENCRE_IMG   ; Open / create disk image
                      ( cmds_diskimg.asm):00060                 
EAEE                  ( cmds_diskimg.asm):00061         CmdMDiskICSend  
EAEE BDE00E           ( cmds_diskimg.asm):00062                 jsr     >MMC_SendCmd            ; Do it !
EAF1 BDE2D5           ( cmds_diskimg.asm):00063                 jsr     >CheckError             ; Check for error 
                      ( cmds_diskimg.asm):00064                 
EAF4 4F               ( cmds_diskimg.asm):00065                 clra
EAF5 39               ( cmds_diskimg.asm):00066                 rts
                      ( cmds_diskimg.asm):00067         
EAF6                  ( cmds_diskimg.asm):00068         CmdDiskIOCommon
EAF6 8D09             ( cmds_diskimg.asm):00069                 bsr     CmdDiskIOGetID          ; get disk id in a
                      ( cmds_diskimg.asm):00070                 
EAF8 BDEC84           ( cmds_diskimg.asm):00071                 jsr     >MMC_InitSendBytes      ; Begin sending bytes to the AVR
EAFB 7EECC5           ( cmds_diskimg.asm):00072                 jmp     >MMC_WaitPutRead        ; send the drive number
                      ( cmds_diskimg.asm):00073                 
EAFE                  ( cmds_diskimg.asm):00074         CmdDiskFC
EAFE 7EB44A           ( cmds_diskimg.asm):00075                 jmp     >BasFCError             ; Generate FC error
                      ( cmds_diskimg.asm):00076         
                      ( cmds_diskimg.asm):00077         ;
                      ( cmds_diskimg.asm):00078         ; Get an 8 bit number and validate as drive id
                      ( cmds_diskimg.asm):00079         ;
EB01                  ( cmds_diskimg.asm):00080         CmdDiskIOGetID
EB01 BDB70B           ( cmds_diskimg.asm):00081                 jsr     >VarGet8Bit             ; Get drive no into b
                      ( cmds_diskimg.asm):00082                 
EB04 1F98             ( cmds_diskimg.asm):00083                 tfr     b,a                     ; get into a
                      ( cmds_diskimg.asm):00084         
                      ( cmds_diskimg.asm):00085         ; Dragon DOS drives are 1..4, RS-DOS are 0..3
                      ( cmds_diskimg.asm):00086                 ifdef   Dragon
                      ( cmds_diskimg.asm):00087                 cmpa    #1                      ; less than 1 ?
                      ( cmds_diskimg.asm):00088                 blo     CmdDiskFC               ; yep : error
                      ( cmds_diskimg.asm):00089                 cmpa    #5                      ; greater than 4 ?
                      ( cmds_diskimg.asm):00090                 bhs     CmdDiskFC               ; yep : error
                      ( cmds_diskimg.asm):00091                 deca                            ; make zero based
                      ( cmds_diskimg.asm):00092                 
                      ( cmds_diskimg.asm):00093                 else
                      ( cmds_diskimg.asm):00094                 
EB06 8100             ( cmds_diskimg.asm):00095                 cmpa    #0                      ; less than 0 ?
EB08 25F4             ( cmds_diskimg.asm):00096                 blo     CmdDiskFC               ; yep : error
EB0A 8104             ( cmds_diskimg.asm):00097                 cmpa    #4                      ; greater than 3 ?
EB0C 24F0             ( cmds_diskimg.asm):00098                 bhs     CmdDiskFC               ; yep : error
                      ( cmds_diskimg.asm):00099                 endc
EB0E 39               ( cmds_diskimg.asm):00100                 rts
                      ( cmds_diskimg.asm):00101                 
                      ( cmds_diskimg.asm):00102         ;
                      ( cmds_diskimg.asm):00103         ; Eject a disk image from a virtual drive.
                      ( cmds_diskimg.asm):00104         ;
                      ( cmds_diskimg.asm):00105                 
EB0F                  ( cmds_diskimg.asm):00106         CmdMdiskO
EB0F 8DE5             ( cmds_diskimg.asm):00107                 bsr     CmdDiskIOCommon         ; get drive number and send it
                      ( cmds_diskimg.asm):00108         
EB11 8647             ( cmds_diskimg.asm):00109                 lda     #CMD_IMG_UNMOUNT        ; Unmount the image
EB13 BDE00E           ( cmds_diskimg.asm):00110                 jsr     >MMC_SendCmd            ; do it
                      ( cmds_diskimg.asm):00111         
EB16 4F               ( cmds_diskimg.asm):00112                 clra                            ; no error
EB17 39               ( cmds_diskimg.asm):00113                 rts
                      ( cmds_diskimg.asm):00114         
                      ( cmds_diskimg.asm):00115         ;
                      ( cmds_diskimg.asm):00116         ; List mounted disks
                      ( cmds_diskimg.asm):00117         ;
                      ( cmds_diskimg.asm):00118                 
EB18                  ( cmds_diskimg.asm):00119         CmdMDiskL
EB18 4F               ( cmds_diskimg.asm):00120                 clra                            ; send first and last disk IDs required
EB19 C603             ( cmds_diskimg.asm):00121                 ldb     #3                      ; 0..3
EB1B 170328           ( cmds_diskimg.asm):00122                 lbsr    MMC_SendDriveIDs
                      ( cmds_diskimg.asm):00123                 
EB1E 8642             ( cmds_diskimg.asm):00124                 lda     #CMD_GET_IMG_NAME       ; Get names of images
EB20 BDE00E           ( cmds_diskimg.asm):00125                 jsr     >MMC_SendCmd            ; do it
EB23 BDE2D5           ( cmds_diskimg.asm):00126                 jsr     >CheckError             ; Check for error 
                      ( cmds_diskimg.asm):00127         
                      ( cmds_diskimg.asm):00128         ; If we get here, then we have the images names in the AVR data buffer
                      ( cmds_diskimg.asm):00129         ; we will read them back and display them
                      ( cmds_diskimg.asm):00130         
EB26 8620             ( cmds_diskimg.asm):00131                 lda     #CMD_INIT_READ          ; start reading
EB28 BDE017           ( cmds_diskimg.asm):00132                 jsr     >MMC_SendCmdRaw         ; do it
                      ( cmds_diskimg.asm):00133         
EB2B 5F               ( cmds_diskimg.asm):00134                 clrb                            ; name counter
                      ( cmds_diskimg.asm):00135                 
EB2C                  ( cmds_diskimg.asm):00136         CmdMDiskLNext
EB2C 3404             ( cmds_diskimg.asm):00137                 pshs    b                       ; save it
                      ( cmds_diskimg.asm):00138                 
                      ( cmds_diskimg.asm):00139                 ifdef   Dragon
                      ( cmds_diskimg.asm):00140                 addb    #'1
                      ( cmds_diskimg.asm):00141                 else
EB2E CB30             ( cmds_diskimg.asm):00142                 addb    #'0                     ; convert to ASCII
                      ( cmds_diskimg.asm):00143                 endc
EB30 1F98             ( cmds_diskimg.asm):00144                 tfr     b,a
EB32 BDA30A           ( cmds_diskimg.asm):00145                 jsr     >BasicScreenOut         ; print it
                      ( cmds_diskimg.asm):00146                 
EB35 863A             ( cmds_diskimg.asm):00147                 lda     #':                     ; print :
EB37 BDA30A           ( cmds_diskimg.asm):00148                 jsr     >BasicScreenOut         ; print it
                      ( cmds_diskimg.asm):00149                 
EB3A                  ( cmds_diskimg.asm):00150         CmdMDiskLNextChar       
EB3A BDECCA           ( cmds_diskimg.asm):00151                 jsr     >MMC_WaitGetWritten     ; wait for a byte
                      ( cmds_diskimg.asm):00152                 
EB3D 8100             ( cmds_diskimg.asm):00153                 cmpa    #0                      ; end of name ?
EB3F 2705             ( cmds_diskimg.asm):00154                 beq     CmdMDiskLEOL
EB41 BDA30A           ( cmds_diskimg.asm):00155                 jsr     >BasicScreenOut         ; print it
EB44 20F4             ( cmds_diskimg.asm):00156                 bra     CmdMDiskLNextChar
                      ( cmds_diskimg.asm):00157         
EB46                  ( cmds_diskimg.asm):00158         CmdMDiskLEOL
EB46 1703EF           ( cmds_diskimg.asm):00159                 lbsr    CON_EOL                 ; send eol
EB49 3504             ( cmds_diskimg.asm):00160                 puls    b                       ; recover drive no
                      ( cmds_diskimg.asm):00161                 
EB4B 5C               ( cmds_diskimg.asm):00162                 incb                            ; increment
EB4C C104             ( cmds_diskimg.asm):00163                 cmpb    #4                      ; all done ?
EB4E 25DC             ( cmds_diskimg.asm):00164                 blo     CmdMDiskLNext           ; nope do next 
                      ( cmds_diskimg.asm):00165                 
EB50 4F               ( cmds_diskimg.asm):00166                 clra
EB51 39               ( cmds_diskimg.asm):00167                 rts
                      ( cmds_diskimg.asm):00168         
                      ( cmds_diskimg.asm):00169         ;
                      ( cmds_diskimg.asm):00170         ; Turn on disk emulation and reboot
                      ( cmds_diskimg.asm):00171         ;
EB52                  ( cmds_diskimg.asm):00172         CmdMdiskOn
EB52 D676             ( cmds_diskimg.asm):00173                 ldb     <CFGByte                ; Get config byte
EB54 CA20             ( cmds_diskimg.asm):00174                 orb     #CFG_ENABLE_DOS         ; Flag Dos enabled
EB56                  ( cmds_diskimg.asm):00175         MDiskOnOff
EB56 BDEC09           ( cmds_diskimg.asm):00176                 jsr     >SetCfgDefaultB 
                      ( cmds_diskimg.asm):00177                 
EB59 0F71             ( cmds_diskimg.asm):00178                 clr     WarmStartFlag           ; flag cold start
EB5B 6E9FFFFE         ( cmds_diskimg.asm):00179                 jmp     [$FFFE]                 ; reset machine, never returns
                      ( cmds_diskimg.asm):00180                 
                      ( cmds_diskimg.asm):00181         
EB5F                  ( cmds_diskimg.asm):00182         CmdMDiskOff
EB5F D676             ( cmds_diskimg.asm):00183                 ldb     <CFGByte                ; Get config byte
EB61 C4DF             ( cmds_diskimg.asm):00184                 andb    #~CFG_ENABLE_DOS         ; Flag Dos enabled
EB63 20F1             ( cmds_diskimg.asm):00185                 bra     MDiskOnOff
                      ( cmds_diskimg.asm):00186                 
                      ( cmds_diskimg.asm):00187         ; 
                      ( cmds_diskimg.asm):00188         ; Get the name of a specified image
                      ( cmds_diskimg.asm):00189         ; returns an empty string if no image mounted.
                      ( cmds_diskimg.asm):00190         ;
EB65                  ( cmds_diskimg.asm):00191         FuncGetIName
EB65 8D9A             ( cmds_diskimg.asm):00192                 bsr     CmdDiskIOGetID          ; get drive id, and adjust as needed, FCerror if invalid
EB67 1F89             ( cmds_diskimg.asm):00193                 tfr     a,b                     ; copy it into, so we only get one filename
                      ( cmds_diskimg.asm):00194                 
EB69 1702DA           ( cmds_diskimg.asm):00195                 lbsr    MMC_SendDriveIDs        ; send them
                      ( cmds_diskimg.asm):00196                 
EB6C 8642             ( cmds_diskimg.asm):00197                 lda     #CMD_GET_IMG_NAME       ; Get names of images
EB6E BDE00E           ( cmds_diskimg.asm):00198                 jsr     >MMC_SendCmd            ; do it
EB71 BDE2D5           ( cmds_diskimg.asm):00199                 jsr     >CheckError             ; Check for error 
                      ( cmds_diskimg.asm):00200         
EB74 7EE62B           ( cmds_diskimg.asm):00201                 jmp     >FuncRetMMCString       ; Return it to basic
                      ( cmds_diskimg.asm):00202         
                      ( cmds_diskimg.asm):00203         ;
                      ( cmds_diskimg.asm):00204         ; Boot disk inserted into the first drive. 
                      ( cmds_diskimg.asm):00205         ; This command can be used to boot a disk *WITHOUT* Basic disk emulation
                      ( cmds_diskimg.asm):00206         ; being enabled, for example to boot OS-9, NitrOS9, Flex etc.
                      ( cmds_diskimg.asm):00207         ;
                      ( cmds_diskimg.asm):00208         
EB77                  ( cmds_diskimg.asm):00209         CmdMdiskB
                      ( cmds_diskimg.asm):00210                 ifdef   Dragon
                      ( cmds_diskimg.asm):00211                 ldu     #2                      ; track 0, sector 2
                      ( cmds_diskimg.asm):00212                 endc
                      ( cmds_diskimg.asm):00213                 
                      ( cmds_diskimg.asm):00214                 ifdef   Tandy
EB77 CE0264           ( cmds_diskimg.asm):00215                 ldu     #(34*18)                ; track 34, sector 0
                      ( cmds_diskimg.asm):00216                 endc
                      ( cmds_diskimg.asm):00217         
EB7A 5F               ( cmds_diskimg.asm):00218                 clrb                            ; MSB of LSN always 0
EB7B 4F               ( cmds_diskimg.asm):00219                 clra                            ; drive 0
EB7C 8E2600           ( cmds_diskimg.asm):00220                 ldx     #$2600                  ; boot address
EB7F BDEDE0           ( cmds_diskimg.asm):00221                 jsr     >MMC_ReadDOSSec         ; go read first sector
EB82 261B             ( cmds_diskimg.asm):00222                 bne     CmdMdiskBErr
                      ( cmds_diskimg.asm):00223                 
EB84 CC2600           ( cmds_diskimg.asm):00224                 ldd     #$2600                  ; get first 2 bytes
EB87 10834F53         ( cmds_diskimg.asm):00225                 cmpd    #$4f53                  ; is it 'OS' ?
EB8B 2612             ( cmds_diskimg.asm):00226                 bne     CmdMdiskBErr            ; nope : error
                      ( cmds_diskimg.asm):00227                 
                      ( cmds_diskimg.asm):00228                 ifdef   Dragon
                      ( cmds_diskimg.asm):00229                 ldb     #15                     ; 15 more sectors
                      ( cmds_diskimg.asm):00230                 endc
                      ( cmds_diskimg.asm):00231                 
                      ( cmds_diskimg.asm):00232                 ifdef   Tandy
EB8D C611             ( cmds_diskimg.asm):00233                 ldb     #17                     ; 17 more sectors
                      ( cmds_diskimg.asm):00234                 endc
                      ( cmds_diskimg.asm):00235         
EB8F                  ( cmds_diskimg.asm):00236         CmdMdiskBLoop   
EB8F 3404             ( cmds_diskimg.asm):00237                 pshs    b                       ; save count
EB91 BDEDF8           ( cmds_diskimg.asm):00238                 jsr     >MMC_ReadNextDOSSec     ; go read next sector
EB94 2609             ( cmds_diskimg.asm):00239                 bne     CmdMdiskBErr
EB96 3504             ( cmds_diskimg.asm):00240                 puls    b                       ; recover count
                      ( cmds_diskimg.asm):00241                 
EB98 5A               ( cmds_diskimg.asm):00242                 decb                            ; decrement count
EB99 26F4             ( cmds_diskimg.asm):00243                 bne     CmdMdiskBLoop           ; do next.
                      ( cmds_diskimg.asm):00244                 
EB9B 7E2602           ( cmds_diskimg.asm):00245                 jmp     $2602                   ; jump to loaded code
EB9E 39               ( cmds_diskimg.asm):00246                 rts
                      ( cmds_diskimg.asm):00247              
EB9F                  ( cmds_diskimg.asm):00248         CmdMdiskBErr
EB9F 7EB44A           ( cmds_diskimg.asm):00249                 jmp     >BasFCError
                      ( cmds_diskimg.asm):00250              
EBA2                  ( cmds_diskimg.asm):00251         __cmd_diskimg_end
                      (    DragonMMC.asm):00670                 use     cmds_datetime.asm
                      (cmds_datetime.asm):00001         ;
                      (cmds_datetime.asm):00002         ; Data and time functions
                      (cmds_datetime.asm):00003         ;
                      (cmds_datetime.asm):00004         
EBA2                  (cmds_datetime.asm):00005         __cmd_datetime
                      (cmds_datetime.asm):00006         
EBA2                  (cmds_datetime.asm):00007         CmdSetDT
EBA2 86C1             (cmds_datetime.asm):00008             lda     #CMD_SET_DATETIME           ; Set data and time
EBA4 7EE2B3           (cmds_datetime.asm):00009             jmp     >CmdSendStringCmd           ; Go send it!
                      (cmds_datetime.asm):00010                 
EBA7                  (cmds_datetime.asm):00011         FuncGetDT
EBA7 86C0             (cmds_datetime.asm):00012             lda         #CMD_GET_DATETIME                       ; Get date and time
EBA9 BDE00E           (cmds_datetime.asm):00013                 jsr         >MMC_SendCmd
EBAC BDE2D5           (cmds_datetime.asm):00014                 jsr     >CheckError                                     ; check for errors, returns to basic on error
                      (cmds_datetime.asm):00015         
EBAF 7EE62B           (cmds_datetime.asm):00016             jmp     >FuncRetMMCString           ; Return it to basic.
                      (cmds_datetime.asm):00017         
                      (cmds_datetime.asm):00018         
                      (cmds_datetime.asm):00019         
EBB2                  (cmds_datetime.asm):00020         ShowDateTime
EBB2 8EE382           (cmds_datetime.asm):00021             ldx     #RTCMess-1                  ; get address of messgae
EBB5 BDB99C           (cmds_datetime.asm):00022             jsr     >TextOutString
                      (cmds_datetime.asm):00023         
EBB8 86C0             (cmds_datetime.asm):00024             lda         #CMD_GET_DATETIME                       ; Get date and time
EBBA BDE00E           (cmds_datetime.asm):00025                 jsr         >MMC_SendCmd
                      (cmds_datetime.asm):00026         
EBBD BDE622           (cmds_datetime.asm):00027             jsr     >GetStrLenA                 ; Get length in A
                      (cmds_datetime.asm):00028         
EBC0 3402             (cmds_datetime.asm):00029             pshs    a                           ; save length
                      (cmds_datetime.asm):00030             
EBC2 8620             (cmds_datetime.asm):00031                 lda             #CMD_INIT_READ                          ; Get date string
EBC4 BDE017           (cmds_datetime.asm):00032                 jsr         >MMC_SendCmdRaw
                      (cmds_datetime.asm):00033            
EBC7 3504             (cmds_datetime.asm):00034             puls    b                           ; retrieve length
                      (cmds_datetime.asm):00035         
EBC9                  (cmds_datetime.asm):00036         ShowDateNext
EBC9 BDECCA           (cmds_datetime.asm):00037                 jsr         >MMC_WaitGetWritten                 ; Wait for byte, and get it in a
EBCC BDA30A           (cmds_datetime.asm):00038             jsr     >BasicScreenOut             ; send to screen
EBCF 5A               (cmds_datetime.asm):00039             decb                                ; decrement count
EBD0 26F7             (cmds_datetime.asm):00040             bne     ShowDateNext
                      (cmds_datetime.asm):00041             
EBD2 BDEF38           (cmds_datetime.asm):00042             jsr     >CON_EOL                    ; print eol.
                      (cmds_datetime.asm):00043         
EBD5 39               (cmds_datetime.asm):00044             rts
                      (cmds_datetime.asm):00045         
EBD6                  (cmds_datetime.asm):00046         __cmd_datetime_end
                      (    DragonMMC.asm):00671                         use             cmds_config.asm
                      (  cmds_config.asm):00001         ;
                      (  cmds_config.asm):00002         ; cmds_config.asm Get/Set config.
                      (  cmds_config.asm):00003         ;
                      (  cmds_config.asm):00004         
                      (  cmds_config.asm):00005         ;
                      (  cmds_config.asm):00006         ; If one byte supplied then set config for this platform, else if two 
                      (  cmds_config.asm):00007         ; bytes supplied, then set for the supplied platform plat,value
                      (  cmds_config.asm):00008         ;       
                      (  cmds_config.asm):00009         ; SetCfg configbyte,<platform>
                      (  cmds_config.asm):00010         ;       
                      (  cmds_config.asm):00011         
EBD6                  (  cmds_config.asm):00012         __cmd_config
                      (  cmds_config.asm):00013         
EBD6                  (  cmds_config.asm):00014         CmdSetCFG
EBD6 8153             (  cmds_config.asm):00015                         cmpa    #'S                                             ; Setbit ?
EBD8 270D             (  cmds_config.asm):00016                         beq             CmdSetCFGSetBits
EBDA 8143             (  cmds_config.asm):00017                         cmpa    #'C                                             ; Clearbit ?
EBDC 270F             (  cmds_config.asm):00018                         beq             CmdSetCFGClearBits
                      (  cmds_config.asm):00019         
                      (  cmds_config.asm):00020         ; Come here if setting directly 
EBDE 170341           (  cmds_config.asm):00021                         lbsr    CON_DotEOL
EBE1 8D10             (  cmds_config.asm):00022                         bsr             CmdSetCFGGetParm                ; Get params
EBE3                  (  cmds_config.asm):00023         CmdSetCFGSetByte                
EBE3 8D4D             (  cmds_config.asm):00024                         bsr             SetCFGinAB                              ; set config byte
EBE5 4F               (  cmds_config.asm):00025                         clra
EBE6 39               (  cmds_config.asm):00026                         rts
                      (  cmds_config.asm):00027         
EBE7                  (  cmds_config.asm):00028         CmdSetCFGSetBits
EBE7 9D9F             (  cmds_config.asm):00029                         JSR     <BasChrGet                              ; skip  
                      (  cmds_config.asm):00030                         
EBE9 8D08             (  cmds_config.asm):00031                         bsr             CmdSetCFGGetParm                ; Get params in 
EBEB 2052             (  cmds_config.asm):00032                         bra             SetCFGBitsAB                    ; Go set them
                      (  cmds_config.asm):00033                         
EBED                  (  cmds_config.asm):00034         CmdSetCFGClearBits              
EBED 9D9F             (  cmds_config.asm):00035                         JSR     <BasChrGet                              ; skip  
                      (  cmds_config.asm):00036                         
EBEF 8D02             (  cmds_config.asm):00037                         bsr             CmdSetCFGGetParm                ; Get params in 
EBF1 205C             (  cmds_config.asm):00038                         bra             ClearCFGBitsAB                  ; Go set them
                      (  cmds_config.asm):00039                         
EBF3                  (  cmds_config.asm):00040         CmdSetCFGGetParm                
EBF3 BDB70B           (  cmds_config.asm):00041                         jsr             >VarGet8Bit                             ; Get first byte from basic
EBF6 BDE2C1           (  cmds_config.asm):00042                         jsr             >CkComma                                ; is there another param?
EBF9 260B             (  cmds_config.asm):00043                         bne             CmdSetCFGDefault                ; no assume current platform
                      (  cmds_config.asm):00044                         
EBFB 3404             (  cmds_config.asm):00045                         pshs    b                                               ; save value
EBFD BDF02F           (  cmds_config.asm):00046                         jsr             >MGetCommaThen8Bit              ; yes: go get platform
                      (  cmds_config.asm):00047         
EC00 3502             (  cmds_config.asm):00048                         puls    a                                               ; recover value
EC02 1E89             (  cmds_config.asm):00049                 exg             a,b                                             ; get platform in a, value in b
EC04 2002             (  cmds_config.asm):00050                         bra             CmdSetCFGGetParmEnd             ; Go set it
                      (  cmds_config.asm):00051         
EC06                  (  cmds_config.asm):00052         CmdSetCFGDefault
EC06 8D6F             (  cmds_config.asm):00053                         bsr             GetPlatform                             ; go get platform
EC08                  (  cmds_config.asm):00054         CmdSetCFGGetParmEnd
EC08 39               (  cmds_config.asm):00055                         rts
                      (  cmds_config.asm):00056                         
                      (  cmds_config.asm):00057                 
EC09                  (  cmds_config.asm):00058         SetCfgDefaultB
EC09 8DFB             (  cmds_config.asm):00059                 bsr     CmdSetCFGDefault        ; go set it
EC0B 20D6             (  cmds_config.asm):00060                 bra             CmdSetCFGSetByte
                      (  cmds_config.asm):00061                 
                      (  cmds_config.asm):00062         ;
                      (  cmds_config.asm):00063         ; GetCfg (<platform>)
                      (  cmds_config.asm):00064         ;       
                      (  cmds_config.asm):00065                         
EC0D                  (  cmds_config.asm):00066         FUNCGetCFG
EC0D BDE2CB           (  cmds_config.asm):00067                         jsr             >CkOpenBrac                             ; Any parameters?
EC10 2619             (  cmds_config.asm):00068                         bne             FUNCGetCFGDef
                      (  cmds_config.asm):00069                         
EC12 BDB26A           (  cmds_config.asm):00070                         jsr             >VarCKOpBrac                    ; Skip bracket
EC15 BDB70B           (  cmds_config.asm):00071                         jsr             >VarGet8Bit                             ; Get platform byte from basic
EC18 3404             (  cmds_config.asm):00072                         pshs    b
EC1A BDB267           (  cmds_config.asm):00073                 jsr             >VarCKClBrac                    ; Close bracket, error if not
EC1D 3502             (  cmds_config.asm):00074                         puls    a
                      (  cmds_config.asm):00075                 
EC1F 81FF             (  cmds_config.asm):00076                 cmpa    #$FF                    ; flag to get ID rather than cfg byte
EC21 2604             (  cmds_config.asm):00077                 bne     FUNCGetCFGID
EC23 8D52             (  cmds_config.asm):00078                 bsr     GetPlatform             ; get platform
EC25 2006             (  cmds_config.asm):00079                 bra             FUNCGetCFGAssign                ; and assign 
                      (  cmds_config.asm):00080                 
EC27                  (  cmds_config.asm):00081         FUNCGetCFGID
EC27 8D33             (  cmds_config.asm):00082                         bsr             GetCFGinA                               ; go get it
EC29 2002             (  cmds_config.asm):00083                         bra             FUNCGetCFGAssign                ; and assign 
EC2B                  (  cmds_config.asm):00084         FUNCGetCFGDef
EC2B 8D2D             (  cmds_config.asm):00085                         bsr             GetDefCFGinA                    ; get config byte
EC2D                  (  cmds_config.asm):00086         FUNCGetCFGAssign
EC2D 1F89             (  cmds_config.asm):00087                         tfr             a,b
EC2F 7EB4F3           (  cmds_config.asm):00088                         jmp             >VarAssign8Bit                  ; return it to basic
                      (  cmds_config.asm):00089                                         
EC32                  (  cmds_config.asm):00090         __cmd_config_end
                      (  cmds_config.asm):00091         
                      (    DragonMMC.asm):00672         
                      (    DragonMMC.asm):00673         ; Driver function includes
                      (    DragonMMC.asm):00674                         use             config_func.asm
                      (  config_func.asm):00001         ;
                      (  config_func.asm):00002         ; config_func.asm Get/Set config functions
                      (  config_func.asm):00003         ;
                      (  config_func.asm):00004         ; Seperated from cmds_config.asm 2017-09-04, PHS.
                      (  config_func.asm):00005         ;
                      (  config_func.asm):00006         ; Define MINIMUM to exclude code not needed by FLASH
                      (  config_func.asm):00007         ; 
EC32                  (  config_func.asm):00008         __config_func
                      (  config_func.asm):00009         ;
                      (  config_func.asm):00010         ; Set the config byte from platform in A, byte in B
                      (  config_func.asm):00011         ;
                      (  config_func.asm):00012         ; Writes the config byte to the global data area, using CMD_SEND_BYTES.
                      (  config_func.asm):00013         ; Then writes the platform byte to the latch register and give a
                      (  config_func.asm):00014         ; CMD_SET_CFG.
                      (  config_func.asm):00015         ;
EC32                  (  config_func.asm):00016         SetCFGinAB
                      (  config_func.asm):00017         ;               lbsr    MMC_InitSendBytes               ; send config byte
EC32 17F3E6           (  config_func.asm):00018                         lbsr    MMC_WaitPutLatchRead    ; send platform byte to AVR     
                      (  config_func.asm):00019         
EC35 1E89             (  config_func.asm):00020                         exg             a,b     
EC37 17F3E1           (  config_func.asm):00021                         lbsr    MMC_WaitPutLatchRead    ; send config byte to AVR       
                      (  config_func.asm):00022         
EC3A 86F1             (  config_func.asm):00023                         lda             #CMD_SET_CFG_BYTE               ; set config byte
EC3C 16F3CF           (  config_func.asm):00024                         lbra    MMC_SendCmd                             ; Exec send command
                      (  config_func.asm):00025         
                      (  config_func.asm):00026                         ifndef  MINIMUM
                      (  config_func.asm):00027         
EC3F                  (  config_func.asm):00028         SetCFGBitsAB
EC3F 3402             (  config_func.asm):00029                         pshs    a                                               ; save platform
EC41 8D19             (  config_func.asm):00030                         bsr             GetCFGinA                               ; get it's config byte
EC43 3404             (  config_func.asm):00031                         pshs    b                                               ; save mask
EC45 AAE4             (  config_func.asm):00032                         ora             ,s                                              ; mask it in
EC47                  (  config_func.asm):00033         SetClearCFGBitsAB
EC47 1E89             (  config_func.asm):00034                         exg             a,b                                             ; platform in a value in b
EC49 3261             (  config_func.asm):00035                         leas    1,s                                             ; drop mask
                      (  config_func.asm):00036                         
EC4B 3502             (  config_func.asm):00037                         puls    a                                               ; recover platform
EC4D 20E3             (  config_func.asm):00038                         bra             SetCFGinAB                              ; go set it
                      (  config_func.asm):00039                         
                      (  config_func.asm):00040         
EC4F                  (  config_func.asm):00041         ClearCFGBitsAB
EC4F 3402             (  config_func.asm):00042                         pshs    a                                               ; save platform
EC51 8D09             (  config_func.asm):00043                         bsr             GetCFGinA                               ; get it's config byte
EC53 53               (  config_func.asm):00044                         comb                                                    ; and with inverse mask
EC54 3404             (  config_func.asm):00045                         pshs    b                                               ; save mask
EC56 A4E4             (  config_func.asm):00046                         anda    ,s                                              ; mask it
                      (  config_func.asm):00047                         
EC58 20ED             (  config_func.asm):00048                         bra             SetClearCFGBitsAB               ; go set it
                      (  config_func.asm):00049         
                      (  config_func.asm):00050         ;
                      (  config_func.asm):00051         ; Get default (our) platform's config in a      
                      (  config_func.asm):00052         ;
                      (  config_func.asm):00053         
                      (  config_func.asm):00054         
EC5A                  (  config_func.asm):00055         GetDefCFGinA
EC5A 8D1B             (  config_func.asm):00056                         bsr             GetPlatform                             ; get platform, 1=Dragon, 2=CoCo
                      (  config_func.asm):00057         
                      (  config_func.asm):00058                         endc
                      (  config_func.asm):00059                         
EC5C                  (  config_func.asm):00060         GetCFGinA
EC5C 17F3BC           (  config_func.asm):00061                         lbsr    MMC_WaitPutLatchRead    ; send platform byte to AVR
                      (  config_func.asm):00062                         
EC5F 86F0             (  config_func.asm):00063                         lda             #CMD_GET_CFG_BYTE               ; Get the config byte
EC61 17F3B3           (  config_func.asm):00064                         lbsr    MMC_SendCmdRaw
EC64 170063           (  config_func.asm):00065                         lbsr    MMC_WaitGetWritten              ; wait for reply return it        
EC67 39               (  config_func.asm):00066                         rts
                      (  config_func.asm):00067                                 
                      (  config_func.asm):00068                         ifndef  MINIMUM
                      (  config_func.asm):00069         
                      (  config_func.asm):00070         ;
                      (  config_func.asm):00071         ; Tell the AVR what platform it is running on, we do this here, so
                      (  config_func.asm):00072         ; that if the 6809 changes platform (for example in a DraCo) the AVR
                      (  config_func.asm):00073         ; is aware of the fact.
                      (  config_func.asm):00074         ;
                      (  config_func.asm):00075         
EC68                  (  config_func.asm):00076         SetPlatform
EC68 8D0D             (  config_func.asm):00077                         bsr             GetPlatform                             ; get the platform by reading D_RAM_CTRL
                      (  config_func.asm):00078         
EC6A 17F3AE           (  config_func.asm):00079                         lbsr    MMC_WaitPutLatchRead    ; send platform byte to AVR
                      (  config_func.asm):00080                         
EC6D 86F2             (  config_func.asm):00081                         lda             #CMD_SET_PLATFORM               ; set the platform
EC6F 16F39C           (  config_func.asm):00082                         lbra    MMC_SendCmd                             ; send the cnd and get the result
                      (  config_func.asm):00083         
                      (  config_func.asm):00084         ;
                      (  config_func.asm):00085         ; Get our config and set system var.
                      (  config_func.asm):00086         ;
EC72                  (  config_func.asm):00087         GetConfig
EC72 8DE6             (  config_func.asm):00088                 bsr     GetDefCFGinA            ; get default config
EC74 9776             (  config_func.asm):00089                         sta             <CFGByte                                ; save it in ram
EC76 39               (  config_func.asm):00090                 rts
                      (  config_func.asm):00091         
                      (  config_func.asm):00092         ; Check if we are running on a Dragon or CoCo by looking at the ROM select bit
                      (  config_func.asm):00093         ; returns 1 if Dragon, 2 if CoCo
EC77                  (  config_func.asm):00094         GetPlatform
EC77 BDE020           (  config_func.asm):00095                         jsr             MMC_GetRAMCTRL                  ; Get ram control reg
                      (  config_func.asm):00096         ;               lda             D_RAM_CTRL              ; Get ram control reg
EC7A 8408             (  config_func.asm):00097                         anda    #D_ROM_A14                              ; check rom sel bit
EC7C 2603             (  config_func.asm):00098                         bne             GetPlatformCoCo                 ; CoCo : exit
EC7E 8601             (  config_func.asm):00099                         lda             #PLAT_DRAGON                    ; Flag Dragon
EC80 39               (  config_func.asm):00100                         rts
                      (  config_func.asm):00101                                 
EC81                  (  config_func.asm):00102         GetPlatformCoCo
EC81 8602             (  config_func.asm):00103                         lda             #PLAT_COCO                              ; Flag CoCo
EC83 39               (  config_func.asm):00104                         rts
                      (  config_func.asm):00105         
                      (  config_func.asm):00106                         endc
                      (  config_func.asm):00107                         
EC84                  (  config_func.asm):00108         __config_func_end
                      (  config_func.asm):00109         
                      (    DragonMMC.asm):00675                         use             mmc_func.asm
                      (     mmc_func.asm):00001         ;
                      (     mmc_func.asm):00002         ; MMC functions.
                      (     mmc_func.asm):00003         ;
                      (     mmc_func.asm):00004         ; 2011-06-13 Phill Harvey-Smith.
                      (     mmc_func.asm):00005         ;
                      (     mmc_func.asm):00006         ; Define MINIMUM to exclude code not needed by FLASH
                      (     mmc_func.asm):00007         ;
                      (     mmc_func.asm):00008         
                      (     mmc_func.asm):00009         ;
                      (     mmc_func.asm):00010         ; Note some routines make calls / returns into the Dragon and CoCo roms.
                      (     mmc_func.asm):00011         ; Please remember to define them so they assemble correctly on *BOTH* 
                      (     mmc_func.asm):00012         ; machines.
                      (     mmc_func.asm):00013         ; 
                      (     mmc_func.asm):00014         
                      (     mmc_func.asm):00015         ;
                      (     mmc_func.asm):00016         ; **** NOTE ****
                      (     mmc_func.asm):00017         ;
                      (     mmc_func.asm):00018         ; Send CMD_INIT_READ with MMC_sendCmdRaw *NOT* MMC_SendCmd
                      (     mmc_func.asm):00019         ;
                      (     mmc_func.asm):00020         
EC84                  (     mmc_func.asm):00021         __mmc_func
                      (     mmc_func.asm):00022         
                      (     mmc_func.asm):00023                         ifdef   Dragon
EC84                  (     mmc_func.asm):00024         CasRDCksum              EQU             $B972                           
EC84                  (     mmc_func.asm):00025         CasWRCksum              EQU             $B9C9
                      (     mmc_func.asm):00026                         else
     A73B             (     mmc_func.asm):00027         CasRDCksum              EQU             $A73B
     A824             (     mmc_func.asm):00028         CasWRCksum              EQU             $A824
                      (     mmc_func.asm):00029                         endc
                      (     mmc_func.asm):00030         
                      (     mmc_func.asm):00031         ; Moved to mmc_simple_func.asm :
                      (     mmc_func.asm):00032         ;
                      (     mmc_func.asm):00033         ; MMC_SendCommand
                      (     mmc_func.asm):00034         ; MMC_SendCommandRaw
                      (     mmc_func.asm):00035         ; MMC_WaitNotBusy
                      (     mmc_func.asm):00036         ; MMC_WaitPutLatchRead
                      (     mmc_func.asm):00037                         
                      (     mmc_func.asm):00038         ;
                      (     mmc_func.asm):00039         ; Init buffer write
                      (     mmc_func.asm):00040         ;
EC84                  (     mmc_func.asm):00041         MMC_InitSendBytes
EC84 3402             (     mmc_func.asm):00042                         pshs    a
EC86 8621             (     mmc_func.asm):00043                         lda             #CMD_INIT_WRITE                 ; Write bytes
EC88 BDE00E           (     mmc_func.asm):00044                         jsr             MMC_SendCmd                             ; send the command
EC8B 3582             (     mmc_func.asm):00045                         puls    a,pc
                      (     mmc_func.asm):00046                         
                      (     mmc_func.asm):00047                         ifne    0
                      (     mmc_func.asm):00048         ;
                      (     mmc_func.asm):00049         ; Init write buffer and send B bytes from X to MMC 
                      (     mmc_func.asm):00050         ;
                      (     mmc_func.asm):00051         
EC8D                  (     mmc_func.asm):00052         MMC_StartSendBBytes
                      (     mmc_func.asm):00053                         bsr             MMC_InitSendBytes
                      (     mmc_func.asm):00054                         endc
                      (     mmc_func.asm):00055                         
                      (     mmc_func.asm):00056         ;
                      (     mmc_func.asm):00057         ; Send B bytes pointed to by X to the WRITE_DATA_REG
                      (     mmc_func.asm):00058         ;
EC8D                  (     mmc_func.asm):00059         MMC_SendBBytes
EC8D 3416             (     mmc_func.asm):00060                         pshs    d,x
EC8F 5D               (     mmc_func.asm):00061                 tstb                            ; Is b zero ?
EC90 2707             (     mmc_func.asm):00062                 beq     MMC_SendBBytesExit      ; yep : exit
                      (     mmc_func.asm):00063                         
EC92                  (     mmc_func.asm):00064         MMC_SendBBytesLoop
EC92 A680             (     mmc_func.asm):00065                 lda             ,x+                                             ; get a byte
                      (     mmc_func.asm):00066         
EC94 8D2F             (     mmc_func.asm):00067                         bsr             MMC_WaitPutRead                 ; send byte, wait for AVR to read it
                      (     mmc_func.asm):00068         
EC96 5A               (     mmc_func.asm):00069                         decb                                                    ; decrement count
EC97 26F9             (     mmc_func.asm):00070                         bne             MMC_SendBBytesLoop              ; more : loop again
                      (     mmc_func.asm):00071         
EC99                  (     mmc_func.asm):00072         MMC_SendBBytesExit
EC99 3596             (     mmc_func.asm):00073                         puls    d,x,pc                                  ; restore and return
                      (     mmc_func.asm):00074                 
                      (     mmc_func.asm):00075         ;
                      (     mmc_func.asm):00076         ; Send U bytes pointed to by X to the WRITE_DATA_REG
                      (     mmc_func.asm):00077         ;       
                      (     mmc_func.asm):00078                 
EC9B                  (     mmc_func.asm):00079         MMC_SendUBytes
EC9B 3456             (     mmc_func.asm):00080                         pshs    u,d,x
                      (     mmc_func.asm):00081                 
EC9D                  (     mmc_func.asm):00082         MMC_SendUBytesLoop        
EC9D 11830000         (     mmc_func.asm):00083                 cmpu    #$0000                  ; U already zero?
ECA1 2708             (     mmc_func.asm):00084                 beq     MMC_SendUBytesExit      ; yep : exit
                      (     mmc_func.asm):00085                 
ECA3 A680             (     mmc_func.asm):00086                         lda             ,x+                                             ; get a byte
                      (     mmc_func.asm):00087         
ECA5 8D1E             (     mmc_func.asm):00088                         bsr             MMC_WaitPutRead                 ; send byte, wait for AVR to read it
                      (     mmc_func.asm):00089         
ECA7 335F             (     mmc_func.asm):00090                         leau    -1,u                                    ; decrement count
ECA9 20F2             (     mmc_func.asm):00091                         bra             MMC_SendUBytesLoop              ; more : loop again
                      (     mmc_func.asm):00092         
ECAB                  (     mmc_func.asm):00093         MMC_SendUBytesExit
ECAB 35D6             (     mmc_func.asm):00094                 puls    u,d,x,pc
                      (     mmc_func.asm):00095         ;
                      (     mmc_func.asm):00096         ; Init buffer and write B bytes from X, and terminate with 0 byte 
                      (     mmc_func.asm):00097         ;       
                      (     mmc_func.asm):00098         ; MMC_Sendname2 differs from MMC_Sendname, in that it assumes that a write 
                      (     mmc_func.asm):00099         ; bytes command has already been written, for example if parameters have been 
                      (     mmc_func.asm):00100         ; written before the filename
                      (     mmc_func.asm):00101         ;
ECAD                  (     mmc_func.asm):00102         MMC_SendName
ECAD 8DD5             (     mmc_func.asm):00103                         bsr             MMC_InitSendBytes               ; start sending bytes
                      (     mmc_func.asm):00104         
ECAF                  (     mmc_func.asm):00105         MMC_SendName2
ECAF 3402             (     mmc_func.asm):00106                         pshs    a
ECB1 8DDA             (     mmc_func.asm):00107                         bsr             MMC_SendBBytes                  ; Send the bytes
                      (     mmc_func.asm):00108                         
ECB3 8600             (     mmc_func.asm):00109                         lda             #0                                              ; Send terminator
ECB5 8D0E             (     mmc_func.asm):00110                         bsr             MMC_WaitPutRead                 ; send byte, wait for AVR to read it
ECB7 3582             (     mmc_func.asm):00111                         puls    a,pc                                    ; restore and return
                      (     mmc_func.asm):00112                 
                      (     mmc_func.asm):00113         ;
                      (     mmc_func.asm):00114         ; Init buffer and write bytes from X, till a zero terminator reached.
                      (     mmc_func.asm):00115         ; does *NOT* send the zero terminator
                      (     mmc_func.asm):00116         ;
                      (     mmc_func.asm):00117         
ECB9                  (     mmc_func.asm):00118         MMC_SendTillZero
ECB9 8DC9             (     mmc_func.asm):00119                         bsr             MMC_InitSendBytes               ; start sending bytes
                      (     mmc_func.asm):00120         
ECBB                  (     mmc_func.asm):00121         MMC_SendTillZeroLoop
ECBB A680             (     mmc_func.asm):00122                 lda     ,x+                     ; get a byte
ECBD 4D               (     mmc_func.asm):00123                 tsta                            ; Zero?
ECBE 2704             (     mmc_func.asm):00124                 beq     MMC_SendTillZeroExit    ; yep : stop sending
                      (     mmc_func.asm):00125                 
ECC0 8D03             (     mmc_func.asm):00126                 bsr     MMC_WaitPutRead                 ; send byte, wait for AVR to read it
ECC2 20F7             (     mmc_func.asm):00127                 bra     MMC_SendTillZeroLoop
                      (     mmc_func.asm):00128         
ECC4                  (     mmc_func.asm):00129         MMC_SendTillZeroExit
ECC4 39               (     mmc_func.asm):00130                 rts
                      (     mmc_func.asm):00131                 
                      (     mmc_func.asm):00132                         
                      (     mmc_func.asm):00133         ;               bra             MMC_WaitRead                    ; and wait for it to be read
                      (     mmc_func.asm):00134         ;
                      (     mmc_func.asm):00135         ; MMC_WaitPutRead Send a byte in a to the AVR DATA_REG and wait for it to read it
                      (     mmc_func.asm):00136         ;
                      (     mmc_func.asm):00137         
ECC5                  (     mmc_func.asm):00138         MMC_WaitPutRead 
ECC5 B7FF52           (     mmc_func.asm):00139                         sta             D_WRITE_DATA_REG                ; send it, and fall through.....
                      (     mmc_func.asm):00140         
                      (     mmc_func.asm):00141         ;
                      (     mmc_func.asm):00142         ; MMC_WaitRead : waits for the AVR to read byte
                      (     mmc_func.asm):00143         ;
ECC8                  (     mmc_func.asm):00144         MMC_WaitRead
                      (     mmc_func.asm):00145                 ifndef  EMULATE
                      (     mmc_func.asm):00146         
ECC8                  (     mmc_func.asm):00147         MMC_WaitReadLoop
                      (     mmc_func.asm):00148                         lda             D_STATUS_REG
                      (     mmc_func.asm):00149         ;               anda    #STATUS_FLAG_READ               ; Has it been read yet ?
                      (     mmc_func.asm):00150         ;               bne             MMC_WaitReadLoop                ; no : keep waiting
                      (     mmc_func.asm):00151                 endc
ECC8 39               (     mmc_func.asm):00152                         rts
                      (     mmc_func.asm):00153         
                      (     mmc_func.asm):00154         ;
                      (     mmc_func.asm):00155         ; MMC_WaitWritten, waits for the AVR to write a byte
                      (     mmc_func.asm):00156         ;
ECC9                  (     mmc_func.asm):00157         MMC_WaitWritten
                      (     mmc_func.asm):00158                 ifndef  EMULATE
                      (     mmc_func.asm):00159                 
ECC9                  (     mmc_func.asm):00160         MMC_WaitWrittenLoop
                      (     mmc_func.asm):00161                         lda             D_STATUS_REG
                      (     mmc_func.asm):00162         ;               anda    #STATUS_FLAG_WRITTEN    ; Written flag is it set ?
                      (     mmc_func.asm):00163         ;               beq             MMC_WaitWrittenLoop                     ; no : keep waiting
                      (     mmc_func.asm):00164                 endc
ECC9 39               (     mmc_func.asm):00165                         rts
                      (     mmc_func.asm):00166         
                      (     mmc_func.asm):00167         ;
                      (     mmc_func.asm):00168         ; MMC_WaitGetWritten, wait for the AVR to write a byte, return it in a
                      (     mmc_func.asm):00169         ;
ECCA                  (     mmc_func.asm):00170         MMC_WaitGetWritten
ECCA 8DFD             (     mmc_func.asm):00171                         bsr             MMC_WaitWritten                 ; Wait for byte
ECCC B6FF52           (     mmc_func.asm):00172                         lda             D_READ_DATA_REG                 ; get byte
ECCF 39               (     mmc_func.asm):00173                         rts
                      (     mmc_func.asm):00174         
                      (     mmc_func.asm):00175                         ifndef  MINIMUM
                      (     mmc_func.asm):00176                         ifne    0
                      (     mmc_func.asm):00177         ;
                      (     mmc_func.asm):00178         ; MMC_WaitGetWrittenReturn, wait for the AVR to write a byte, return it to basic
                      (     mmc_func.asm):00179         ;
                      (     mmc_func.asm):00180         
ECD0                  (     mmc_func.asm):00181         MMC_WaitGetWrittenReturn
                      (     mmc_func.asm):00182                         bsr             MMC_WaitWritten                 ; Wait for byte
                      (     mmc_func.asm):00183                         ldb             D_READ_DATA_REG                 ; get byte
                      (     mmc_func.asm):00184                         jmp             VarAssign8Bit                   ; return it to basic
                      (     mmc_func.asm):00185         
                      (     mmc_func.asm):00186                         endc
                      (     mmc_func.asm):00187                         endc
                      (     mmc_func.asm):00188         ;
                      (     mmc_func.asm):00189         ; MMC_CloseFile : close current file
                      (     mmc_func.asm):00190         ;               
ECD0                  (     mmc_func.asm):00191         MMC_CloseFile
ECD0 8600             (     mmc_func.asm):00192                         lda             #CAS_FILE                               ; file id of cas file
ECD2 BDE01B           (     mmc_func.asm):00193                         jsr             MMC_WaitPutLatchRead    ; send it to latch register
                      (     mmc_func.asm):00194                 
ECD5 8610             (     mmc_func.asm):00195                         lda             #CMD_FILE_CLOSE                 ; Close the file
ECD7 17F334           (     mmc_func.asm):00196                         lbsr    MMC_SendCmd                             ; send the command
ECDA 39               (     mmc_func.asm):00197                         rts
                      (     mmc_func.asm):00198         
                      (     mmc_func.asm):00199                         
                      (     mmc_func.asm):00200         ;
                      (     mmc_func.asm):00201         ; MMC_ReadFByte : Read a byte from a file and return it in a
                      (     mmc_func.asm):00202         ;
ECDB                  (     mmc_func.asm):00203         MMC_ReadFByte
ECDB 8601             (     mmc_func.asm):00204                         lda             #1                                              ; One byte
ECDD 8D02             (     mmc_func.asm):00205                         bsr             MMC_ReadFCommon
ECDF 20E9             (     mmc_func.asm):00206                         bra             MMC_WaitGetWritten              ; get the byte, returned in a
                      (     mmc_func.asm):00207         
ECE1                  (     mmc_func.asm):00208         MMC_ReadFCommon
ECE1 3402             (     mmc_func.asm):00209                         pshs    a                                               ; save byte count
ECE3 8600             (     mmc_func.asm):00210                         lda             #CAS_FILE                               ; file id of cas file
ECE5 BDE01B           (     mmc_func.asm):00211                         jsr             MMC_WaitPutLatchRead    ; send it to latch register
ECE8 3502             (     mmc_func.asm):00212                         puls    a                                               ; restore byte count
                      (     mmc_func.asm):00213                         
ECEA BDE01B           (     mmc_func.asm):00214                         jsr             MMC_WaitPutLatchRead    ; send it to latch register
                      (     mmc_func.asm):00215                         
ECED 8622             (     mmc_func.asm):00216                         lda     #CMD_READ_BYTES                 ; Read bytes from file
ECEF 17F31C           (     mmc_func.asm):00217                         lbsr    MMC_SendCmd                             ; send the command
                      (     mmc_func.asm):00218                         
ECF2 8620             (     mmc_func.asm):00219                         lda             #CMD_INIT_READ                  ; Read the byte
ECF4 17F320           (     mmc_func.asm):00220                         lbsr    MMC_SendCmdRaw                  
ECF7 39               (     mmc_func.asm):00221                         rts
                      (     mmc_func.asm):00222                         
                      (     mmc_func.asm):00223         ;
                      (     mmc_func.asm):00224         ; Read a block from open cas file, length in 
                      (     mmc_func.asm):00225         ; Entry :
                      (     mmc_func.asm):00226         ;       CasBlockLen     = size of block in bytes $00..$FF
                      (     mmc_func.asm):00227         ;       X                               = Pointer to buffer to recieve bytes
                      (     mmc_func.asm):00228         ;
                      (     mmc_func.asm):00229         ; Exit :
                      (     mmc_func.asm):00230         ;       X                               = Updated to point to byte after last byte read.
                      (     mmc_func.asm):00231         ;       a                               = error code, $00=none, $01=Csum error, $02=invalid dest addr
                      (     mmc_func.asm):00232         ;       CasCkSum                = Checksum of block
                      (     mmc_func.asm):00233         ;       
                      (     mmc_func.asm):00234         ;
                      (     mmc_func.asm):00235         
                      (     mmc_func.asm):00236                         ifndef  MINIMUM
                      (     mmc_func.asm):00237         
ECF8                  (     mmc_func.asm):00238         MMC_ReadFBlock
ECF8 8D07             (     mmc_func.asm):00239                         bsr             MMC_ReadFileBlockCas    ; read the block
ECFA 7EA73B           (     mmc_func.asm):00240                         jmp             CasRDCksum                              ; and back to the rom for the checksum
                      (     mmc_func.asm):00241         
                      (     mmc_func.asm):00242                         endc
                      (     mmc_func.asm):00243         ;               
                      (     mmc_func.asm):00244         ; Read a block pointed to by X from MMC 
                      (     mmc_func.asm):00245         ;
                      (     mmc_func.asm):00246         ; Entry :
                      (     mmc_func.asm):00247         ;       b                               = size of block in bytes $00..$FF
                      (     mmc_func.asm):00248         ;       X                               = Pointer to buffer to recieve bytes
                      (     mmc_func.asm):00249         ;
                      (     mmc_func.asm):00250         ; Exit :
                      (     mmc_func.asm):00251         ;       X                               = Updated to point to byte after last byte written.
                      (     mmc_func.asm):00252         ;
                      (     mmc_func.asm):00253         
ECFD                  (     mmc_func.asm):00254         MMC_ReadFileBlock
ECFD D77D             (     mmc_func.asm):00255                         stb             <CasBlockLen            ; Save block length
ECFF D781             (     mmc_func.asm):00256                         stb             <CasIOErrorCode         ; running count
                      (     mmc_func.asm):00257                         
ED01                  (     mmc_func.asm):00258         MMC_ReadFileBlockCas
ED01 967D             (     mmc_func.asm):00259                         lda             <CasBlockLen            ; get length of block
ED03 8DDC             (     mmc_func.asm):00260                         bsr             MMC_ReadFCommon         ; Set the bytes
                      (     mmc_func.asm):00261                         
ED05                  (     mmc_func.asm):00262         MMC_ReadFBlockLoop
ED05 17FFC2           (     mmc_func.asm):00263                         lbsr    MMC_WaitGetWritten      ; get the byte, returned in a
ED08 A784             (     mmc_func.asm):00264                         sta             ,x                                      ; save in buffer
ED0A A180             (     mmc_func.asm):00265                         cmpa    ,x+                                     ; Did it save ok ? 
ED0C 2612             (     mmc_func.asm):00266                         bne             MMC_ReadFBlockError     ; Yep eat rest of read and return error
ED0E 9B80             (     mmc_func.asm):00267                         adda    <CasCkSum                       ; add read byte to checksum
ED10 9780             (     mmc_func.asm):00268                 sta     <CasCkSum                       
ED12 0A81             (     mmc_func.asm):00269                 dec     <CasIOErrorCode         ; decrement byte count
ED14 26EF             (     mmc_func.asm):00270                         bne             MMC_ReadFBlockLoop      ; Keep going if more bytes
                      (     mmc_func.asm):00271         
ED16 39               (     mmc_func.asm):00272                         rts
                      (     mmc_func.asm):00273                 
ED17 9080             (     mmc_func.asm):00274                         suba    <CasCkSum                       ; check against calculated checksum
ED19 2602             (     mmc_func.asm):00275                         bne             MMC_ReadFBlockExit
                      (     mmc_func.asm):00276                 
ED1B 8601             (     mmc_func.asm):00277                         lda             #$01                            ; Flag error
                      (     mmc_func.asm):00278                 
ED1D                  (     mmc_func.asm):00279         MMC_ReadFBlockExit
ED1D 9781             (     mmc_func.asm):00280                         sta             <CasIOErrorCode         ; Save error code
ED1F 39               (     mmc_func.asm):00281                         rts     
                      (     mmc_func.asm):00282         
ED20                  (     mmc_func.asm):00283         MMC_ReadFBlockError
ED20 8602             (     mmc_func.asm):00284                         lda             #$02                            ; Flag error    
ED22 20F9             (     mmc_func.asm):00285                         bra             MMC_ReadFBlockExit      
                      (     mmc_func.asm):00286                         
                      (     mmc_func.asm):00287         
                      (     mmc_func.asm):00288                         ifndef  MINIMUM
                      (     mmc_func.asm):00289         ;               
                      (     mmc_func.asm):00290         ; Read a block pointed to by X from MMC, does not use tape vars like MMC_ReadFileBlock 
                      (     mmc_func.asm):00291         ;
                      (     mmc_func.asm):00292         ; Entry :
                      (     mmc_func.asm):00293         ;       b                               = size of block in bytes $00..$FF
                      (     mmc_func.asm):00294         ;       X                               = Pointer to buffer to recieve bytes
                      (     mmc_func.asm):00295         ;
                      (     mmc_func.asm):00296         ; Exit :
                      (     mmc_func.asm):00297         ;       X                               = Updated to point to byte after last byte written.
                      (     mmc_func.asm):00298         ;
                      (     mmc_func.asm):00299         
ED24                  (     mmc_func.asm):00300         MMC_ReadFileBlockRaw
ED24 3404             (     mmc_func.asm):00301                 pshs    b                   ; save byte count                       
ED26 1E98             (     mmc_func.asm):00302                 exg     b,a                 ; get byte count
ED28 8DB7             (     mmc_func.asm):00303                 bsr     MMC_ReadFCommon     ; Tell AVR to read bytes & begin reading
                      (     mmc_func.asm):00304         
ED2A 3504             (     mmc_func.asm):00305                 puls    b                   ; restore byte count
ED2C                  (     mmc_func.asm):00306         MMC_ReadFileBlockRawLoop
ED2C 17FF9B           (     mmc_func.asm):00307                         lbsr    MMC_WaitGetWritten      ; get the byte, returned in a
ED2F A780             (     mmc_func.asm):00308                         sta             ,x+                             ; save in buffer
ED31 5A               (     mmc_func.asm):00309                 decb                        ; decrement byte count
ED32 26F8             (     mmc_func.asm):00310                         bne             MMC_ReadFileBlockRawLoop ; Keep going if more bytes
                      (     mmc_func.asm):00311         
ED34 39               (     mmc_func.asm):00312                         rts
                      (     mmc_func.asm):00313         ;
                      (     mmc_func.asm):00314         ; Write a byte to open cas file, from a
                      (     mmc_func.asm):00315         ;
                      (     mmc_func.asm):00316                 
ED35                  (     mmc_func.asm):00317         MMC_WriteFByte
ED35 3402             (     mmc_func.asm):00318                         pshs    a
ED37 8621             (     mmc_func.asm):00319                         lda             #CMD_INIT_WRITE         ; Initiialise write
ED39 17F2D2           (     mmc_func.asm):00320                         lbsr    MMC_SendCmd                     ; send command
ED3C A6E4             (     mmc_func.asm):00321                         lda             ,s                                      ; peek a back off stack 
                      (     mmc_func.asm):00322                         
ED3E 17FF84           (     mmc_func.asm):00323                         lbsr    MMC_WaitPutRead         ; send byte to AVR
                      (     mmc_func.asm):00324                         
ED41 8600             (     mmc_func.asm):00325                         lda             #CAS_FILE                               ; file id of cas file
ED43 17F2D5           (     mmc_func.asm):00326                         lbsr    MMC_WaitPutLatchRead    ; send it to latch register
                      (     mmc_func.asm):00327                         
ED46 8601             (     mmc_func.asm):00328                         lda             #1                                      ; Write 1 byte
ED48 17F2D0           (     mmc_func.asm):00329                         lbsr    MMC_WaitPutLatchRead    ; send it to latch register
                      (     mmc_func.asm):00330                         
ED4B 8623             (     mmc_func.asm):00331                         lda             #CMD_WRITE_BYTES        ; Write bytes
ED4D 17F2BE           (     mmc_func.asm):00332                         lbsr    MMC_SendCmd                     ; send command
                      (     mmc_func.asm):00333                         
ED50 3582             (     mmc_func.asm):00334                         puls    a,pc                            ; restore and return
                      (     mmc_func.asm):00335         
                      (     mmc_func.asm):00336         ;
                      (     mmc_func.asm):00337         ; Read 2 bytes from file and into D
                      (     mmc_func.asm):00338         ;
ED52                  (     mmc_func.asm):00339         MMC_ReadDFile        
ED52 8602             (     mmc_func.asm):00340                 lda     #2                  ; 2 bytes
ED54 8D8B             (     mmc_func.asm):00341                 bsr     MMC_ReadFCommon     ; go read them 
                      (     mmc_func.asm):00342         ;
                      (     mmc_func.asm):00343         ; Fetch two bytes into D register, assumes CMD_INIT_READ already reading bytes
                      (     mmc_func.asm):00344         ; 
                      (     mmc_func.asm):00345                         
ED56                  (     mmc_func.asm):00346         MMC_ReadD
ED56 17FF71           (     mmc_func.asm):00347                 lbsr    MMC_WaitGetWritten  ; get msb
ED59 1E89             (     mmc_func.asm):00348                 exg     a,b                 ; swap them
ED5B 17FF6C           (     mmc_func.asm):00349                 lbsr    MMC_WaitGetWritten  ; get lsb
ED5E 1E89             (     mmc_func.asm):00350                 exg     a,b                 ; swap them back
ED60 39               (     mmc_func.asm):00351                 rts
                      (     mmc_func.asm):00352         
                      (     mmc_func.asm):00353         ;
                      (     mmc_func.asm):00354         ; Send D register, assumes CMD_INIT_WRITE already sending bytes
                      (     mmc_func.asm):00355         ; 
                      (     mmc_func.asm):00356                         
ED61                  (     mmc_func.asm):00357         MMC_WriteD
ED61 3406             (     mmc_func.asm):00358                 pshs    d
ED63 17FF5F           (     mmc_func.asm):00359                 lbsr    MMC_WaitPutRead     ; send msb
ED66 1E89             (     mmc_func.asm):00360                 exg     a,b                 ; swap them
ED68 17FF5A           (     mmc_func.asm):00361                 lbsr    MMC_WaitPutRead     ; send lsb
ED6B 3586             (     mmc_func.asm):00362                 puls    d,pc
                      (     mmc_func.asm):00363                 
                      (     mmc_func.asm):00364                 
                      (     mmc_func.asm):00365         ;
                      (     mmc_func.asm):00366         ; Write a block pointed to by X to MMC (tape emulation)
                      (     mmc_func.asm):00367         ;
                      (     mmc_func.asm):00368         ; Entry :
                      (     mmc_func.asm):00369         ;       CasBlockLen     = size of block in bytes $00..$FF
                      (     mmc_func.asm):00370         ;       CasIOErrorCode  = CasBlockLen
                      (     mmc_func.asm):00371         ;       X                               = Pointer to buffer to recieve bytes
                      (     mmc_func.asm):00372         ;
                      (     mmc_func.asm):00373         ; Exit :
                      (     mmc_func.asm):00374         ;       X                               = Updated to point to byte after last byte written.
                      (     mmc_func.asm):00375         ;
                      (     mmc_func.asm):00376         
ED6D                  (     mmc_func.asm):00377         MMC_WriteFBlock
ED6D 8D07             (     mmc_func.asm):00378                         bsr             MMC_WriteFileBlockCas   ; Write it
ED6F 7EA824           (     mmc_func.asm):00379                         jmp             CasWRCksum                              ; Jump back to rom
                      (     mmc_func.asm):00380         
                      (     mmc_func.asm):00381         ;               
                      (     mmc_func.asm):00382         ; Write a block pointed to by X to MMC 
                      (     mmc_func.asm):00383         ;
                      (     mmc_func.asm):00384         ; Entry :
                      (     mmc_func.asm):00385         ;       b                               = size of block in bytes $00..$FF
                      (     mmc_func.asm):00386         ;       X                               = Pointer to buffer to recieve bytes
                      (     mmc_func.asm):00387         ;
                      (     mmc_func.asm):00388         ; Exit :
                      (     mmc_func.asm):00389         ;       X                               = Updated to point to byte after last byte written.
                      (     mmc_func.asm):00390         ;
                      (     mmc_func.asm):00391         
ED72                  (     mmc_func.asm):00392         MMC_WriteFileBlock
ED72 D77D             (     mmc_func.asm):00393                         stb             <CasBlockLen            ; Initialise block len / count
ED74 D781             (     mmc_func.asm):00394                         stb             <CasIOErrorCode
                      (     mmc_func.asm):00395                         
ED76                  (     mmc_func.asm):00396         MMC_WriteFileBlockCas
ED76 8621             (     mmc_func.asm):00397                         lda             #CMD_INIT_WRITE         ; Initiialise write
ED78 17F293           (     mmc_func.asm):00398                         lbsr    MMC_SendCmd                     ; send command
ED7B                  (     mmc_func.asm):00399         MMC_WriteFBlockLoop
                      (     mmc_func.asm):00400         ;               com             $401
ED7B A680             (     mmc_func.asm):00401                         lda             ,x+                                     ; get byte to write
ED7D 17FF45           (     mmc_func.asm):00402                         lbsr    MMC_WaitPutRead         ; send byte to AVR
                      (     mmc_func.asm):00403                 
ED80 0A81             (     mmc_func.asm):00404                         dec     <CasIOErrorCode         ; Decrement count
ED82 26F7             (     mmc_func.asm):00405                         bne             MMC_WriteFBlockLoop     ; More ? yep : keep going
                      (     mmc_func.asm):00406                         
ED84 967D             (     mmc_func.asm):00407                         lda             <CasBlockLen            ; get length of block
ED86                  (     mmc_func.asm):00408         MMC_WriteAFromAVRBuf
ED86 3402             (     mmc_func.asm):00409                         pshs    a                                               ; save byte count
ED88 8600             (     mmc_func.asm):00410                         lda             #CAS_FILE                               ; file id of cas file
ED8A 17F28E           (     mmc_func.asm):00411                         lbsr    MMC_WaitPutLatchRead    ; send it to latch register
ED8D 3502             (     mmc_func.asm):00412                         puls    a                                               ; restore byte count
                      (     mmc_func.asm):00413                         
ED8F 17F289           (     mmc_func.asm):00414                         lbsr    MMC_WaitPutLatchRead    ; send it to latch register
                      (     mmc_func.asm):00415                                         
ED92 8623             (     mmc_func.asm):00416                         lda             #CMD_WRITE_BYTES        ; Write it to the file
ED94 17F277           (     mmc_func.asm):00417                         lbsr    MMC_SendCmd                     ; send it
ED97 39               (     mmc_func.asm):00418                         rts     
                      (     mmc_func.asm):00419         
                      (     mmc_func.asm):00420         ;
                      (     mmc_func.asm):00421         ; MMC_SaveFile, save to the open file 
                      (     mmc_func.asm):00422         ; 
                      (     mmc_func.asm):00423         ; Entry :
                      (     mmc_func.asm):00424         ;       u                               = Pointer to the file header for the file to save.
                      (     mmc_func.asm):00425         ;
                      (     mmc_func.asm):00426         
ED98                  (     mmc_func.asm):00427         MMC_SaveFile
ED98 C609             (     mmc_func.asm):00428                         ldb             #FileHeadLen            ; Header length
ED9A 30C4             (     mmc_func.asm):00429                         leax    ,u                                      ; point to header
ED9C 8DD4             (     mmc_func.asm):00430                         bsr             MMC_WriteFileBlock      ; Write the block
                      (     mmc_func.asm):00431         
ED9E AE42             (     mmc_func.asm):00432                         ldx             HdrLoad,u                       ; Get load address
                      (     mmc_func.asm):00433         
EDA0                  (     mmc_func.asm):00434         MMC_SaveFileLoop        
EDA0 EC44             (     mmc_func.asm):00435                         ldd             HdrLen,u                        ; Get file length
EDA2 10830100         (     mmc_func.asm):00436                         cmpd    #$100                           ; > 256 bytes ?
EDA6 250A             (     mmc_func.asm):00437                         blo             MMC_SaveTail            ; no : last block
                      (     mmc_func.asm):00438         
EDA8 830100           (     mmc_func.asm):00439                         subd    #$100                           ; decrement length
EDAB ED44             (     mmc_func.asm):00440                         std             HdrLen,u                        ; update
                      (     mmc_func.asm):00441                         
EDAD 5F               (     mmc_func.asm):00442                         clrb                                            ; flag 256 bytes
EDAE 8DC2             (     mmc_func.asm):00443                         bsr             MMC_WriteFileBlock      ; Write the block
EDB0 20EE             (     mmc_func.asm):00444                         bra             MMC_SaveFileLoop        ; Do next block 
                      (     mmc_func.asm):00445                         
EDB2                  (     mmc_func.asm):00446         MMC_SaveTail
EDB2 5D               (     mmc_func.asm):00447                         tstb                                            ; any more bytes ?
EDB3 2702             (     mmc_func.asm):00448                         beq             MMC_SaveFileExit        ; nope : exit
EDB5 8DBB             (     mmc_func.asm):00449                         bsr             MMC_WriteFileBlock      ; Write the block
                      (     mmc_func.asm):00450                                         
EDB7                  (     mmc_func.asm):00451         MMC_SaveFileExit
EDB7 4F               (     mmc_func.asm):00452                         clra    
EDB8 39               (     mmc_func.asm):00453                         rts
                      (     mmc_func.asm):00454                         
                      (     mmc_func.asm):00455         ;
                      (     mmc_func.asm):00456         ; MMC_LoadFile, load from the open file
                      (     mmc_func.asm):00457         ;
                      (     mmc_func.asm):00458         ; Entry :
                      (     mmc_func.asm):00459         ;       u       = Pointer to the file header for the file to load.
                      (     mmc_func.asm):00460         ; Exit :
                      (     mmc_func.asm):00461         ;       x       = pointer just beyond end of loaded buffer.
                      (     mmc_func.asm):00462         ;
                      (     mmc_func.asm):00463         
                      (     mmc_func.asm):00464         
EDB9                  (     mmc_func.asm):00465         MMC_LoadFile
EDB9 AE44             (     mmc_func.asm):00466                         ldx             HdrLen,u                        ; Get length
EDBB 3410             (     mmc_func.asm):00467                         pshs    x                                       ; save on stack
EDBD AE42             (     mmc_func.asm):00468                         ldx             HdrLoad,u                       ; get load address
EDBF 2002             (     mmc_func.asm):00469                         bra             MMC_LoadFileLoop        ; go do it
                      (     mmc_func.asm):00470         
                      (     mmc_func.asm):00471         ;
                      (     mmc_func.asm):00472         ; MMC_LoadFile2, load from the open file
                      (     mmc_func.asm):00473         ;
                      (     mmc_func.asm):00474         ; Entry :
                      (     mmc_func.asm):00475         ;   x   = Pointer to buffer to load file into
                      (     mmc_func.asm):00476         ;       u       = Bytes to read from the file.
                      (     mmc_func.asm):00477         ; Exit :
                      (     mmc_func.asm):00478         ;       x       = pointer just beyond end of loaded buffer.
                      (     mmc_func.asm):00479         ;
                      (     mmc_func.asm):00480         
EDC1                  (     mmc_func.asm):00481         MMC_LoadFile2
EDC1 3440             (     mmc_func.asm):00482                         pshs    u                                       ; save length   
                      (     mmc_func.asm):00483                         
EDC3                  (     mmc_func.asm):00484         MMC_LoadFileLoop
EDC3 ECE4             (     mmc_func.asm):00485                         ldd             ,s                                      ; Get length remaining
EDC5 10830100         (     mmc_func.asm):00486                         cmpd    #$100                           ; > 256 bytes ?
EDC9 250B             (     mmc_func.asm):00487                         blo             MMC_LoadTail            ; no : last block
                      (     mmc_func.asm):00488                         
EDCB 830100           (     mmc_func.asm):00489                         subd    #$100                           ; decrement remaining length
EDCE EDE4             (     mmc_func.asm):00490                         std             ,s                                      ; update
                      (     mmc_func.asm):00491                         
EDD0 5F               (     mmc_func.asm):00492                         clrb                                            ; flag 256 bytes
EDD1 17FF29           (     mmc_func.asm):00493                         lbsr    MMC_ReadFileBlock       ; read next block
EDD4 20ED             (     mmc_func.asm):00494                         bra             MMC_LoadFileLoop        ; do next block
                      (     mmc_func.asm):00495                         
EDD6                  (     mmc_func.asm):00496         MMC_LoadTail
EDD6 5D               (     mmc_func.asm):00497                         tstb                                            ; any more bytes ?
EDD7 2703             (     mmc_func.asm):00498                         beq             MMC_LoadFileExit        ; nope : exit
EDD9 17FF21           (     mmc_func.asm):00499                         lbsr    MMC_ReadFileBlock       ; load last block
                      (     mmc_func.asm):00500                         
EDDC                  (     mmc_func.asm):00501         MMC_LoadFileExit
EDDC 3262             (     mmc_func.asm):00502                         leas    2,s                                     ; drop saved count
EDDE 4F               (     mmc_func.asm):00503                         clra
EDDF 39               (     mmc_func.asm):00504                         rts
                      (     mmc_func.asm):00505         
                      (     mmc_func.asm):00506                 ifeq    1
                      (     mmc_func.asm):00507         ;
                      (     mmc_func.asm):00508         ; Send LBA to AVR
                      (     mmc_func.asm):00509         ;
EDE0                  (     mmc_func.asm):00510         MMC_SendLBA
                      (     mmc_func.asm):00511                         pshs    u,d
                      (     mmc_func.asm):00512                         lbsr    MMC_InitSendBytes       ; Begin sending bytes
                      (     mmc_func.asm):00513                         
                      (     mmc_func.asm):00514                         lbsr    MMC_WaitPutRead         ; send drive id it
                      (     mmc_func.asm):00515                         
                      (     mmc_func.asm):00516                         exg             u,d                                     ; get LSW of LBA
                      (     mmc_func.asm):00517                         exg             a,b                                     ; move lsb into a
                      (     mmc_func.asm):00518                         
                      (     mmc_func.asm):00519                         lbsr    MMC_WaitPutRead         ; send LSB of LSN
                      (     mmc_func.asm):00520                         
                      (     mmc_func.asm):00521                         exg             a,b                                     ; get next byte of LBA
                      (     mmc_func.asm):00522                         
                      (     mmc_func.asm):00523                         lbsr    MMC_WaitPutRead         ; send it
                      (     mmc_func.asm):00524                         
                      (     mmc_func.asm):00525                         exg             d,u                                     ; retrieve MSB
                      (     mmc_func.asm):00526                         
                      (     mmc_func.asm):00527                         exg             a,b                                     ; move lsb into a
                      (     mmc_func.asm):00528                         lbsr    MMC_WaitPutRead         ; send it
                      (     mmc_func.asm):00529         
                      (     mmc_func.asm):00530                         clra                                            ; msb of LSN always 0
                      (     mmc_func.asm):00531                         lbsr    MMC_WaitPutRead         ; send it
                      (     mmc_func.asm):00532         
                      (     mmc_func.asm):00533                         lda             #CMD_LOAD_PARAM         ; Tell AVR
                      (     mmc_func.asm):00534                         lbsr    MMC_SendCmd                     ; send command
                      (     mmc_func.asm):00535                         
                      (     mmc_func.asm):00536                         puls    u,d,pc                          ; restore / return
                      (     mmc_func.asm):00537                 
                      (     mmc_func.asm):00538                 endc
                      (     mmc_func.asm):00539                         
                      (     mmc_func.asm):00540         ;
                      (     mmc_func.asm):00541         ; MMC_ReadDOSSec,  Read an emulated dos sector
                      (     mmc_func.asm):00542         ; MMC_ReadDOSSec2  Read just the first two bytes, used by 'BOOT'
                      (     mmc_func.asm):00543         ;
                      (     mmc_func.asm):00544         ; Entry :
                      (     mmc_func.asm):00545         ;       A       = drive id
                      (     mmc_func.asm):00546         ;       X       = buffer
                      (     mmc_func.asm):00547         ;
                      (     mmc_func.asm):00548         ; Before calling :
                      (     mmc_func.asm):00549         ; Drive track should have been set with a call to MMC_SeekCheck
                      (     mmc_func.asm):00550         ; Head and Sector number should have been set with a call to MMC_SendHR
                      (     mmc_func.asm):00551         ;
                      (     mmc_func.asm):00552         ; Note for whatever path this code takes it should always pickup the
                      (     mmc_func.asm):00553         ; simulated WD error at the end
                      (     mmc_func.asm):00554         ;
                      (     mmc_func.asm):00555         
EDE0                  (     mmc_func.asm):00556         MMC_ReadDOSSec
                      (     mmc_func.asm):00557         ;        jsr     >CON_DumpRegs
EDE0 8D1F             (     mmc_func.asm):00558                         bsr             MMC_ReadDOSSecInit      ; init the read
EDE2 2B11             (     mmc_func.asm):00559                         bmi             MMC_ReadDOSSecEExit     ; Error : exit
                      (     mmc_func.asm):00560                         
EDE4 5F               (     mmc_func.asm):00561                         clrb                                            ; init count
EDE5 2006             (     mmc_func.asm):00562                         bra             MMC_ReadDOSSecLoopB     ; Go read the data
                      (     mmc_func.asm):00563         
EDE7                  (     mmc_func.asm):00564         MMC_ReadDOSSec2
EDE7 8D18             (     mmc_func.asm):00565                         bsr             MMC_ReadDOSSecInit      ; init the read
EDE9 2B0A             (     mmc_func.asm):00566                         bmi             MMC_ReadDOSSecEExit     ; Error : exit
EDEB C6FE             (     mmc_func.asm):00567                         ldb             #$FE                            ; init count, reads 2 bytes
                      (     mmc_func.asm):00568                 
EDED                  (     mmc_func.asm):00569         MMC_ReadDOSSecLoopB
                      (     mmc_func.asm):00570         ;               lbsr    ConWriteHexX
EDED                  (     mmc_func.asm):00571         MMC_ReadDOSSecLoop              
EDED 17FEDA           (     mmc_func.asm):00572                         lbsr    MMC_WaitGetWritten      ; wait for byte
EDF0 A780             (     mmc_func.asm):00573                         sta             ,x+                                     ; save in buffer
EDF2 5C               (     mmc_func.asm):00574                         incb                                            ; inc count
EDF3 26F8             (     mmc_func.asm):00575                         bne             MMC_ReadDOSSecLoop      ; not done, loop again
                      (     mmc_func.asm):00576                         
EDF5                  (     mmc_func.asm):00577         MMC_ReadDOSSecEExit
EDF5 8D33             (     mmc_func.asm):00578                         bsr             MMC_GetWDError
EDF7 39               (     mmc_func.asm):00579                         rts
                      (     mmc_func.asm):00580         
                      (     mmc_func.asm):00581         ;
                      (     mmc_func.asm):00582         ; Read the next dos sector, must be preceeded by a call to 
                      (     mmc_func.asm):00583         ; MMC_ReadDOSSec, that will correctly set the starting LSN and drive ID.
                      (     mmc_func.asm):00584         ;
                      (     mmc_func.asm):00585         ; Entry :
                      (     mmc_func.asm):00586         ;       X       = buffer
                      (     mmc_func.asm):00587         ;
                      (     mmc_func.asm):00588         
EDF8                  (     mmc_func.asm):00589         MMC_ReadNextDOSSec
EDF8 8D03             (     mmc_func.asm):00590                         bsr             MMC_ReadDOSSecInitNext  ; Init the read
EDFA 5F               (     mmc_func.asm):00591                         clrb                                            ; init count
EDFB 20F0             (     mmc_func.asm):00592                         bra             MMC_ReadDOSSecLoopB     ; Go read the data              
                      (     mmc_func.asm):00593         
EDFD                  (     mmc_func.asm):00594         MMC_ReadDOSSecInitNext
EDFD 864B             (     mmc_func.asm):00595                         lda             #CMD_READ_NEXT_IMG_SEC  ; read next sector
EDFF 2002             (     mmc_func.asm):00596                         bra             MMC_ReadDOSSecInit2
                      (     mmc_func.asm):00597         
EE01                  (     mmc_func.asm):00598         MMC_ReadDOSSecInit
EE01 8643             (     mmc_func.asm):00599                         lda             #CMD_READ_IMG_SEC       ; Read sector from AVR
EE03                  (     mmc_func.asm):00600         MMC_ReadDOSSecInit2             
EE03 17F208           (     mmc_func.asm):00601                         lbsr    MMC_SendCmd                     ; send command
EE06 2B05             (     mmc_func.asm):00602                         bmi             MMC_ReadDOSSecExit      ; if error handle it
                      (     mmc_func.asm):00603                         
EE08 8620             (     mmc_func.asm):00604                         lda             #CMD_INIT_READ          ; read the sector
EE0A 17F20A           (     mmc_func.asm):00605                         lbsr    MMC_SendCmdRaw          ; send command
                      (     mmc_func.asm):00606         
EE0D                  (     mmc_func.asm):00607         MMC_ReadDOSSecExit
EE0D 39               (     mmc_func.asm):00608                         rts
                      (     mmc_func.asm):00609         
                      (     mmc_func.asm):00610         ;
                      (     mmc_func.asm):00611         ; MMC_WriteDOSSec,  Read an emulated dos sector
                      (     mmc_func.asm):00612         ;
                      (     mmc_func.asm):00613         ; Entry :
                      (     mmc_func.asm):00614         ;       A       = drive id
                      (     mmc_func.asm):00615         ;       X       = buffer
                      (     mmc_func.asm):00616         ;
                      (     mmc_func.asm):00617         ; Before calling :
                      (     mmc_func.asm):00618         ; Drive track should have been set with a call to MMC_SeekCheck
                      (     mmc_func.asm):00619         ; Head and Sector number should have been set with a call to MMC_SendHR
                      (     mmc_func.asm):00620         ;
                      (     mmc_func.asm):00621         ; Note for whatever path this code takes it should always pickup the
                      (     mmc_func.asm):00622         ; simulated WD error at the end
                      (     mmc_func.asm):00623         ;
                      (     mmc_func.asm):00624         
EE0E                  (     mmc_func.asm):00625         MMC_WriteDOSSec
EE0E 8D14             (     mmc_func.asm):00626                         bsr             MMC_WriteDOSSecInit     ; init the write
EE10 25FB             (     mmc_func.asm):00627                         bcs             MMC_ReadDOSSecExit      ; Error : exit
                      (     mmc_func.asm):00628                         
EE12 3440             (     mmc_func.asm):00629                 pshs    u
EE14 CE0100           (     mmc_func.asm):00630                         ldu     #$100                           ; send 256 bytes
EE17 17FE81           (     mmc_func.asm):00631                         lbsr    MMC_SendUBytes          ; send 256 bytes from x
EE1A 3540             (     mmc_func.asm):00632                         puls    u
                      (     mmc_func.asm):00633                 
EE1C 8644             (     mmc_func.asm):00634                         lda             #CMD_WRITE_IMG_SEC      ; write the sector
EE1E 17F1ED           (     mmc_func.asm):00635                         lbsr    MMC_SendCmd
                      (     mmc_func.asm):00636         
EE21 8D07             (     mmc_func.asm):00637                         bsr             MMC_GetWDError          ; Get simulated WD error        
EE23 39               (     mmc_func.asm):00638                         rts
                      (     mmc_func.asm):00639         
                      (     mmc_func.asm):00640         
EE24                  (     mmc_func.asm):00641         MMC_WriteDOSSecInit
                      (     mmc_func.asm):00642         ;               bsr             MMC_SendLBA                     ; send LBA to AVR
                      (     mmc_func.asm):00643                         
EE24 8621             (     mmc_func.asm):00644                         lda             #CMD_INIT_WRITE         ; Prepare to send the data
EE26 17F1E5           (     mmc_func.asm):00645                         lbsr    MMC_SendCmd                     ; send command
EE29 39               (     mmc_func.asm):00646                         rts
                      (     mmc_func.asm):00647         
                      (     mmc_func.asm):00648         ;
                      (     mmc_func.asm):00649         ; Get the simulated WD17xx/WD27xx error from the AVR
                      (     mmc_func.asm):00650         ; simulated WD error returned in a
                      (     mmc_func.asm):00651         ;
EE2A                  (     mmc_func.asm):00652         MMC_GetWDError
EE2A 864A             (     mmc_func.asm):00653                         lda             #CMD_GET_FDC_STATUS     ; Get status
EE2C 17F1DF           (     mmc_func.asm):00654                         lbsr    MMC_SendCmd                     ; send command
EE2F 4D               (     mmc_func.asm):00655                         tsta                                            ; set flags
EE30 39               (     mmc_func.asm):00656                         rts
                      (     mmc_func.asm):00657         
                      (     mmc_func.asm):00658         ;
                      (     mmc_func.asm):00659         ; Check to see if image is valid and we can seek to track.
                      (     mmc_func.asm):00660         ; track to seek to in a
                      (     mmc_func.asm):00661         ;
                      (     mmc_func.asm):00662         ; Entry :
                      (     mmc_func.asm):00663         ;       A       = Drive id 0..3
                      (     mmc_func.asm):00664         ;       B       = Track 0..79
                      (     mmc_func.asm):00665         ; Exit :
                      (     mmc_func.asm):00666         ;       A       = Simulated WD error.
                      (     mmc_func.asm):00667         ;
                      (     mmc_func.asm):00668         
EE31                  (     mmc_func.asm):00669         MMC_SeekCheck
EE31 3404             (     mmc_func.asm):00670                         pshs    b
EE33 17FE4E           (     mmc_func.asm):00671                         lbsr    MMC_InitSendBytes       ; Send drive id and track to AVR
                      (     mmc_func.asm):00672                         
EE36 17FE8C           (     mmc_func.asm):00673                         lbsr    MMC_WaitPutRead         ; send drive id to AVR
EE39 3502             (     mmc_func.asm):00674                         puls    a                                       ; recover track
EE3B 17FE87           (     mmc_func.asm):00675                         lbsr    MMC_WaitPutRead         ; send track AVR
                      (     mmc_func.asm):00676                         
EE3E 8648             (     mmc_func.asm):00677                         lda             #CMD_IMG_SEEK           ; Try the seek
EE40 17F1CB           (     mmc_func.asm):00678                         lbsr    MMC_SendCmd
                      (     mmc_func.asm):00679                         
EE43 8DE5             (     mmc_func.asm):00680                         bsr             MMC_GetWDError          ; Get simulated WD error
EE45 39               (     mmc_func.asm):00681                         rts
                      (     mmc_func.asm):00682                         
                      (     mmc_func.asm):00683         ;
                      (     mmc_func.asm):00684         ; Send first and last drive ids to MMC for list drives command
                      (     mmc_func.asm):00685         ;
                      (     mmc_func.asm):00686         ; Entry :
                      (     mmc_func.asm):00687         ;       A       = First drive id 0..3
                      (     mmc_func.asm):00688         ;       B       = Second drive id 0..3
                      (     mmc_func.asm):00689         ; Exit :
                      (     mmc_func.asm):00690                 
EE46                  (     mmc_func.asm):00691         MMC_SendDriveIDs
EE46 17FE3B           (     mmc_func.asm):00692                 lbsr    MMC_InitSendBytes  ; Init writing bytes
                      (     mmc_func.asm):00693                 
EE49 17FE79           (     mmc_func.asm):00694                 lbsr    MMC_WaitPutRead     ; send first drive
EE4C 1E98             (     mmc_func.asm):00695                 exg     b,a                 ; get second drive
EE4E 17FE74           (     mmc_func.asm):00696                 lbsr    MMC_WaitPutRead     ; send second drive
EE51 39               (     mmc_func.asm):00697                 rts
                      (     mmc_func.asm):00698           
                      (     mmc_func.asm):00699         ;
                      (     mmc_func.asm):00700         ; issue a format image command.
                      (     mmc_func.asm):00701         ; Entry :
                      (     mmc_func.asm):00702         ;   A = Drive id 0..3
                      (     mmc_func.asm):00703         ;   B = Tracks / sides, b7=0 single sided,  b7=1 double sided.
                      (     mmc_func.asm):00704         ;
EE52                  (     mmc_func.asm):00705         MMC_FormatImage
EE52 BDEC84           (     mmc_func.asm):00706                 jsr         >MMC_InitSendBytes ; Init writing bytes
                      (     mmc_func.asm):00707                 
EE55 BDECC5           (     mmc_func.asm):00708                 jsr     >MMC_WaitPutRead    ; send drive id
                      (     mmc_func.asm):00709         
EE58 1F98             (     mmc_func.asm):00710                 tfr     b,a                 ; get tracks LSB
EE5A 847F             (     mmc_func.asm):00711                 anda    #$7F                ; mask out sides
EE5C BDECC5           (     mmc_func.asm):00712                 jsr     >MMC_WaitPutRead    ; tracks LSB
                      (     mmc_func.asm):00713                         
EE5F 4F               (     mmc_func.asm):00714                 clra                        ; Send MSB of tracks = 0
EE60 BDECC5           (     mmc_func.asm):00715                 jsr     >MMC_WaitPutRead    ; tracks MSB
                      (     mmc_func.asm):00716                      
EE63 8601             (     mmc_func.asm):00717                 lda     #$01                ; Assume single sided
EE65 5D               (     mmc_func.asm):00718                 tstb                        ; check for double sided
EE66 2A01             (     mmc_func.asm):00719                 bpl     MMC_FormatImageSS   ; no : skip
EE68 4C               (     mmc_func.asm):00720                 inca
                      (     mmc_func.asm):00721                 
EE69                  (     mmc_func.asm):00722         MMC_FormatImageSS
EE69 BDECC5           (     mmc_func.asm):00723                 jsr     >MMC_WaitPutRead    ; heads
EE6C 8612             (     mmc_func.asm):00724                 lda     #SectorsPerTrack    ; 18 sectors / track
EE6E BDECC5           (     mmc_func.asm):00725                 jsr     >MMC_WaitPutRead    
                      (     mmc_func.asm):00726                 
EE71 8649             (     mmc_func.asm):00727                 lda     #CMD_CREATE_IMG     ; Send command
                      (     mmc_func.asm):00728                 
EE73 17F198           (     mmc_func.asm):00729                 lbsr    MMC_SendCmd
EE76 39               (     mmc_func.asm):00730                 rts
                      (     mmc_func.asm):00731         
                      (     mmc_func.asm):00732         ;
                      (     mmc_func.asm):00733         ; Send Head and record (sector) number.
                      (     mmc_func.asm):00734         ; Logical sector no in a, 1..36 for Dragondos 1..18 for RSDOS
                      (     mmc_func.asm):00735         ; DragonDos version needs to deal with both head and sector
                      (     mmc_func.asm):00736         ; 
                      (     mmc_func.asm):00737         
                      (     mmc_func.asm):00738                 ifdef    Dragon
EE77                  (     mmc_func.asm):00739         MMC_SendHR       
                      (     mmc_func.asm):00740                 
                      (     mmc_func.asm):00741                 pshs    a
                      (     mmc_func.asm):00742                 jsr         >MMC_InitSendBytes ; Init writing bytes
                      (     mmc_func.asm):00743                 
                      (     mmc_func.asm):00744                 ldb     <DosDriveNo             ; Get drive no
                      (     mmc_func.asm):00745                 decb
                      (     mmc_func.asm):00746                 exg     a,b                 ; swap it into a
                      (     mmc_func.asm):00747                 
                      (     mmc_func.asm):00748                 jsr     >MMC_WaitPutRead    ; send drive id
                      (     mmc_func.asm):00749                 exg     a,b                 ; recover sector no
                      (     mmc_func.asm):00750         
                      (     mmc_func.asm):00751                 clrb                        ; Head no -1
                      (     mmc_func.asm):00752                 cmpa    #SectorsPerTrack    ; > Sectors / Track, if so on side 2
                      (     mmc_func.asm):00753                 bls     MMC_SendHR_side0    ; lower, on side 0
                      (     mmc_func.asm):00754                 
                      (     mmc_func.asm):00755                 suba    #SectorsPerTrack    ; get correct sector no
                      (     mmc_func.asm):00756                 incb                        ; on side 2
                      (     mmc_func.asm):00757                 
EE77                  (     mmc_func.asm):00758         MMC_SendHR_side0
                      (     mmc_func.asm):00759                 exg     a,b                 ; send head first
                      (     mmc_func.asm):00760                 jsr     >MMC_WaitPutRead    ; send head       
                      (     mmc_func.asm):00761                 exg     a,b                 ; get sec no into a
                      (     mmc_func.asm):00762                 deca
                      (     mmc_func.asm):00763                 jsr     >MMC_WaitPutRead    ; send it
                      (     mmc_func.asm):00764                 
                      (     mmc_func.asm):00765                 lda     #CMD_LOAD_HR        ; set sector and head
                      (     mmc_func.asm):00766                 jsr     >MMC_SendCmd
                      (     mmc_func.asm):00767                 
                      (     mmc_func.asm):00768                 puls    a,pc                ; restore and return.
                      (     mmc_func.asm):00769                 
                      (     mmc_func.asm):00770                 else
                      (     mmc_func.asm):00771         
                      (     mmc_func.asm):00772         ;
                      (     mmc_func.asm):00773         ; RSDOS version, much simpler as head is always 0
                      (     mmc_func.asm):00774         ;
                      (     mmc_func.asm):00775         
EE77                  (     mmc_func.asm):00776         MMC_SendHR       
                      (     mmc_func.asm):00777         
EE77 3402             (     mmc_func.asm):00778                 pshs    a
EE79 BDEC84           (     mmc_func.asm):00779                 jsr         >MMC_InitSendBytes ; Init writing bytes
                      (     mmc_func.asm):00780                 
EE7C D6EB             (     mmc_func.asm):00781                 ldb     dcdrv               ; Get drive no
EE7E 1E89             (     mmc_func.asm):00782                 exg     a,b                 ; swap it into a
                      (     mmc_func.asm):00783                 
EE80 BDECC5           (     mmc_func.asm):00784                 jsr     >MMC_WaitPutRead    ; send drive id
                      (     mmc_func.asm):00785          
EE83 4F               (     mmc_func.asm):00786                 clra    
EE84 BDECC5           (     mmc_func.asm):00787                 jsr     >MMC_WaitPutRead    ; send head, always 0 for RSDOS
                      (     mmc_func.asm):00788                
EE87 1E89             (     mmc_func.asm):00789                 exg     a,b                 ; get sec no into a
EE89 4A               (     mmc_func.asm):00790                 deca
EE8A BDECC5           (     mmc_func.asm):00791                 jsr     >MMC_WaitPutRead    ; send it
                      (     mmc_func.asm):00792                 
EE8D 864C             (     mmc_func.asm):00793                 lda     #CMD_LOAD_HR        ; set sector and head
EE8F BDE00E           (     mmc_func.asm):00794                 jsr     >MMC_SendCmd
                      (     mmc_func.asm):00795                 
EE92 3582             (     mmc_func.asm):00796                 puls    a,pc                ; restore and return.
                      (     mmc_func.asm):00797                 
                      (     mmc_func.asm):00798                 endc
                      (     mmc_func.asm):00799                 
                      (     mmc_func.asm):00800                 
                      (     mmc_func.asm):00801         ;
                      (     mmc_func.asm):00802         ; Get disk geometry of drive in DosLastDrive
                      (     mmc_func.asm):00803         ;
                      (     mmc_func.asm):00804         ; Entry : DosLastDrive contains drive to interigate
                      (     mmc_func.asm):00805         ; Exit  : DosDxTracks and DosDxSecTrack set for drive
                      (     mmc_func.asm):00806         ;                 Also returned in A=Tracks, B=Sec/Trk
                      (     mmc_func.asm):00807         ;
                      (     mmc_func.asm):00808         ; If an error occours, or a geometry block is not present
                      (     mmc_func.asm):00809         ; defaults to standard single sided, 40 track.
                      (     mmc_func.asm):00810         ;
                      (     mmc_func.asm):00811         
                      (     mmc_func.asm):00812                         ifne    0
EE94                  (     mmc_func.asm):00813         MMC_GetGeom
                      (     mmc_func.asm):00814                         pshs    x
                      (     mmc_func.asm):00815                         lda             <DosLastDrive           ; Pickup drive id
                      (     mmc_func.asm):00816                         deca                                            ; make zero based
                      (     mmc_func.asm):00817         
                      (     mmc_func.asm):00818                         ldx             #DosD0Online            ; Point to tables for this drive
                      (     mmc_func.asm):00819                         leax    a,x
                      (     mmc_func.asm):00820         
                      (     mmc_func.asm):00821                         lbsr    MMC_WaitPutLatchRead    ; send the drive id             
                      (     mmc_func.asm):00822                         
                      (     mmc_func.asm):00823                         lda             #CMD_IMG_GET_GEOM       ; get geometry
                      (     mmc_func.asm):00824                         lbsr    MMC_SendCmd                     ; send command
                      (     mmc_func.asm):00825                         
                      (     mmc_func.asm):00826                         lda             #CMD_INIT_READ          ; Read the results
                      (     mmc_func.asm):00827                         lbsr    MMC_SendCmdRaw          ; send command
                      (     mmc_func.asm):00828                         
                      (     mmc_func.asm):00829                         lbsr    MMC_WaitGetWritten      ; get sec/track
                      (     mmc_func.asm):00830                         
                      (     mmc_func.asm):00831                         sta             DosSecTrkTblOfs,x       ; save sec/trk it
                      (     mmc_func.asm):00832                         exg             a,b                                     ; get sec / trk in b
                      (     mmc_func.asm):00833                 
                      (     mmc_func.asm):00834                         lbsr    MMC_WaitGetWritten      ; get tracks
                      (     mmc_func.asm):00835                         sta             DosTracksTblOfs,x       ; save tracks it
                      (     mmc_func.asm):00836                         
                      (     mmc_func.asm):00837                         puls    x,pc                            ; restore / return
                      (     mmc_func.asm):00838                         endc 
                      (     mmc_func.asm):00839                         
                      (     mmc_func.asm):00840                         endc
                      (     mmc_func.asm):00841                         
EE94                  (     mmc_func.asm):00842         __mmc_func_end
                      (    DragonMMC.asm):00676                         use             console.asm
                      (      console.asm):00001         ;
                      (      console.asm):00002         ; Console.asm : write things to Dragon screen.
                      (      console.asm):00003         ;
                      (      console.asm):00004         ; Define MINIMUM to exclude code not needed by FLASH
                      (      console.asm):00005         ;
                      (      console.asm):00006         ; 2017-03-22, removed all calls to TextOutString, **DO NOT** put any back in
                      (      console.asm):00007         ; as they mess with the system area too much.
                      (      console.asm):00008         ; use CON_WriteString instead.
                      (      console.asm):00009         ;
EE94                  (      console.asm):00010         __console
                      (      console.asm):00011         
                      (      console.asm):00012         ; Set CONDEB to 1 to include console debugging code usefull for debugging
                      (      console.asm):00013         ; other routines, but not needed when building release version.
     0001             (      console.asm):00014         CONDEB  equ             1       
                      (      console.asm):00015         
                      (      console.asm):00016                         ifne    CONDEB
EE94                  (      console.asm):00017         CON_WriteHexX
EE94 3406             (      console.asm):00018                         pshs    d
EE96 1F10             (      console.asm):00019                         tfr             x,d
EE98 8D0C             (      console.asm):00020                         bsr             CON_WriteHexWordS               ; Write x
EE9A 3586             (      console.asm):00021                         puls    d,pc
                      (      console.asm):00022                         
                      (      console.asm):00023         ;
                      (      console.asm):00024         ; Write hex word in D.
                      (      console.asm):00025         ;
                      (      console.asm):00026         
EE9C                  (      console.asm):00027         CON_WriteHexWord
EE9C 3406             (      console.asm):00028                         pshs    d                                           ; save d
EE9E 8D0A             (      console.asm):00029                         bsr             CON_WriteHexByte                ; Write MSB
EEA0 1E89             (      console.asm):00030                         exg             a,b                                         ; get LSB
EEA2 8D06             (      console.asm):00031                         bsr             CON_WriteHexByte                ; Write LSB
EEA4 3586             (      console.asm):00032                         puls    d,pc                                ; restore / return
                      (      console.asm):00033         
EEA6                  (      console.asm):00034         CON_WriteHexWordS
EEA6 8DF4             (      console.asm):00035                         bsr             CON_WriteHexWord                ; Write word
EEA8 2016             (      console.asm):00036                         bra             CON_WriteSpace              ; write space
                      (      console.asm):00037                         endc
                      (      console.asm):00038                         
                      (      console.asm):00039         ;
                      (      console.asm):00040         ; Write byte in a as hex followed by space.
                      (      console.asm):00041         ;
                      (      console.asm):00042                         
EEAA                  (      console.asm):00043         CON_WriteHexByte
EEAA 3402             (      console.asm):00044                         pshs    a
                      (      console.asm):00045                 
EEAC 44               (      console.asm):00046                         lsra                                                ; Move msn to lsn
EEAD 44               (      console.asm):00047                         lsra    
EEAE 44               (      console.asm):00048                         lsra    
EEAF 44               (      console.asm):00049                         lsra    
                      (      console.asm):00050         
EEB0 8D27             (      console.asm):00051                         bsr             CON_GetHexNibbleA               ; send msn
EEB2 BDA30A           (      console.asm):00052                         jsr             BasicScreenOut  
                      (      console.asm):00053                 
EEB5 A6E4             (      console.asm):00054                         lda             ,s                                          ; retrive digit
EEB7 8D20             (      console.asm):00055                         bsr             CON_GetHexNibbleA               ; send lsn
EEB9 BDA30A           (      console.asm):00056                         jsr             BasicScreenOut  
EEBC 3582             (      console.asm):00057                         puls    a,pc
                      (      console.asm):00058         
                      (      console.asm):00059                         ifne    CONDEB
EEBE                  (      console.asm):00060         CON_WriteHexByteS
EEBE 8DEA             (      console.asm):00061                         bsr             CON_WriteHexByte        
                      (      console.asm):00062                         
EEC0                  (      console.asm):00063         CON_WriteSpace
EEC0 3402             (      console.asm):00064                         pshs    a
EEC2 8620             (      console.asm):00065                         lda             #$20                                ; send space
EEC4 BDA30A           (      console.asm):00066                         jsr             BasicScreenOut              ; send it
EEC7 3582             (      console.asm):00067                         puls    a,pc
                      (      console.asm):00068                         endc
                      (      console.asm):00069                         
EEC9                  (      console.asm):00070         CON_HexDigits
EEC9 3031323334353637 (      console.asm):00071                         fcc             /0123456789ABCDEF/
     3839414243444546
                      (      console.asm):00072                 
EED9                  (      console.asm):00073         CON_GetHexNibbleA
EED9 3410             (      console.asm):00074                         pshs    x
EEDB 840F             (      console.asm):00075                         anda    #$0F                                ; mask out bytes
                      (      console.asm):00076                 
EEDD 308DFFE8         (      console.asm):00077                         leax    >CON_HexDigits,pcr              ; Point to digits
EEE1 3086             (      console.asm):00078                         leax    a,x                                         ; point to needed digit
EEE3 A684             (      console.asm):00079                         lda             ,x                                          ; **GET** hex digit !
EEE5 3590             (      console.asm):00080                         puls    x,pc
                      (      console.asm):00081         
                      (      console.asm):00082                         ifne    CONDEB
                      (      console.asm):00083         
EEE7                  (      console.asm):00084         CON_HexByteAt0
EEE7 3412             (      console.asm):00085                         pshs    a,x                                                     ; save regs
EEE9 9E88             (      console.asm):00086                         ldx     <TextVDUCursAddr            ; get cursor pos
EEEB 3410             (      console.asm):00087                         pshs    x                                                       ; save it
EEED 8E0400           (      console.asm):00088                         ldx             #$400                                           ; pos 0
EEF0 9F88             (      console.asm):00089                         stx     <TextVDUCursAddr            ; set cursor pos
                      (      console.asm):00090                         
EEF2 8DB6             (      console.asm):00091                         bsr             CON_WriteHexByte                        ; write it
                      (      console.asm):00092                         
EEF4 3510             (      console.asm):00093                         puls    x                                                       ; restore old cursor pos
EEF6 9F88             (      console.asm):00094                         stx     <TextVDUCursAddr            ; set cursor pos
                      (      console.asm):00095                         
EEF8 3592             (      console.asm):00096                         puls    a,x,pc                                          ; restore and return
                      (      console.asm):00097         
EEFA                  (      console.asm):00098         ASCII_AToHexA
EEFA 3414             (      console.asm):00099                 pshs    x,b
EEFC 5F               (      console.asm):00100                 clrb
EEFD 308CC9           (      console.asm):00101                 leax    CON_HexDigits,pcr           ; Point to hex digits
EF00                  (      console.asm):00102         ASCII_AToHexALoop
EF00 A185             (      console.asm):00103                 cmpa    b,x                         ; same digit?
EF02 2709             (      console.asm):00104                 beq     ValidHex
EF04 5C               (      console.asm):00105                 incb                                ; next digit
EF05 C110             (      console.asm):00106                 cmpb    #16                         ; tried all?
EF07 25F7             (      console.asm):00107                 blo     ASCII_AToHexALoop           ; no : loop again
EF09 1A01             (      console.asm):00108                 orcc    #FlagCarry                  ; flag error
EF0B 3594             (      console.asm):00109                 puls    b,x,pc                      ; return it
                      (      console.asm):00110                 
EF0D                  (      console.asm):00111         ValidHex
EF0D 1F98             (      console.asm):00112                 tfr     b,a                         ; get position into a
EF0F 3594             (      console.asm):00113                 puls    b,x,pc
                      (      console.asm):00114                         
EF11                  (      console.asm):00115         ASCII_XToHexByte
EF11 A684             (      console.asm):00116                 lda     ,x                          ; Get byte
EF13 8DE5             (      console.asm):00117                 bsr     ASCII_AToHexA               ; convert it
EF15 48               (      console.asm):00118                 asla                                ; convert to MSN
EF16 48               (      console.asm):00119                 asla
EF17 48               (      console.asm):00120                 asla
EF18 48               (      console.asm):00121                 asla                                
EF19 3402             (      console.asm):00122                 pshs    a                           ; save it
EF1B A601             (      console.asm):00123                 lda     1,x                         ; Get byte
EF1D 8DDB             (      console.asm):00124                 bsr     ASCII_AToHexA               ; convert it
EF1F AAE0             (      console.asm):00125                 ora     ,s+                         ; combine with stacked MSN
EF21 39               (      console.asm):00126                 rts
                      (      console.asm):00127                 
                      (      console.asm):00128                         endc
                      (      console.asm):00129                 
                      (      console.asm):00130                         ifne    CONDEB
EF22                  (      console.asm):00131         CON_DotEOL
EF22 3402             (      console.asm):00132                         pshs    a                                                       ; save a
EF24 862E             (      console.asm):00133                         lda             #'.'                                            ; print dot
EF26 BDA30A           (      console.asm):00134                         jsr             BasicScreenOut              ; send it
EF29 8D0D             (      console.asm):00135                         bsr             CON_EOL                                         ; and EOL
EF2B 3582             (      console.asm):00136                         puls    a,pc
                      (      console.asm):00137         
EF2D                  (      console.asm):00138         CON_DashEOL
EF2D 3402             (      console.asm):00139                         pshs    a                                                       ; save a
EF2F 862D             (      console.asm):00140                         lda             #'-'                                            ; print dot
EF31 BDA30A           (      console.asm):00141                         jsr             BasicScreenOut              ; send it
EF34 8D02             (      console.asm):00142                         bsr             CON_EOL                                         ; and EOL
EF36 3582             (      console.asm):00143                         puls    a,pc
                      (      console.asm):00144         
                      (      console.asm):00145                         endc
                      (      console.asm):00146                         
                      (      console.asm):00147         ;
                      (      console.asm):00148         ; CON_EOL : Write end of line sequence
                      (      console.asm):00149         ;
                      (      console.asm):00150         
EF38                  (      console.asm):00151         CON_EOL
EF38 860D             (      console.asm):00152                         lda             #$0d                                ; EOL
EF3A 7EA30A           (      console.asm):00153                         jmp             BasicScreenOut              ; send it
                      (      console.asm):00154                         
                      (      console.asm):00155         
                      (      console.asm):00156                         ifne    CONDEB
                      (      console.asm):00157         
EF3D                  (      console.asm):00158         CON_WriteHexByteEOL
EF3D 3402             (      console.asm):00159                         pshs    a
EF3F 17FF68           (      console.asm):00160                         lbsr            CON_WriteHexByte
EF42 8DF4             (      console.asm):00161                         bsr             CON_EOL
EF44 3582             (      console.asm):00162                         puls    a,pc
                      (      console.asm):00163                         endc
                      (      console.asm):00164                         
                      (      console.asm):00165         ;
                      (      console.asm):00166         ; Write a zero terminated string to the screen, does not screw with 
                      (      console.asm):00167         ; as many of system vars as rom routine at $90E5
                      (      console.asm):00168         ; 
                      (      console.asm):00169         ; Entry : X address of ASCIIZ string to print.
                      (      console.asm):00170         ;
                      (      console.asm):00171                 
EF46                  (      console.asm):00172         CON_WriteString
EF46 3412             (      console.asm):00173                 pshs    x,a
EF48                  (      console.asm):00174         CON_WriteStringLoop        
EF48 A680             (      console.asm):00175                 lda     ,x+                         ; Get character to print
EF4A 4D               (      console.asm):00176                 tsta                                ; Zero : end of string
EF4B 2705             (      console.asm):00177                 beq     CON_WriteStringExit         ; exit
EF4D BDA30A           (      console.asm):00178                 jsr     BasicScreenOut              ; output it
EF50 20F6             (      console.asm):00179                 bra     CON_WriteStringLoop         ; do next
EF52                  (      console.asm):00180         CON_WriteStringExit        
EF52 3592             (      console.asm):00181                 puls    x,a,pc
                      (      console.asm):00182                     
                      (      console.asm):00183                         ifndef  MINIMUM
                      (      console.asm):00184                         ifne    CONDEB
EF54                  (      console.asm):00185         CON_WaitKey
EF54 3402             (      console.asm):00186                         pshs    a
EF56                  (      console.asm):00187         CON_WaitKeyLoop
EF56 BDA1C1           (      console.asm):00188                         jsr             BasicKbdIn              
EF59 27FB             (      console.asm):00189                         beq             CON_WaitKeyLoop
EF5B 3582             (      console.asm):00190                         puls    a,pc
                      (      console.asm):00191                         
                      (      console.asm):00192                         endc
                      (      console.asm):00193         ;
                      (      console.asm):00194         ; Write a version number in a as msn.lsn followed by space.
                      (      console.asm):00195         ;
                      (      console.asm):00196         
EF5D                  (      console.asm):00197         CON_NdotN
EF5D 3402             (      console.asm):00198                         pshs    a
                      (      console.asm):00199                 
EF5F 44               (      console.asm):00200                         lsra                                                ; Move msn to lsn
EF60 44               (      console.asm):00201                         lsra    
EF61 44               (      console.asm):00202                         lsra    
EF62 44               (      console.asm):00203                         lsra    
                      (      console.asm):00204         
EF63 BDEED9           (      console.asm):00205                         jsr             CON_GetHexNibbleA           ; send msn
EF66 BDA30A           (      console.asm):00206                         jsr             BasicScreenOut  
                      (      console.asm):00207         
EF69 862E             (      console.asm):00208                         lda             #'.'                                    ; send dot
EF6B BDA30A           (      console.asm):00209                         jsr             BasicScreenOut  
                      (      console.asm):00210         
EF6E A6E4             (      console.asm):00211                         lda             ,s                                          ; retrive digit
EF70 BDEED9           (      console.asm):00212                         jsr             CON_GetHexNibbleA               ; send lsn
EF73 BDA30A           (      console.asm):00213                         jsr             BasicScreenOut  
                      (      console.asm):00214                 
EF76 8620             (      console.asm):00215                         lda             #$20                                ; send space
EF78 BDA30A           (      console.asm):00216                         jsr             BasicScreenOut              ; send it
                      (      console.asm):00217                 
EF7B 3582             (      console.asm):00218                         puls    a,pc
                      (      console.asm):00219                         
                      (      console.asm):00220         ;
                      (      console.asm):00221         ; CON_PromptMore : display a prompt and wait for a key
                      (      console.asm):00222         ;                                  Key pressed returned in a
                      (      console.asm):00223         ; 
                      (      console.asm):00224         
EF7D                  (      console.asm):00225         CON_PromptMore
EF7D 308DF425         (      console.asm):00226                         leax    MoreMess,PCR                            ; Prompt for more
EF81 BDEF46           (      console.asm):00227                         JSR     >CON_WriteString
EF84                  (      console.asm):00228         CON_PromptMoreWait              
EF84 BDA1C1           (      console.asm):00229                         jsr             >BasicKbdIn                                     ; Poll keyboard
EF87 27FB             (      console.asm):00230                         beq             CON_PromptMoreWait                      ; No key pressed loop again
                      (      console.asm):00231         
EF89 39               (      console.asm):00232                         rts
                      (      console.asm):00233                         
                      (      console.asm):00234                         ifne    CONDEB
                      (      console.asm):00235         ;
                      (      console.asm):00236         ; CON_DumpRegs : Dump the registers.
                      (      console.asm):00237         ;
                      (      console.asm):00238         ; After the push (and set of wait flag) the stack will be....
                      (      console.asm):00239         ;
                      (      console.asm):00240         ; PCL   from BSR/JSR
                      (      console.asm):00241         ; PCH   S+11
                      (      console.asm):00242         ; UL    From pshs
                      (      console.asm):00243         ; UH    S+9
                      (      console.asm):00244         ; YL
                      (      console.asm):00245         ; YH    S+7
                      (      console.asm):00246         ; XL
                      (      console.asm):00247         ; XH    S+5
                      (      console.asm):00248         ; DP    S+4
                      (      console.asm):00249         ; B             S+3
                      (      console.asm):00250         ; A             S+2
                      (      console.asm):00251         ; CC    S+1
                      (      console.asm):00252         ; WFLAG S+0
                      (      console.asm):00253         
EF8A                  (      console.asm):00254         CON_DumpRegs
EF8A 347F             (      console.asm):00255                         pshs    u,y,x,dp,b,a,cc                         ; pushed in this order
EF8C 4F               (      console.asm):00256                         clra                                                            ; flag don't wait for keypress
                      (      console.asm):00257         
EF8D                  (      console.asm):00258         CON_DumpRegsCommon
EF8D 3402             (      console.asm):00259                         pshs    a                                                       ; save wait flag
                      (      console.asm):00260         
EF8F 308DF419         (      console.asm):00261                         leax    RegNames,pcr                            ; print reg names
EF93 BDEF46           (      console.asm):00262                         JSR     >CON_WriteString
                      (      console.asm):00263                         
EF96 EC6B             (      console.asm):00264                         ldd             11,s                                            ; Get PC
EF98 17FF0B           (      console.asm):00265                         lbsr    CON_WriteHexWordS                       ; display it
                      (      console.asm):00266         
EF9B A662             (      console.asm):00267                         lda             2,s                                                     ; get A
EF9D 17FF1E           (      console.asm):00268                         lbsr    CON_WriteHexByteS                       ; display it
                      (      console.asm):00269                         
EFA0 A663             (      console.asm):00270                         lda             3,s                                                     ; get B
EFA2 17FF19           (      console.asm):00271                         lbsr    CON_WriteHexByteS                       ; display it
                      (      console.asm):00272                         
EFA5 EC65             (      console.asm):00273                         ldd             5,s                                             ; Get X
EFA7 17FEFC           (      console.asm):00274                         lbsr    CON_WriteHexWordS                       ; display it
                      (      console.asm):00275                         
EFAA EC67             (      console.asm):00276                         ldd             7,s                                                     ; Get Y
EFAC 17FEF7           (      console.asm):00277                         lbsr    CON_WriteHexWordS                       ; display it
                      (      console.asm):00278                                 
EFAF EC69             (      console.asm):00279                         ldd             9,s                                                     ; Get U
EFB1 17FEF2           (      console.asm):00280                         lbsr    CON_WriteHexWordS                       ; display it
                      (      console.asm):00281                 
EFB4 A664             (      console.asm):00282                         lda             4,s                                                     ; get DP
EFB6 17FF05           (      console.asm):00283                         lbsr    CON_WriteHexByteS                       ; display it
                      (      console.asm):00284                 
EFB9 A661             (      console.asm):00285                         lda             1,s                                                     ; get CC
EFBB 17FF00           (      console.asm):00286                         lbsr    CON_WriteHexByteS                       ; display it
                      (      console.asm):00287                 
EFBE 3502             (      console.asm):00288                         puls    a                                                       ; get wait flag
EFC0 2702             (      console.asm):00289                         beq             CON_DumpRegsExit                        ; Don't wait exit
                      (      console.asm):00290         
EFC2                  (      console.asm):00291         CON_DumpRegsLoop        
EFC2 8D90             (      console.asm):00292                         bsr             CON_WaitKey                                     ; wait for a keypress
EFC4                  (      console.asm):00293         CON_DumpRegsExit        
EFC4 357F             (      console.asm):00294                         puls    u,y,x,dp,b,a,cc
EFC6 39               (      console.asm):00295                         rts
                      (      console.asm):00296         
EFC7                  (      console.asm):00297         CON_DumpRegsWait                
EFC7 347F             (      console.asm):00298                         pshs    u,y,x,dp,b,a,cc                         ; pushed in this order
EFC9 86FF             (      console.asm):00299                         lda             #$FF                                            ; flag wait for keypress
EFCB 20C0             (      console.asm):00300                         bra             CON_DumpRegsCommon
                      (      console.asm):00301         
                      (      console.asm):00302                         endc
                      (      console.asm):00303         ;
                      (      console.asm):00304         ; Get maximum of B bytes of input into buffer at X
                      (      console.asm):00305         ;
                      (      console.asm):00306         
EFCD                  (      console.asm):00307         CON_InputBufXB
EFCD 5A               (      console.asm):00308                 decb
EFCE 3404             (      console.asm):00309                 pshs    b
EFD0 5F               (      console.asm):00310                 clrb
                      (      console.asm):00311                 
EFD1                  (      console.asm):00312         CON_InputBufXBLoop
EFD1 3414             (      console.asm):00313                 pshs    x,b
EFD3 BDA199           (      console.asm):00314                 jsr     >BasicCursorB               ; Blink cursor
EFD6 BDA1C1           (      console.asm):00315                 jsr             >BasicKbdIn                                 ; Read keyboard
EFD9 3514             (      console.asm):00316                 puls    x,b
                      (      console.asm):00317                 
EFDB 8100             (      console.asm):00318                 cmpa    #0
EFDD 27F2             (      console.asm):00319                 beq     CON_InputBufXBLoop          ; keep looping until keypressed
                      (      console.asm):00320                 
EFDF 810D             (      console.asm):00321                 cmpa    #$0d                        ; Enter pressed?
EFE1 272A             (      console.asm):00322                 beq     CON_InputBufXBEnd
                      (      console.asm):00323                 
EFE3 8108             (      console.asm):00324                 cmpa    #$08                        ; Backspace?
EFE5 270C             (      console.asm):00325                 beq     CON_InputBufXBBack          ; yep : act on it
                      (      console.asm):00326                 
EFE7 E1E4             (      console.asm):00327                 cmpb    ,s                          ; Past end of buffer?
EFE9 24E6             (      console.asm):00328                 bhs     CON_InputBufXBLoop          ; yep : do nothing
                      (      console.asm):00329                 
EFEB A785             (      console.asm):00330                 sta     b,x                         ; save in buffer
EFED 5C               (      console.asm):00331                 incb                                ; increment count
                      (      console.asm):00332                 
EFEE                  (      console.asm):00333         CON_InputBufXBOut
EFEE BDA30A           (      console.asm):00334                 jsr     >BasicScreenOut             ; output character
EFF1 20DE             (      console.asm):00335                 bra     CON_InputBufXBLoop          ; go again
                      (      console.asm):00336                 
                      (      console.asm):00337                 
EFF3                  (      console.asm):00338         CON_InputBufXBBack
EFF3 C100             (      console.asm):00339                 cmpb    #0                          ; at beginning of buffer?
EFF5 27DA             (      console.asm):00340                 beq     CON_InputBufXBLoop          ; Yep do nothing
                      (      console.asm):00341                 
EFF7 5A               (      console.asm):00342                 decb                                ; decrement pointer
EFF8 3410             (      console.asm):00343                 pshs    x                           ; save x
EFFA 9E88             (      console.asm):00344                 ldx     <TextVDUCursAddr            ; get cursor pos
EFFC 301F             (      console.asm):00345                 leax    -1,x                        ; previous char
EFFE 9F88             (      console.asm):00346                         stx     <TextVDUCursAddr            ; update it
F000 8620             (      console.asm):00347                 lda             #' '
F002 BDA30A           (      console.asm):00348                 jsr     >BasicScreenOut             ; output character
F005 9F88             (      console.asm):00349                 stx     <TextVDUCursAddr            ; reset pointer
F007 3510             (      console.asm):00350                 puls    x
F009 20C6             (      console.asm):00351                 bra             CON_InputBufXBLoop
F00B 20E1             (      console.asm):00352                 bra     CON_InputBufXBOut           
                      (      console.asm):00353                 
F00D                  (      console.asm):00354         CON_InputBufXBEnd
F00D 6F85             (      console.asm):00355                 clr     b,x                         ; Terminate string
F00F 3584             (      console.asm):00356                 puls    b,pc
                      (      console.asm):00357                 
                      (      console.asm):00358         ;
                      (      console.asm):00359         ; Clear text screen line specified in B
                      (      console.asm):00360         ;
F011                  (      console.asm):00361         CON_ClearLineB
F011 3416             (      console.asm):00362                 pshs    d,x
                      (      console.asm):00363                 
F013 8620             (      console.asm):00364                 lda     #TextLineLen                ; line length
F015 3D               (      console.asm):00365                 mul                                 ; calculate offset
F016 8E0400           (      console.asm):00366                 ldx     #TextScreenBase             ; point to screen
F019 308B             (      console.asm):00367                 leax    d,x                         ; add offset
F01B 9F88             (      console.asm):00368                 stx     <TextVDUCursAddr            ; Set cursor address to beginning of line
                      (      console.asm):00369                 
F01D 8660             (      console.asm):00370                 lda     #$60                        ; VDG space :)
F01F 5F               (      console.asm):00371                 clrb
F020                  (      console.asm):00372         CON_ClearLineBLoop
F020 A785             (      console.asm):00373                 sta     b,x                         ; blank it
F022 5C               (      console.asm):00374                 incb                                ; next
F023 C120             (      console.asm):00375                 cmpb    #TextLineLen                ; done a line ?
F025 25F9             (      console.asm):00376                 blo     CON_ClearLineBLoop          ; nope keep going
                      (      console.asm):00377                 
F027 3596             (      console.asm):00378                 puls    d,x,pc
                      (      console.asm):00379                 
                      (      console.asm):00380         ;
                      (      console.asm):00381         ; Clear line B and print string at X
                      (      console.asm):00382         ;
F029                  (      console.asm):00383         CON_ClearBPrintX
F029 8DE6             (      console.asm):00384                 bsr     CON_ClearLineB              ; clear line
F02B 17FF18           (      console.asm):00385                 lbsr    CON_WriteString             ; print it
F02E 39               (      console.asm):00386                 rts
                      (      console.asm):00387         
                      (      console.asm):00388                
                      (      console.asm):00389         ;
                      (      console.asm):00390         ; Acorn style inline print where string to be printed follows jsr/bsr
                      (      console.asm):00391         ;
                      (      console.asm):00392                 ifne    DEBUG
                      (      console.asm):00393                 ifne    0
F02F                  (      console.asm):00394         CON_InlinePrint
                      (      console.asm):00395                 pshs    x,d                         ; PC now at s+4
                      (      console.asm):00396                 ldx     4,s                         ; Get PC of return address
                      (      console.asm):00397                 
F02F                  (      console.asm):00398         CON_InlinePrintLoop
                      (      console.asm):00399                 lda     ,x+                         ; get a byte from string
                      (      console.asm):00400                 beq     CON_InlinePrintEnd          ; zero end of sting : exit
                      (      console.asm):00401                 jsr     >BasicScreenOut
                      (      console.asm):00402                 bra     CON_InlinePrintLoop         ; loop again!
F02F                  (      console.asm):00403         CON_InlinePrintEnd
                      (      console.asm):00404                 
                      (      console.asm):00405                 stx     4,s                         ; Update return address
                      (      console.asm):00406                 puls    d,x,pc
                      (      console.asm):00407                 endc
                      (      console.asm):00408                 endc
                      (      console.asm):00409                 
                      (      console.asm):00410                         endc
                      (      console.asm):00411                         
F02F                  (      console.asm):00412         __console_end
                      (    DragonMMC.asm):00677                         use             util.asm
                      (         util.asm):00001         ;
                      (         util.asm):00002         ; Utility routines
                      (         util.asm):00003         ;
                      (         util.asm):00004         
                      (         util.asm):00005         ;
                      (         util.asm):00006         ; wrapper for UtilCopyBXtoU, that disables interrupts whilst doing it's work
                      (         util.asm):00007         ; 
F02F                  (         util.asm):00008         __utils
                      (         util.asm):00009                         ifne    0
F02F                  (         util.asm):00010         DO_SafeCopy
                      (         util.asm):00011                         pshs    cc                                              ; save condition codes
                      (         util.asm):00012                         orcc    #FlagIRQ+FlagFIRQ               ; disable ints
                      (         util.asm):00013                         jsr             UtilCopyBXtoU                   ; do the copy
                      (         util.asm):00014                         puls    cc,pc                                   ; restore and return
                      (         util.asm):00015         
                      (         util.asm):00016         ;
                      (         util.asm):00017         ; Wrapper for UtilCopyBXtoU which enables extra ram before copying, and disables afterwards
                      (         util.asm):00018         ; this assumes that the roms have already been mirrored to ram, and is to be used
                      (         util.asm):00019         ; for copying data to ram e.g. whilst snapshotting.
                      (         util.asm):00020         ;
                      (         util.asm):00021                         
F02F                  (         util.asm):00022         DO_RamCopy
                      (         util.asm):00023                         pshs    a,cc                                    ; save condition codes
                      (         util.asm):00024                         orcc    #FlagIRQ+FlagFIRQ               ; disable ints
                      (         util.asm):00025         
                      (         util.asm):00026                         lda     D_RAM_CTRL                              ; Get RAM control reg
                      (         util.asm):00027                 ora             #D_RAM_ENABLE                   ; put us in RAM mode
                      (         util.asm):00028                         sta             D_RAM_CTRL                              ; set flags
                      (         util.asm):00029                 
                      (         util.asm):00030                         jsr             UtilCopyBXtoU                   ; do the copy
                      (         util.asm):00031                         
                      (         util.asm):00032                         lda     D_RAM_CTRL                              ; Get RAM control reg
                      (         util.asm):00033                 anda    #~D_RAM_ENABLE                  ; put us in ROM mode
                      (         util.asm):00034                         sta             D_RAM_CTRL                              ; set flags
                      (         util.asm):00035         
                      (         util.asm):00036                         puls    a,cc,pc                                 ; restore and return
                      (         util.asm):00037         
                      (         util.asm):00038                         endc
                      (         util.asm):00039         
                      (         util.asm):00040         ;
                      (         util.asm):00041         ; MGetCommaThen8Bit, scan for comma, error if not found, then fetch 8 bit that follows (or error). 
                      (         util.asm):00042         ;
                      (         util.asm):00043         
F02F                  (         util.asm):00044         MGetCommaThen8Bit
F02F 9DA5             (         util.asm):00045                         JSR     <BasChrGetCurr                  ; Get current basic char
F031 270A             (         util.asm):00046                 BEQ     MGetCommaThen8BitExit   ; Any left no: return 
F033 BDB26D           (         util.asm):00047                 JSR     >VarCKComma                             ; check for comma
                      (         util.asm):00048         ;        bra     MGet8Bit                               ; go get it
F036                  (         util.asm):00049         MGet8Bit
F036 3460             (         util.asm):00050                         PSHS    Y,U
F038 BDB70B           (         util.asm):00051                 JSR     >VarGet8Bit                             ; Get 8 bit value into B
                      (         util.asm):00052         ;MGet8BitorErrorExit    
F03B 3560             (         util.asm):00053                         PULS    Y,U                                             ; Restore and return
                      (         util.asm):00054         
F03D                  (         util.asm):00055         MGetCommaThen8BitExit
F03D 39               (         util.asm):00056                         rts
                      (         util.asm):00057         ;
                      (         util.asm):00058         ; Reset the machine to power on memory map, used by tape and direct loading routines.
                      (         util.asm):00059         ; Note : corrupts Y and moves stack.
                      (         util.asm):00060         ;
                      (         util.asm):00061         
F03E                  (         util.asm):00062         DO_ResetPoweron
F03E 3520             (         util.asm):00063                         puls    y                                               ; get our return address
                      (         util.asm):00064         
                      (         util.asm):00065         ; Perform the equivelent of a clear 200,MaxRam so the machine has it's ramtop
                      (         util.asm):00066         ; reset as if it had just been turned on, as a lot of commercial tape software 
                      (         util.asm):00067         ; assumes this condition, and will bomb on loading due to stack being over-written!
                      (         util.asm):00068         
F040 9E74             (         util.asm):00069                         ldx             <AddrRamTop                             ; Get top of RAM
F042 9F27             (         util.asm):00070                         stx             <AddrFWareRamTop                ; Firmware ramtop, last basic used address
F044 3089FF38         (         util.asm):00071                         leax    -200,x                                  ; 200 bytes string space
F048 9F21             (         util.asm):00072                         stx             <AddrStack                              ; Stack address here
F04A BDAE6F           (         util.asm):00073                         jsr             ClearEntry                              ; perform a clear, moves stack!
F04D BDAD19           (         util.asm):00074                         jsr             >BasNew                                 ; Do a 'new'
F050 3420             (         util.asm):00075                         pshs    y                                               ; restore our return address!
F052 39               (         util.asm):00076                         rts
                      (         util.asm):00077         
F053                  (         util.asm):00078         __utils_end
                      (    DragonMMC.asm):00678                         use     interrupt.asm
                      (    interrupt.asm):00001         ;
                      (    interrupt.asm):00002         ; New NMI handler, for 'Snap' button on DragonMMC.
                      (    interrupt.asm):00003         ;
                      (    interrupt.asm):00004         
                      (    interrupt.asm):00005         ;
                      (    interrupt.asm):00006         ; Initialize the interrupt vector area at the top of memory
                      (    interrupt.asm):00007         ;
                      (    interrupt.asm):00008         
F053                  (    interrupt.asm):00009         __interrupt
                      (    interrupt.asm):00010         
     05C0             (    interrupt.asm):00011         MenuLoc         equ             TextScreenBase+(14*TextLineLen)                 ; Address of NMI menu
                      (    interrupt.asm):00012         
     0009             (    interrupt.asm):00013         FileNameLen     equ     9               ; Filename length including terminating 0
     0500             (    interrupt.asm):00014         TempS           equ     $500            ; Tempory S whilst loading image 
                      (    interrupt.asm):00015         
     0000             (    interrupt.asm):00016         LoadBlock1      equ     $0000           ; beginning of first image load block 
     0600             (    interrupt.asm):00017         LoadBlock1a     equ     $0600           ; Top of text screen
     4000             (    interrupt.asm):00018         LoadBlock2      equ     $4000           ; beginning of second image load block 
     8000             (    interrupt.asm):00019         LoadEnd         equ     $8000           ; End of load area (beginning of ROM)
                      (    interrupt.asm):00020         
F053                  (    interrupt.asm):00021         InterruptInit
F053 3401             (    interrupt.asm):00022                         pshs    cc                                              ; save ccr
F055 1A50             (    interrupt.asm):00023                         orcc    #FlagIRQ+FlagFIRQ               ; disable interrupts
                      (    interrupt.asm):00024                         
F057 308D002D         (    interrupt.asm):00025                 leax    NewNMI,pcr              ; get new vector
F05B BF010A           (    interrupt.asm):00026                 stx     SecVecNMI+1             ; set it up
F05E 867E             (    interrupt.asm):00027                 lda     #$7E                    ; JMP opcode
F060 B70109           (    interrupt.asm):00028                 sta     SecVecNMI               ; fill in jump
                      (    interrupt.asm):00029                 
                      (    interrupt.asm):00030         ;               ldx     #MonStart               ; Set SWI->mon
                      (    interrupt.asm):00031         ;        stx            SecVecSWI+1                             ; Temp point SWI at it so we can test in MESS!
                      (    interrupt.asm):00032         ;               sta             SecVecSWI
                      (    interrupt.asm):00033         
F063 BDE020           (    interrupt.asm):00034                         jsr             MMC_GetRAMCTRL                  ; Go get current value
F066 849D             (    interrupt.asm):00035                         anda    #~(D_NMI_ENABLE+D_RAM_VEC+D_RAM_VEC_WP) ; Disable NMI + Select rom vectors, remove write prot on RAM vectors
F068 3402             (    interrupt.asm):00036                         pshs    a                                               ; save current RAM_CTRL
F06A BDE028           (    interrupt.asm):00037                         jsr             MMC_SetRAMCTRL                  ; and update
                      (    interrupt.asm):00038                         
                      (    interrupt.asm):00039         ;       lda     D_RAM_CTRL              ; Get ram control       
                      (    interrupt.asm):00040         ;               anda    #~(D_NMI_ENABLE+D_RAM_VEC+D_RAM_VEC_WP) ; Disable NMI + Select rom vectors, remove write prot on RAM vectors
                      (    interrupt.asm):00041         ;               sta             D_RAM_CTRL
                      (    interrupt.asm):00042         ;               pshs    a                                               ; save current RAM_CTRL
                      (    interrupt.asm):00043         
                      (    interrupt.asm):00044         ;
                      (    interrupt.asm):00045         ; Copy hardware interrupt vectors from ROM to RAM, as writes always go to RAM, no need to swap.
                      (    interrupt.asm):00046         ;
                      (    interrupt.asm):00047         ; 2024-11-07, Modified to do a byte at a time, yes a word at a time is fatser, but for
                      (    interrupt.asm):00048         ; 16 bytes worth this is not going to be significant.
                      (    interrupt.asm):00049         ; The reason for this change is that the Pico code uses a read of the reset vector bytes one 
                      (    interrupt.asm):00050         ; after the other to detect a reset (as this is how it is fetched at reset time). 
                      (    interrupt.asm):00051         ; Unfortunately moving the vectors a word at a time will also trigger this causing the Pico
                      (    interrupt.asm):00052         ; to think it is getting a reset, and clearing it's copy of the SAM registers.
                      (    interrupt.asm):00053         ; By doing this a byte at a time, it should not trigger this behavior as there will be 
                      (    interrupt.asm):00054         ; instruction fetches between the two vector bytes.
                      (    interrupt.asm):00055          
F06D 860E             (    interrupt.asm):00056                         lda             #HWVecCount*2                   ; No of vectors * bytes/vector
F06F 8EFFF2           (    interrupt.asm):00057                         ldx             #HWVecBase                              ; point to base
F072                  (    interrupt.asm):00058         IntCopyLoop
F072 E684             (    interrupt.asm):00059                         ldb             ,x                                              ; get vector
F074 E780             (    interrupt.asm):00060                         stb             ,x+                                             ; put it in RAM 
F076 4A               (    interrupt.asm):00061                         deca                                                    ; decrement counter
F077 26F9             (    interrupt.asm):00062                         bne             IntCopyLoop
                      (    interrupt.asm):00063                 
F079 8EF088           (    interrupt.asm):00064                 ldx     #NewNMI                 ; set newnmi
F07C BFFFFC           (    interrupt.asm):00065                 stx     HWVecNMI                
                      (    interrupt.asm):00066             
                      (    interrupt.asm):00067         ;        ldx     #MonStart               ; Set SWI->mon
                      (    interrupt.asm):00068         ;        stx     HWVecSWI
                      (    interrupt.asm):00069             
F07F 3502             (    interrupt.asm):00070                         puls    a                                               ; recover saved  RAM_CTRL
F081 8A62             (    interrupt.asm):00071                 ora             #D_NMI_ENABLE+D_RAM_VEC+D_RAM_VEC_WP    ; Enable NMI routing + RAM vectors, write protect RAM vectors.
F083 BDE028           (    interrupt.asm):00072                         jsr             MMC_SetRAMCTRL                  ; and update
                      (    interrupt.asm):00073                                
F086 3581             (    interrupt.asm):00074                         puls    cc,pc                                   ; restore CC (and int flags if enabled) + return
                      (    interrupt.asm):00075                 
                      (    interrupt.asm):00076         ;
                      (    interrupt.asm):00077         ; We are in the NMI handler, and therefore the registers of the 
                      (    interrupt.asm):00078         ; currently running program are saved on the stack, so we are free 
                      (    interrupt.asm):00079         ; to use them as long as S is the same at exit. 
                      (    interrupt.asm):00080         ;
F088                  (    interrupt.asm):00081         NewNMI
                      (    interrupt.asm):00082         ; Disable NMI so we don't get called recursively
F088 BDE020           (    interrupt.asm):00083                         jsr             MMC_GetRAMCTRL                  ; Go get current value
F08B 84BF             (    interrupt.asm):00084                 anda    #~D_NMI_ENABLE          ; Mask out NMI enable
F08D BDE028           (    interrupt.asm):00085                         jsr             MMC_SetRAMCTRL                  ; and update
                      (    interrupt.asm):00086         
F090 338D019A         (    interrupt.asm):00087                 leau    NMI_SavePIA,pcr         ; save PIA register contents on stack
F094 1E53             (    interrupt.asm):00088                 exg     pc,u                    ; call subroutine without using stack!
                      (    interrupt.asm):00089         
                      (    interrupt.asm):00090         ;               ldd     D_SAMBITS_MSB           ; get sambits into D
                      (    interrupt.asm):00091         ; New code for Pico, read SAM bits from pico
F096 86EF             (    interrupt.asm):00092                         lda             #CMD_GET_SAMBITS
F098 BDE00E           (    interrupt.asm):00093                         jsr             MMC_SendCmd                             ; Send the command, and wait for it.
                      (    interrupt.asm):00094                         
F09B 8620             (    interrupt.asm):00095                         lda             #CMD_INIT_READ                  ; read the data
F09D BDE017           (    interrupt.asm):00096                         jsr             MMC_SendCmdRaw                  
                      (    interrupt.asm):00097                         
F0A0 B6FF52           (    interrupt.asm):00098                         lda             D_READ_DATA_REG                 ; get MSB
F0A3 F6FF52           (    interrupt.asm):00099                         ldb             D_READ_DATA_REG                 ; get LSB
F0A6 3406             (    interrupt.asm):00100                         pshs    D                                               ; save on stack
                      (    interrupt.asm):00101         
F0A8 DC88             (    interrupt.asm):00102                         ldd             <TextVDUCursAddr                ; Save cursor address
F0AA 3406             (    interrupt.asm):00103                         pshs    d
                      (    interrupt.asm):00104                         
F0AC 4F               (    interrupt.asm):00105                 clra                            ; DP=0, as ROM routines assume this.
F0AD 1F8B             (    interrupt.asm):00106                 tfr     a,dp
                      (    interrupt.asm):00107                 
F0AF BD95AC           (    interrupt.asm):00108                 jsr     >TextResetVDU           ; Go to text mode
                      (    interrupt.asm):00109                 
F0B2 8E05C0           (    interrupt.asm):00110                         ldx             #MenuLoc                                ; Beginning of line #14
F0B5 9F88             (    interrupt.asm):00111                         stx             <TextVDUCursAddr                ; set cursor address
                      (    interrupt.asm):00112                         
F0B7                  (    interrupt.asm):00113         SaveTextLoop
F0B7 EC81             (    interrupt.asm):00114                         ldd             ,x++                                    ; Get bytes from screen
F0B9 3406             (    interrupt.asm):00115                         pshs    d                                               ; save on stack
F0BB 8C0600           (    interrupt.asm):00116                         cmpx    #$600                                   ; end of screen?
F0BE 25F7             (    interrupt.asm):00117                         blo             SaveTextLoop                    ; keep going
                      (    interrupt.asm):00118                         
F0C0 308D01D8         (    interrupt.asm):00119                         leax    NMIMenu1,pcr                    ; point to menu text
F0C4 318D020A         (    interrupt.asm):00120                         leay    NMIMenuTable1,pcr               ; Keycodes & jump table
F0C8 8D27             (    interrupt.asm):00121                         bsr             NMIMenu
                      (    interrupt.asm):00122              
F0CA                  (    interrupt.asm):00123         NMI_Exit
                      (    interrupt.asm):00124         
F0CA 8E0600           (    interrupt.asm):00125                         ldx             #$600                                   ; end of screen
F0CD                  (    interrupt.asm):00126         RestoreTextLoop
F0CD 3506             (    interrupt.asm):00127                         puls    d                                               ; get bytes
F0CF ED83             (    interrupt.asm):00128                         std             ,--x                                    ; save on screen
F0D1 8C05C0           (    interrupt.asm):00129                         cmpx    #MenuLoc                                ; done all?
F0D4 22F7             (    interrupt.asm):00130                         bhi             RestoreTextLoop                 ; nope keep going
                      (    interrupt.asm):00131         
F0D6 3506             (    interrupt.asm):00132                         puls    d                                               ; restore cursor address
F0D8 DD88             (    interrupt.asm):00133                         std             <TextVDUCursAddr
                      (    interrupt.asm):00134                         
F0DA 3506             (    interrupt.asm):00135                         puls    D                                               ; restore sambits
F0DC 17013A           (    interrupt.asm):00136                         lbsr    SetSambits                              ; set them
                      (    interrupt.asm):00137                         
F0DF 338D0180         (    interrupt.asm):00138                 leau    NMI_RestorePIA,pcr      ; save PIA register contents on stack
F0E3 1E53             (    interrupt.asm):00139                 exg     pc,u                    ; call subroutine without using stack!
                      (    interrupt.asm):00140         
F0E5 8D01             (    interrupt.asm):00141                 bsr     NMI_Enable
F0E7 3B               (    interrupt.asm):00142                 rti                             ; return.
                      (    interrupt.asm):00143         
F0E8                  (    interrupt.asm):00144         NMI_Enable
F0E8 BDE020           (    interrupt.asm):00145                         jsr             MMC_GetRAMCTRL                  ; Go get current value
F0EB 8A40             (    interrupt.asm):00146                 ora     #D_NMI_ENABLE           ; Enable NMI routing
F0ED BDE028           (    interrupt.asm):00147                         jsr             MMC_SetRAMCTRL                  ; and update
F0F0 39               (    interrupt.asm):00148                 rts
                      (    interrupt.asm):00149         
F0F1                  (    interrupt.asm):00150         NMIMenu
F0F1 C60F             (    interrupt.asm):00151                         ldb     #15                     ; clear bottom two lines
F0F3 BDF011           (    interrupt.asm):00152                 jsr     >CON_ClearLineB         ; line 15
F0F6 5A               (    interrupt.asm):00153                 decb    
F0F7 BDF011           (    interrupt.asm):00154                 jsr     >CON_ClearLineB         ; line 14
                      (    interrupt.asm):00155                 
F0FA 3430             (    interrupt.asm):00156                 pshs    x,y                                             ; save pointer to text & table
F0FC BDEF46           (    interrupt.asm):00157                 jsr     CON_WriteString
F0FF                  (    interrupt.asm):00158         WaitKey
F0FF BDA1C1           (    interrupt.asm):00159                         jsr             BasicKbdIn                              ; Read keyboard
F102 8100             (    interrupt.asm):00160                         cmpa    #0                                              ; Key pressed?
F104 27F9             (    interrupt.asm):00161                         beq             WaitKey                                 ; nope loop again
                      (    interrupt.asm):00162                         
F106                  (    interrupt.asm):00163         check_next
F106 A1A4             (    interrupt.asm):00164                         cmpa    ,y                                              ; Check key from table?
F108 2607             (    interrupt.asm):00165                         bne             try_next                                ; no try next
                      (    interrupt.asm):00166                         
F10A 3422             (    interrupt.asm):00167                         pshs    a,y                                             ; save on stack
F10C ADB801           (    interrupt.asm):00168                         jsr             [1,y]                                   ; Jump to handler
                      (    interrupt.asm):00169         
F10F 3522             (    interrupt.asm):00170                         puls    a,y                                             ; restore
                      (    interrupt.asm):00171                         
F111                  (    interrupt.asm):00172         try_next
F111 3123             (    interrupt.asm):00173                         leay    3,y                                             ; next entry in table
F113 6DA4             (    interrupt.asm):00174                         tst             ,y                                              ; last entry?
F115 26EF             (    interrupt.asm):00175                         bne             check_next                              ; nope loop again
                      (    interrupt.asm):00176                         
F117 10AE21           (    interrupt.asm):00177                         ldy             1,y                                             ; recover pointer to table beginning
F11A 20E3             (    interrupt.asm):00178                         bra             WaitKey                                 ; invalid key keep going!
                      (    interrupt.asm):00179         
F11C                  (    interrupt.asm):00180         NMIMenuExit
F11C 3265             (    interrupt.asm):00181                         leas    5,s                                             ; drop return address & saved a,y
F11E 35B0             (    interrupt.asm):00182                         puls    x,y,pc                                  ; restore and return
                      (    interrupt.asm):00183         
                      (    interrupt.asm):00184              
                      (    interrupt.asm):00185                         
F120                  (    interrupt.asm):00186         NMICold
F120 0F71             (    interrupt.asm):00187                         clr             WarmStartFlag                   ; clear warm start flag
                      (    interrupt.asm):00188         
F122 BDE020           (    interrupt.asm):00189                         jsr             MMC_GetRAMCTRL                  ; Go get current value
F125 8408             (    interrupt.asm):00190                 anda    #D_ROM_A14              ; Reset all bits *EXECPT* rom select           
F127 BDE028           (    interrupt.asm):00191                         jsr             MMC_SetRAMCTRL                  ; and update
                      (    interrupt.asm):00192         
                      (    interrupt.asm):00193         ; Clear the RAM on cold boot.
                      (    interrupt.asm):00194                 
F12A 4F               (    interrupt.asm):00195                 clra                            ; D=0, X=0
F12B 5F               (    interrupt.asm):00196                 clrb
                      (    interrupt.asm):00197                 
F12C 1F01             (    interrupt.asm):00198                 tfr     d,x
F12E                  (    interrupt.asm):00199         NMIClearLoop
F12E ED81             (    interrupt.asm):00200                 std     ,x++                    ; save it
F130 8C8000           (    interrupt.asm):00201                 cmpx    #$8000                  ; end of ram
F133 25F9             (    interrupt.asm):00202                 blo     NMIClearLoop
                      (    interrupt.asm):00203                 
F135 2004             (    interrupt.asm):00204                 bra     NMIDoReset
F137                  (    interrupt.asm):00205         NMIWarm
F137 8655             (    interrupt.asm):00206                 lda     #$55                    ; Make sure it's a warm start
F139 9771             (    interrupt.asm):00207                 sta     WarmStartFlag                   
F13B                  (    interrupt.asm):00208         NMIDoReset
F13B 8DAB             (    interrupt.asm):00209                         bsr     NMI_Enable              ; We have to re-enable here for warm start
F13D 6E9FFFFE         (    interrupt.asm):00210                 JMP             [HWVecReset]                    ; Jump to reset vector
                      (    interrupt.asm):00211                         
                      (    interrupt.asm):00212         ;
                      (    interrupt.asm):00213         ; Save a dump of memory to card, prompts for filename and dumps memory to that file.
                      (    interrupt.asm):00214         ; not yet error checked, and will overwrite exiting files.
                      (    interrupt.asm):00215         ;
                      (    interrupt.asm):00216                 
F141                  (    interrupt.asm):00217         NMISave
F141 8D2C             (    interrupt.asm):00218                 bsr     NMIGetSendFileName      ; Get filename, send to AVR
                      (    interrupt.asm):00219                 
F143 8600             (    interrupt.asm):00220                         lda             #CAS_FILE                               ; file id of cas file
F145 17EED3           (    interrupt.asm):00221                         lbsr    MMC_WaitPutLatchRead    ; send it to latch register
                      (    interrupt.asm):00222         
F148 861A             (    interrupt.asm):00223                         lda             #CMD_FILE_OPEN_SNAPW    ; Open snapshot file for write file
F14A 17EEC1           (    interrupt.asm):00224                         lbsr    MMC_SendCmd                     ; Open file
                      (    interrupt.asm):00225         
F14D 1F40             (    interrupt.asm):00226                 tfr     s,d                     ; get copy of stack pointer
F14F BDEC84           (    interrupt.asm):00227                 jsr     >MMC_InitSendBytes      ; send S to file
F152 BDED61           (    interrupt.asm):00228                 jsr     >MMC_WriteD             ; Write S to file
                      (    interrupt.asm):00229         
F155 8602             (    interrupt.asm):00230                 lda     #2                      ; 2 bytes
F157 BDED86           (    interrupt.asm):00231                 jsr     >MMC_WriteAFromAVRBuf   ; Write to file.
                      (    interrupt.asm):00232         
F15A 8E0000           (    interrupt.asm):00233                 ldx     #LoadBlock1             ; start of RAM
                      (    interrupt.asm):00234                 
F15D                  (    interrupt.asm):00235         NMISaveLoop
F15D 5F               (    interrupt.asm):00236                 clrb                            ; 256 bytes
F15E BDED72           (    interrupt.asm):00237                         jsr     >MMC_WriteFileBlock     ; write to MMC
                      (    interrupt.asm):00238                 
F161 8C8000           (    interrupt.asm):00239                 cmpx    #LoadEnd                ; End of RAM?
F164 25F7             (    interrupt.asm):00240                 blo     NMISaveLoop             ; no do next block
                      (    interrupt.asm):00241                 
F166 17FB67           (    interrupt.asm):00242                 lbsr    MMC_CloseFile               ; close the file
                      (    interrupt.asm):00243         
F169 C60F             (    interrupt.asm):00244                 ldb     #15                     ; Clear last line
F16B BDF011           (    interrupt.asm):00245                 jsr     >CON_ClearLineB         
                      (    interrupt.asm):00246                 
F16E 39               (    interrupt.asm):00247                         rts
                      (    interrupt.asm):00248         
F16F                  (    interrupt.asm):00249         NMIGetSendFileName
F16F C60F             (    interrupt.asm):00250                 ldb     #15                     ; Line 15
F171 308D0146         (    interrupt.asm):00251                 leax    FilePrompt,pcr          ; Point to prompt
F175 BDF029           (    interrupt.asm):00252                 jsr     >CON_ClearBPrintX       ; print it
                      (    interrupt.asm):00253                 
F178 3277             (    interrupt.asm):00254                 leas    -FileNameLen,s          ; Make room on stack
                      (    interrupt.asm):00255                 
F17A 30E4             (    interrupt.asm):00256                 leax    ,s                      ; get pointer to buffer
F17C C609             (    interrupt.asm):00257                 ldb     #FileNameLen            ; filename length
F17E BDEFCD           (    interrupt.asm):00258                 jsr     >CON_InputBufXB         ; go read it
                      (    interrupt.asm):00259                 
F181 BDECB9           (    interrupt.asm):00260                 jsr     >MMC_SendTillZero       ; send filename to AVR
                      (    interrupt.asm):00261                 
F184 3269             (    interrupt.asm):00262                 leas    FileNameLen,s           ; discard buffer
                      (    interrupt.asm):00263                 
F186 308D013C         (    interrupt.asm):00264                 leax    SnapExt,pcr             ; point to extension
F18A C604             (    interrupt.asm):00265                 ldb     #4                      ; 4 bytes in extension
F18C 7EECAF           (    interrupt.asm):00266                 jmp     >MMC_SendName2          ; send the name
                      (    interrupt.asm):00267         
                      (    interrupt.asm):00268         ;
                      (    interrupt.asm):00269         ; Load a snapshot file from card, will need to load the file in parts
                      (    interrupt.asm):00270         ; so as to avoid over-writing stack.
                      (    interrupt.asm):00271         ; Proposed method is : 
                      (    interrupt.asm):00272         ;   check / move** stack to top 16K of RAM, then load in the first 16K.
                      (    interrupt.asm):00273         ;   move stack pointer to the screen area at $500, and load the top 16K.
                      (    interrupt.asm):00274         ;   read the real stack pointer loaction from the file (first 2 bytes) and set it.
                      (    interrupt.asm):00275         ;   re-read the screen ram at $400.
                      (    interrupt.asm):00276         ;   return from the load routine which will return into the snap menu. 
                      (    interrupt.asm):00277         
                      (    interrupt.asm):00278         
F18F                  (    interrupt.asm):00279         NMILoad
F18F 8DDE             (    interrupt.asm):00280                 bsr     NMIGetSendFileName      ; Get filename, send to AVR
                      (    interrupt.asm):00281                 
F191 8600             (    interrupt.asm):00282                         lda             #CAS_FILE                               ; file id of cas file
F193 17EE85           (    interrupt.asm):00283                         lbsr    MMC_WaitPutLatchRead    ; send it to latch register
                      (    interrupt.asm):00284         
F196 8619             (    interrupt.asm):00285                         lda             #CMD_FILE_OPEN_SNAPR    ; Open snapshot for read 
F198 17EE73           (    interrupt.asm):00286                         lbsr    MMC_SendCmd                     ; Open file
F19B 2B63             (    interrupt.asm):00287                 bmi     NMILoadError            ; error opening file
F19D                  (    interrupt.asm):00288         NMILoadEntry               
F19D 118C4000         (    interrupt.asm):00289                 cmps    #LoadBlock2             ; Is stack in top of RAM?
F1A1 2404             (    interrupt.asm):00290                 bhs     NMIStackHigh            ; yes : do nothing
F1A3 10CE7FFF         (    interrupt.asm):00291                 lds     #LoadEnd-1              ; no : move to top of ram
                      (    interrupt.asm):00292                 
F1A7                  (    interrupt.asm):00293         NMIStackHigh        
F1A7 17FBA8           (    interrupt.asm):00294                 lbsr    MMC_ReadDFile           ; Read saved S (skip past it)
F1AA 3406             (    interrupt.asm):00295                 pshs    d                       ; Save stapshot's S
                      (    interrupt.asm):00296                 
                      (    interrupt.asm):00297         ; Load the first 16K of the image        
F1AC 8E0000           (    interrupt.asm):00298                 ldx     #LoadBlock1             ; begin loading at bottom of RAM
F1AF                  (    interrupt.asm):00299         NMILoadLoop1
F1AF 5F               (    interrupt.asm):00300                 clrb                            ; flag 256 bytes
F1B0 BDED24           (    interrupt.asm):00301                 jsr     >MMC_ReadFileBlockRaw   ; read a block
F1B3 8C4000           (    interrupt.asm):00302                 cmpx    #LoadBlock2             ; top of first 16K
F1B6 26F7             (    interrupt.asm):00303                 bne     NMILoadLoop1            ; no : keep loading
                      (    interrupt.asm):00304         
                      (    interrupt.asm):00305         ; We have loaded the first 16K of the image, move stack pointer to $500        
F1B8 3506             (    interrupt.asm):00306                 puls    d                       ; recover saved snapshot S
F1BA 10834000         (    interrupt.asm):00307                 cmpd    #LoadBlock2             ; in already laded RAM ?
F1BE 2404             (    interrupt.asm):00308                 bhs     NMITempS                ; no : use temp stack in screen ram
F1C0 1F04             (    interrupt.asm):00309                 tfr     d,s                     ; yes : make it active
F1C2 2004             (    interrupt.asm):00310                 bra     NMIDoBlock2             ; Go load upper ram
                      (    interrupt.asm):00311                 
F1C4                  (    interrupt.asm):00312         NMITempS        
F1C4 10CE0500         (    interrupt.asm):00313                 lds     #TempS                  ; setup temp stack
F1C8                  (    interrupt.asm):00314         NMIDoBlock2        
F1C8 8E4000           (    interrupt.asm):00315                 ldx     #LoadBlock2             ; begin loading at bottom of RAM
F1CB                  (    interrupt.asm):00316         NMILoadLoop2
F1CB 5F               (    interrupt.asm):00317                 clrb                            ; flag 256 bytes
F1CC BDED24           (    interrupt.asm):00318                 jsr     >MMC_ReadFileBlockRaw   ; read a block
F1CF 8C8000           (    interrupt.asm):00319                 cmpx    #LoadEnd                ; top of first 16K
F1D2 26F7             (    interrupt.asm):00320                 bne     NMILoadLoop2            ; no : keep loading
                      (    interrupt.asm):00321                 
                      (    interrupt.asm):00322         ; we now have loaded the whole image, except the text screen ram which we used as
                      (    interrupt.asm):00323         ; a stack. We need to position the stack pointer at the saved stack pointer and
                      (    interrupt.asm):00324         ; re-load the screen ram from $400-$500        
F1D4 8600             (    interrupt.asm):00325                         lda             #CAS_FILE                               ; file id of cas file
F1D6 17EE42           (    interrupt.asm):00326                         lbsr    MMC_WaitPutLatchRead    ; send it to latch register
                      (    interrupt.asm):00327                         
F1D9 8624             (    interrupt.asm):00328                 lda     #CMD_REWIND             ; rewind file to beginning
F1DB BDE00E           (    interrupt.asm):00329                 jsr     >MMC_SendCmd            
                      (    interrupt.asm):00330                 
F1DE 17FB71           (    interrupt.asm):00331                 lbsr    MMC_ReadDFile           ; Read saved S        
F1E1 1F04             (    interrupt.asm):00332                 tfr     d,s                     ; setup loaded stack pointer
                      (    interrupt.asm):00333         
F1E3 10834000         (    interrupt.asm):00334                 cmpd    #LoadBlock2             ; in bottom of RAM?
F1E7 250C             (    interrupt.asm):00335                 blo     NMINoBlock3             ; yes no need to re-read bottom of RAM
                      (    interrupt.asm):00336         
F1E9 8E0000           (    interrupt.asm):00337                 ldx     #LoadBlock1             ; begin loading at bottom of RAM
F1EC                  (    interrupt.asm):00338         NMILoadLoop3
F1EC 5F               (    interrupt.asm):00339                 clrb                            ; flag 256 bytes
F1ED BDED24           (    interrupt.asm):00340                 jsr     >MMC_ReadFileBlockRaw   ; read a block
F1F0 8C0600           (    interrupt.asm):00341                 cmpx    #LoadBlock1a            ; top of text screen
F1F3 26F7             (    interrupt.asm):00342                 bne     NMILoadLoop3            ; no : keep loading
                      (    interrupt.asm):00343         
F1F5                  (    interrupt.asm):00344         NMINoBlock3 
                      (    interrupt.asm):00345         
F1F5 17FAD8           (    interrupt.asm):00346                 lbsr    MMC_CloseFile               ; close the file
F1F8 17FE58           (    interrupt.asm):00347                 lbsr    InterruptInit           ; Reinit our vectors as they may be different in image
                      (    interrupt.asm):00348              
F1FB 326B             (    interrupt.asm):00349                 leas    11,s                    ; Drop bytes saved by menu etc
F1FD 7EF0CA           (    interrupt.asm):00350                 jmp     NMI_Exit                ; exit NMI back to loaded program
                      (    interrupt.asm):00351                 
F200                  (    interrupt.asm):00352         NMILoadError
F200 3402             (    interrupt.asm):00353                 pshs    a                       ; save error code
F202 C60F             (    interrupt.asm):00354                 ldb     #15                     ; Line 15
F204 308D00C2         (    interrupt.asm):00355                 leax    ErrorMess1,pcr          ; Point to message
F208 BDF029           (    interrupt.asm):00356                 jsr     >CON_ClearBPrintX       ; print it
                      (    interrupt.asm):00357                 
F20B 3502             (    interrupt.asm):00358                 puls    a                       ; retrieve error code
F20D BDEEAA           (    interrupt.asm):00359                 jsr     >CON_WriteHexByte        ; write it.
                      (    interrupt.asm):00360                 
F210 308D00B6         (    interrupt.asm):00361                 leax    ErrorMess1,pcr          ; Point to message
F214 BDEF46           (    interrupt.asm):00362                 jsr     CON_WriteString         ; print it
                      (    interrupt.asm):00363                 
F217 39               (    interrupt.asm):00364                 rts
                      (    interrupt.asm):00365                 
F218                  (    interrupt.asm):00366         NMIUtil
F218 39               (    interrupt.asm):00367                         rts
                      (    interrupt.asm):00368                                 
                      (    interrupt.asm):00369         ;
                      (    interrupt.asm):00370         ; On entry D contains SAM bits to set.
                      (    interrupt.asm):00371         ;       
                      (    interrupt.asm):00372         ; We only set the graphics mode and offset bits, we should not need to touch
                      (    interrupt.asm):00373         ; the memory type & CPU speed as they should not have been changed.
                      (    interrupt.asm):00374         ;
F219                  (    interrupt.asm):00375         SetSambits
F219 8EFFC0           (    interrupt.asm):00376                         ldx             #SAMBase                                ; point at base of SAM registers
                      (    interrupt.asm):00377         
F21C                  (    interrupt.asm):00378         SetSambitsLoop          
F21C 44               (    interrupt.asm):00379                         lsra                                                    ; bottom bit into carry
F21D 56               (    interrupt.asm):00380                         rorb                                                    ; carry-> top bit, bottom bit into carry
F21E 2504             (    interrupt.asm):00381                         bcs             SetSambit                               ; yes set it
F220 6F84             (    interrupt.asm):00382                         clr             ,x                                              ; Clear sam bit
F222 2002             (    interrupt.asm):00383                         bra             NextBit
F224                  (    interrupt.asm):00384         SetSambit
F224 6F01             (    interrupt.asm):00385                         clr             1,x                                             ; set sambit
F226                  (    interrupt.asm):00386         NextBit
F226 3002             (    interrupt.asm):00387                         leax    2,x                                             ; next bit
F228 8CFFD4           (    interrupt.asm):00388                         cmpx    #SAMCP1                                 ; done all?
F22B 25EF             (    interrupt.asm):00389                         blo             SetSambitsLoop                  ; no : go again
F22D 39               (    interrupt.asm):00390                         rts
                      (    interrupt.asm):00391                         
                      (    interrupt.asm):00392         ;
                      (    interrupt.asm):00393         ; Save PIA registers on stack :
                      (    interrupt.asm):00394         ;
                      (    interrupt.asm):00395         ; CRA           <- highest address
                      (    interrupt.asm):00396         ; DDRA
                      (    interrupt.asm):00397         ; PA
                      (    interrupt.asm):00398         ; CRB
                      (    interrupt.asm):00399         ; DDRB
                      (    interrupt.asm):00400         ; DB            <- lowest address
                      (    interrupt.asm):00401         ;
                      (    interrupt.asm):00402         ; This is repeated for PIA2
                      (    interrupt.asm):00403         ;
F22E                  (    interrupt.asm):00404         NMI_SavePIA
F22E 8EFF00           (    interrupt.asm):00405                 ldx     #PIA0DA                 ; point to PIA0
                      (    interrupt.asm):00406         
F231                  (    interrupt.asm):00407         NMI_SavePIALoop
F231 A601             (    interrupt.asm):00408                 lda     1,x                     ; get control register A side
F233 3402             (    interrupt.asm):00409                 pshs    a                       ; save it
                      (    interrupt.asm):00410                 
F235 84FB             (    interrupt.asm):00411                 anda    #$FF-PIACRDDR           ; select DDR
F237 A701             (    interrupt.asm):00412                 sta     1,x                     
F239 E684             (    interrupt.asm):00413                 ldb     ,x                      ; Get DDR
F23B 3404             (    interrupt.asm):00414                 pshs    b
                      (    interrupt.asm):00415                 
F23D 8A04             (    interrupt.asm):00416                 ora     #PIACRDDR               ; select data register
F23F A701             (    interrupt.asm):00417                 sta     1,x
F241 E684             (    interrupt.asm):00418                 ldb     ,x
F243 3404             (    interrupt.asm):00419                 pshs    b
                      (    interrupt.asm):00420                 
F245 A603             (    interrupt.asm):00421                 lda     3,x                     ; get control register A side
F247 3402             (    interrupt.asm):00422                 pshs    a                       ; save it
                      (    interrupt.asm):00423                 
F249 84FB             (    interrupt.asm):00424                 anda    #$FF-PIACRDDR           ; select DDR
F24B A703             (    interrupt.asm):00425                 sta     3,x                     
F24D E602             (    interrupt.asm):00426                 ldb     2,x                     ; Get DDR
F24F 3404             (    interrupt.asm):00427                 pshs    b
                      (    interrupt.asm):00428                 
F251 8A04             (    interrupt.asm):00429                 ora     #PIACRDDR               ; select data register
F253 A703             (    interrupt.asm):00430                 sta     3,x
F255 E602             (    interrupt.asm):00431                 ldb     2,x
F257 3404             (    interrupt.asm):00432                 pshs    b
                      (    interrupt.asm):00433                 
F259 308820           (    interrupt.asm):00434                 leax    $20,x                   ; do next PIA
F25C 8CFF40           (    interrupt.asm):00435                 cmpx    #$FF40                  ; Done both ?
F25F 25D0             (    interrupt.asm):00436                 blo     NMI_SavePIALoop         ; no go again.
                      (    interrupt.asm):00437                 
F261 1E53             (    interrupt.asm):00438                 exg     pc,u                    ; return to caller
                      (    interrupt.asm):00439         
                      (    interrupt.asm):00440                 
F263                  (    interrupt.asm):00441         NMI_RestorePIA
F263 8EFF20           (    interrupt.asm):00442                 ldx     #PIA1DA                 ; point to PIA1
                      (    interrupt.asm):00443         
F266                  (    interrupt.asm):00444         NMI_RestorePIALoop
F266 A603             (    interrupt.asm):00445                 lda     3,x                     ; get control register A side
                      (    interrupt.asm):00446         
                      (    interrupt.asm):00447         ; Restore B side
F268 8A04             (    interrupt.asm):00448                 ora     #PIACRDDR               ; select Data reg
F26A A703             (    interrupt.asm):00449                 sta     3,x                     
F26C 3504             (    interrupt.asm):00450                 puls    b                       ; restore it
F26E E702             (    interrupt.asm):00451                 stb     2,x
                      (    interrupt.asm):00452                 
F270 84FB             (    interrupt.asm):00453                 anda    #$FF-PIACRDDR           ; select DDR register
F272 A703             (    interrupt.asm):00454                 sta     3,x
F274 3504             (    interrupt.asm):00455                 puls    b                       ; restore it
F276 E702             (    interrupt.asm):00456                 stb     2,x
                      (    interrupt.asm):00457                 
F278 3502             (    interrupt.asm):00458                 puls    a                       ; Restore CRB
F27A A703             (    interrupt.asm):00459                 sta     3,x
                      (    interrupt.asm):00460         
                      (    interrupt.asm):00461         ;Restore A side
F27C A601             (    interrupt.asm):00462                 lda     1,x                     ; get control register A side
                      (    interrupt.asm):00463         
F27E 8A04             (    interrupt.asm):00464                 ora     #PIACRDDR               ; select Data reg
F280 A701             (    interrupt.asm):00465                 sta     1,x                     
F282 3504             (    interrupt.asm):00466                 puls    b                       ; restore it
F284 E784             (    interrupt.asm):00467                 stb     ,x
                      (    interrupt.asm):00468                 
F286 84FB             (    interrupt.asm):00469                 anda    #$FF-PIACRDDR           ; select DDR register
F288 A701             (    interrupt.asm):00470                 sta     1,x
F28A 3504             (    interrupt.asm):00471                 puls    b                       ; restore it
F28C E784             (    interrupt.asm):00472                 stb     ,x
                      (    interrupt.asm):00473                 
F28E 3502             (    interrupt.asm):00474                 puls    a                       ; Restore CRA
F290 A701             (    interrupt.asm):00475                 sta     1,x
                      (    interrupt.asm):00476            
F292 3088E0           (    interrupt.asm):00477                 leax    -$20,x                  ; do next PIA
F295 8CFF00           (    interrupt.asm):00478                 cmpx    #$FF00                  ; Done both ?
F298 24CC             (    interrupt.asm):00479                 bhs     NMI_RestorePIALoop      ; no go again.
                      (    interrupt.asm):00480                 
F29A 1E53             (    interrupt.asm):00481                 exg     pc,u                    ; return to caller
                      (    interrupt.asm):00482         
                      (    interrupt.asm):00483         ;
                      (    interrupt.asm):00484         ; Data, menu tables messages etc.
                      (    interrupt.asm):00485         ;
                      (    interrupt.asm):00486             
F29C                  (    interrupt.asm):00487         NMIMenu1
                      (    interrupt.asm):00488         ;                                01234567890123456789012345678901
F29C 7741524D20634F4C (    interrupt.asm):00489                         FCC             'wARM cOLD sAVE lOAD uTIL ExIT'
     442073415645206C
     4F4144207554494C
     2045784954
F2B9 0D00             (    interrupt.asm):00490                         FCB             $0d,$00
                      (    interrupt.asm):00491         
F2BB                  (    interrupt.asm):00492         FilePrompt
F2BB 46494C454E414D45 (    interrupt.asm):00493                 FCC     'FILENAME >'
     203E
F2C5 00               (    interrupt.asm):00494                 FCB     $00
                      (    interrupt.asm):00495         
                      (    interrupt.asm):00496         ;
                      (    interrupt.asm):00497         ; Use different extensions for Dragon and CoCo so we don't inadvertently load a snapshot
                      (    interrupt.asm):00498         ; on the wrong platform.
                      (    interrupt.asm):00499         ;
F2C6                  (    interrupt.asm):00500         SnapExt
                      (    interrupt.asm):00501                 ifdef   Dragon
                      (    interrupt.asm):00502                 FCC     '.SSD'
                      (    interrupt.asm):00503                 else
F2C6 2E535343         (    interrupt.asm):00504                 FCC     '.SSC'
                      (    interrupt.asm):00505                 endc
                      (    interrupt.asm):00506                 
F2CA                  (    interrupt.asm):00507         ErrorMess1
F2CA 4552524F523A20   (    interrupt.asm):00508                 FCC     'ERROR: '
F2D1 00               (    interrupt.asm):00509                 FCB     $00
                      (    interrupt.asm):00510         
                      (    interrupt.asm):00511                         ifne    0
F2D2                  (    interrupt.asm):00512         ErrorMess2
                      (    interrupt.asm):00513                 FCC     'OPENING FILE'
                      (    interrupt.asm):00514                 FCB     $00
                      (    interrupt.asm):00515                         endc
                      (    interrupt.asm):00516                         
F2D2                  (    interrupt.asm):00517         NMIMenuTable1
F2D2 57               (    interrupt.asm):00518                         FCB             'W'                                             ; Warm start
F2D3 F137             (    interrupt.asm):00519                         FDB             NMIWarm
                      (    interrupt.asm):00520                         
F2D5 43               (    interrupt.asm):00521                         FCB             'C'                                             ; Cold start
F2D6 F120             (    interrupt.asm):00522                         FDB             NMICold
                      (    interrupt.asm):00523                         
F2D8 53               (    interrupt.asm):00524                         FCB             'S'                                             ; Save snapshot
F2D9 F141             (    interrupt.asm):00525                         FDB             NMISave
                      (    interrupt.asm):00526                         
F2DB 4C               (    interrupt.asm):00527                 FCB             'L'                                             ; Load snapshot
F2DC F18F             (    interrupt.asm):00528                         FDB             NMILoad
                      (    interrupt.asm):00529                                 
F2DE 55               (    interrupt.asm):00530                         FCB             'U'                                             ; Utils
F2DF F218             (    interrupt.asm):00531                         FDB             NMIUtil
                      (    interrupt.asm):00532                         
F2E1 58               (    interrupt.asm):00533                         FCB             'X'                                             ; Exit
F2E2 F11C             (    interrupt.asm):00534                         FDB             NMIMenuExit
                      (    interrupt.asm):00535                         
F2E4 00               (    interrupt.asm):00536                         FCB             0                                               ; end of table
F2E5 F2D2             (    interrupt.asm):00537                         FDB             NMIMenuTable1                   ; pointer back to beginnig of table
                      (    interrupt.asm):00538         
F2E7                  (    interrupt.asm):00539         __interrupt_end
                      (    DragonMMC.asm):00679         ;        use     mon.asm
                      (    DragonMMC.asm):00680         
                      (    DragonMMC.asm):00681         
F2E7                  (    DragonMMC.asm):00682         Inverse
F2E7 BDB26D           (    DragonMMC.asm):00683                         jsr             VarCKComma                              ; Check for comma, SN error if not
F2EA BDB73D           (    DragonMMC.asm):00684                         jsr             VarGet16Bit                             ; Get print pos
F2ED 8C0000           (    DragonMMC.asm):00685                         cmpx    #0                                              ; beforer first?
F2F0 2521             (    DragonMMC.asm):00686                         blo             InvError
F2F2 8C01FF           (    DragonMMC.asm):00687                         cmpx    #$1FF                                   ; beyond end of screen?
F2F5 221C             (    DragonMMC.asm):00688                         bhi             InvError                                ; yep 
                      (    DragonMMC.asm):00689                         
F2F7 30890400         (    DragonMMC.asm):00690                         leax    $400,x                                  ; turn into screen offset
                      (    DragonMMC.asm):00691                         
F2FB 3410             (    DragonMMC.asm):00692                         pshs    x                                               ; save on stack
                      (    DragonMMC.asm):00693                         
F2FD BDB26D           (    DragonMMC.asm):00694                         jsr             VarCKComma                              ; Check for comma, SN error if not
F300 BDB70B           (    DragonMMC.asm):00695                         jsr             VarGet8Bit                              ; Get char count (in b)
                      (    DragonMMC.asm):00696                         
F303 3510             (    DragonMMC.asm):00697                         puls    x
                      (    DragonMMC.asm):00698                         
F305                  (    DragonMMC.asm):00699         InvLoop
F305 A684             (    DragonMMC.asm):00700                         lda             ,x                                              ; get char from screen
F307 8180             (    DragonMMC.asm):00701                         cmpa    #$80                                    ; >$80, semigraphic, leave unchanged.
F309 2402             (    DragonMMC.asm):00702                         bhs             NoInv
F30B 8840             (    DragonMMC.asm):00703                         eora    #$40                                    ; flip bit
F30D                  (    DragonMMC.asm):00704         NoInv
F30D A780             (    DragonMMC.asm):00705                         sta             ,x+                                             ; resave it
F30F 5A               (    DragonMMC.asm):00706                         decb                                                    ; decrement count
F310 26F3             (    DragonMMC.asm):00707                         bne             InvLoop                                 ; not zero loop again
                      (    DragonMMC.asm):00708                 
F312 39               (    DragonMMC.asm):00709                         rts
                      (    DragonMMC.asm):00710                         
F313                  (    DragonMMC.asm):00711         InvError
F313 7EB44A           (    DragonMMC.asm):00712                         jmp             BasFCError
                      (    DragonMMC.asm):00713         
                      (    DragonMMC.asm):00714         
                      (    DragonMMC.asm):00715         ;********************************
                      (    DragonMMC.asm):00716         ;** PLACE NO CODE BELOW HERE ! **
                      (    DragonMMC.asm):00717         ;********************************
                      (    DragonMMC.asm):00718         
F316 0000000000000000 (    DragonMMC.asm):00719                         zmb             $fffd-*
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     0000000000000000
     00000000000000
                      (    DragonMMC.asm):00720                 
FFFD 504853           (    DragonMMC.asm):00721                         FCC             /PHS/
                      (    DragonMMC.asm):00722         ;DE000   END
                      (    DragonMMC.asm):00723                 
